{"pages":[{"title":"Hello,world.","text":"","link":"/Hello-world/index.html"},{"title":"","text":"我已足够幸福，有梦可追，有梦可做！小小的我,有着大大的梦. 一切都会越来越好的, 一切都在向未来奔去, 愿你我各自努力,他日重逢,","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"归档","text":"","link":"/archives/index.html"},{"title":"friend","text":"","link":"/friend/index.html"},{"title":"home","text":"","link":"/home/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"","text":"你可以成为你想成为的人！ 及时止损，立即止损。 直面问题，解决问题。 不要在乎别人怎么想，不寻求认同感。 冥想。 跑步。 定期复盘。 减少被动信息摄入。 知行合一。 面对现实，不要逃避现实。 对错误反思总结。 坚定的从头到尾执行方案。 让别人评估你的进度。 头脑开放。 事事有回落。先利己，后利他。","link":"/plan/index.html"},{"title":"Valine 加密评论功能测试","text":"🔐 Valine 加密评论功能测试功能说明本页面用于测试 Valine 加密评论功能，包含以下特性： ✅ 可选择加密评论（勾选”加密评论”复选框） ✅ 使用固定盐值进行 AES-256-GCM 加密 ✅ 支持富内容加密（文本、图片链接、表情符号等） ✅ 加密评论显示为密文，需要密码解密 ✅ 单条评论独立解密，不支持批量解密 ✅ 美观的 UI 设计，不影响原有布局 测试步骤 在下方评论框中输入测试内容 勾选”加密评论”复选框 点击”回复”按钮 输入加密密码（建议使用：test123） 提交后查看加密评论的显示效果 使用相同密码尝试解密评论 调试信息请打开浏览器开发者工具（F12）查看控制台输出，以便诊断任何问题。 console.log('测试页面加载完成'); console.log('当前页面 URL:', window.location.href); console.log('Valine 对象是否存在:', typeof Valine !== 'undefined'); console.log('AV 对象是否存在:', typeof AV !== 'undefined');","link":"/test-crypto/index.html"},{"title":"","text":"Bookmarks Bookmarks 博客 Python基础 - 廖雪峰的官方网站 保罗的小宇宙 实用网站推荐！你一定会用上！ - Ray's Blog - RAYCODER.ME 想法 - 猫梨の部屋 阮一峰的网络日志 蝉時雨 | 蝉鸣如雨 花宵道中 -陈泽辉 About Me | 宇宙湾 震惊！NLP 顶级赛事 SemEval 那个人居然夺得榜首 关于可爱的 DIYgod | Hi, DIYgod See you in BUPT | See_you_in_BUPT ningzimu/See_you_in_BUPT: 北京邮电大学计算机考研信息汇总 2019 年终总结：新生活、新探索 | 静觅 MingruiYu - 博客园 #0000：Talk is cheap,Show me the code. – 远在上海 猿人学Python - 教你挣钱的Python教程网站 lxw的大数据田地Hadoop/Hive/HBase/Spark/Java 钦念 - 博客园 见字如面 - 抽离自我，冷眼旁观 过往记忆 奇舞周刊 AlloyTeam|腾讯全端 AlloyTeam 团队 淘系前端团队 JDC | 京东设计中心 当然我在扯淡 ZJBLOG —— zj的个人博客 Jadmin的个人博客 | 一个努力成长中的Java后端程序猿 刘未鹏 | Mind Hacks – 思维改变生活 (1条消息) 优秀有价值的博客收藏列表（持续更新）_曹胜欢-CSDN博客 Matrix67: The Aha Moments 罗辑思维 第36集 大家都有拖延症 36-资讯-高清完整正版视频在线观看-优酷 GeekPlux 做爱做的事，看有趣的人 (4条消息) 刘未鹏|C++的罗浮宫_pongba_CSDN博客-C++,片面思考,杂感|生活领域博主 保罗·格雷厄姆 gaclib.net - C++博客 首页 - 老赵点滴 - 追求编程之美 I'm TualatriX OneV's Den Dandy's Blog 林夕水共 不要说话哦 - 全民K歌 归档 | TangShusen idealclover GoodThingList/GoodBlogList.md at master · cnfeat/GoodThingList 优秀个人独立博客推荐名单 – 土木坛子 We Study Billionaires - The Investor's Podcast Network About - 李理的博客 爱影博客 - 生命不息，奋斗不止 www.lylyl.cn 云风的 BLOG 4G Spaces The Big Picture - Macro Perspective on the Capital Markets, Economy, Geopolitics, Technology, and Digital Media 月光博客-关注互联网和搜索引擎的IT科技博客 WNJXYKのBlog – 没有退路 // 唯有一往无前 前端 Zou-Wang / CNblogs-Theme-Sakura：基于Sakura美化的博客园样式 Iconfont-阿里巴巴矢量图标库 在线代码格式化 今日诗词 - 一言API - 诗词实时智能推荐 - 今日诗词开放接口 - 今日诗词 API 免费素材照片 · Pexels 极简壁纸_海量电脑桌面壁纸美图_4K超高清_最潮壁纸网站 Awesome Wallpapers - wallhaven.cc 1392您的名字高清壁纸|墙纸 背景图片-Wallpaper Abyss-页面5 模板制作快速入门 - Typecho Docs 储存库 10 学校网课 首页 计算机网络谢希仁第七版网课_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili 清华大学 JAVA 自主学习教程 （推荐1.25倍数食用）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili 学堂在线-精品中文慕课(mooc)平台 腾讯课堂 云班课 - 我的班课 教学管理系统 工具 FreeV2ray (30 条消息) 你极力推荐的 Chrome 扩展有哪些？ - 知乎 Quora-分享知识和更好地了解世界的地方 字典对象 — Python 3.7.7 文档 Shimmer (shimmer) - 路过图床 正在播放: 青春不打烊（JOKER 2018Mix ） - 王梓钰,音阙诗听 碎碎念 百度学术 - 保持学习的态度 封神台 - 掌控安全在线演练靶场，是一个在线黑客攻防演练平台。 ASCII编码对照表_911查询 站长工具 - 站长之家 ShowDoc 【GitMind官网】- 免费在线思维导图软件 在线工具 - 程序员的工具箱 Inspect Traffic | Progress Telerik Fiddler Everywhere The Best IP Address, Email and Networking Tools - IPAddress.com 在线翻译_有道 计算机 - PDF之家-免费高清PDF电子书下载 腾讯文档 Gridea | 一个静态博客写作客户端 Text to ASCII Art Generator (TAAG) Add Font 100font.com - 免版权字体下载、免费商用字体下载网站 彩虹屁生成器 | chp.shadiao.app 用Chrome学编程 Trending repositories on GitHub today Apache软件基金会 在线文字半角转全角，全角转半角，英文标点转中文、中文标点转英文--查错网 掘金 Shimmer · 语雀 看云 | 专注文档在线创作、阅读、分享和托管 Web of Science [v.5.35] - 所有数据库 基本检索 中国国家图书馆•中国国家数字图书馆 免费logo在线制作 抠图_在线抠图软件_证件照换底色-稿定设计 iLoveIMG 在线修改图像。 CodePen：在线代码编辑器和前端Web开发人员社区 首页 — 猫熊网络加速器 aries15/freess: 免费机场 wantToDoSomeThing/ssSSRV2rayClashTrojan: 科学上网，ss, ssr, v2ray, trojan, clash, clashr，翻墙机场推荐 navicat-keygen: A keygen for Navicat - Gitee.com 首页 - Auto.js 女巫2020_HD中字在线播放-片库 首页 — FASTLINK 免费在线文字识别，文字提取，OCR服务－OCRMaker RGB颜色值与十六进制颜色码转换工具 Initial page - Shimmerの笔记 在线随机密码生成器 - 密码工具箱 - 脚本之家在线工具 Pinterest 电子书世界 - 为阅读而生 计算机电子书下载网-编程pdf电子书下载-码农之家 Criminal Minds S03 COMPLETE / 犯罪心理 第三季全季 Criminal.Minds.S03.720p.WEB-DL.DD5.1.h.264-EbP 简体 字幕下载 - SubHD 配置文件 | PicGo-Core DownGit 奶牛快传 | 传文件 文件下载不限速 小宇宙 AKShare 专题教程 — AKShare 1.0.0 文档 JSON Online Validator and Formatter - JSON Lint Bajins 片库 - 全网高清影视聚合下载 文献 PubsOnLine arXiv.org e-Print archive Frontiers | Peer Reviewed Articles - Open Access Journals About Us 自由的百科全书 2021 - ZHZ.wiki 小屋 Shimmer 博客园 - 开发者的网上家园 cskaoyan 中国研究生招生信息网 北京工业大学研究生招生网 英语词缀大全 2020考研计算机有感（已上岸） - X_Jun - 博客园 中科大软件学院 2021计算机考研有感（已上岸） - KillerAery - 博客园 【新提醒】2020双非二战上岸科软复盘与经验分享（3个月复习408专业课） - 中国科学技术大学 - 王道论坛,专注于计算机考研的点点滴滴！ - Powered by Discuz! 考研百科 解锁考研困惑_中国研究生招生信息网 北京工业大学研究生招生网 书单 『只读经典』思考的技术与艺术（原“学会思考”） 『只读经典』判断与决策 『只读经典』思维改变生活（原“心理学改变生活”） 机器学习与人工智能","link":"/bookmarks/index.html"},{"title":"","text":"碎碎念 Don't forget!","link":"/self-talking/index.html"},{"title":"","text":"/*! * Valine v1.5.3 * (c) 2017-2025 xCss * Released under the GPL-2.0 License. * Last Update: 2025/6/11 21:58:11 */ !function(t,e){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define([],e):\"object\"==typeof exports?exports.Valine=e():t.Valine=e()}(this,function(){return function(t){function e(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return t[r].call(i.exports,i,i.exports,e),i.l=!0,i.exports}var n={};return e.m=t,e.c=n,e.i=function(t){return t},e.d=function(t,n,r){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:r})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,\"a\",n),n},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p=\"\",e(e.s=353)}([function(t,e,n){var r=n(2),i=n(19),o=n(11),s=n(12),u=n(20),a=function(t,e,n){var c,l,f,h,d=t&a.F,p=t&a.G,v=t&a.S,g=t&a.P,m=t&a.B,y=p?r:v?r[e]||(r[e]={}):(r[e]||{}).prototype,b=p?i:i[e]||(i[e]={}),_=b.prototype||(b.prototype={});p&&(n=e);for(c in n)l=!d&&y&&void 0!==y[c],f=(l?y:n)[c],h=m&&l?u(f,r):g&&\"function\"==typeof f?u(Function.call,f):f,y&&s(y,c,f,t&a.U),b[c]!=f&&o(b,c,h),g&&_[c]!=f&&(_[c]=f)};r.core=i,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,e,n){var r=n(4);t.exports=function(t){if(!r(t))throw TypeError(t+\" is not an object!\");return t}},function(t,e){var n=t.exports=\"undefined\"!=typeof window&&window.Math==Math?window:\"undefined\"!=typeof self&&self.Math==Math?self:Function(\"return this\")();\"number\"==typeof __g&&(__g=n)},function(t,e){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,e){t.exports=function(t){return\"object\"==typeof t?null!==t:\"function\"==typeof t}},function(t,e,n){var r=n(50)(\"wks\"),i=n(41),o=n(2).Symbol,s=\"function\"==typeof o;(t.exports=function(t){return r[t]||(r[t]=s&&o[t]||(s?o:i)(\"Symbol.\"+t))}).store=r},function(t,e,n){var r=n(22),i=Math.min;t.exports=function(t){return t>0?i(r(t),9007199254740991):0}},function(t,e,n){t.exports=!n(3)(function(){return 7!=Object.defineProperty({},\"a\",{get:function(){return 7}}).a})},function(t,e,n){var r=n(1),i=n(102),o=n(26),s=Object.defineProperty;e.f=n(7)?Object.defineProperty:function(t,e,n){if(r(t),e=o(e,!0),r(n),i)try{return s(t,e,n)}catch(t){}if(\"get\"in n||\"set\"in n)throw TypeError(\"Accessors not supported!\");return\"value\"in n&&(t[e]=n.value),t}},function(t,e,n){var r=n(24);t.exports=function(t){return Object(r(t))}},function(t,e){t.exports=function(t){if(\"function\"!=typeof t)throw TypeError(t+\" is not a function!\");return t}},function(t,e,n){var r=n(8),i=n(37);t.exports=n(7)?function(t,e,n){return r.f(t,e,i(1,n))}:function(t,e,n){return t[e]=n,t}},function(t,e,n){var r=n(2),i=n(11),o=n(14),s=n(41)(\"src\"),u=n(144),a=(\"\"+u).split(\"toString\");n(19).inspectSource=function(t){return u.call(t)},(t.exports=function(t,e,n,u){var c=\"function\"==typeof n;c&&(o(n,\"name\")||i(n,\"name\",e)),t[e]!==n&&(c&&(o(n,s)||i(n,s,t[e]?\"\"+t[e]:a.join(String(e)))),t===r?t[e]=n:u?t[e]?t[e]=n:i(t,e,n):(delete t[e],i(t,e,n)))})(Function.prototype,\"toString\",function(){return\"function\"==typeof this&&this[s]||u.call(this)})},function(t,e,n){var r=n(0),i=n(3),o=n(24),s=/\"/g,u=function(t,e,n,r){var i=String(o(t)),u=\"\"+i+\"\"};t.exports=function(t,e){var n={};n[t]=e(u),r(r.P+r.F*i(function(){var e=\"\"[t]('\"');return e!==e.toLowerCase()||e.split('\"').length>3}),\"String\",n)}},function(t,e){var n={}.hasOwnProperty;t.exports=function(t,e){return n.call(t,e)}},function(t,e,n){var r=n(49),i=n(37),o=n(17),s=n(26),u=n(14),a=n(102),c=Object.getOwnPropertyDescriptor;e.f=n(7)?c:function(t,e){if(t=o(t),e=s(e,!0),a)try{return c(t,e)}catch(t){}if(u(t,e))return i(!r.f.call(t,e),t[e])}},function(t,e,n){var r=n(14),i=n(9),o=n(84)(\"IE_PROTO\"),s=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),r(t,o)?t[o]:\"function\"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?s:null}},function(t,e,n){var r=n(48),i=n(24);t.exports=function(t){return r(i(t))}},function(t,e){var n={}.toString;t.exports=function(t){return n.call(t).slice(8,-1)}},function(t,e){var n=t.exports={version:\"2.6.12\"};\"number\"==typeof __e&&(__e=n)},function(t,e,n){var r=n(10);t.exports=function(t,e,n){if(r(t),void 0===e)return t;switch(n){case 1:return function(n){return t.call(e,n)};case 2:return function(n,r){return t.call(e,n,r)};case 3:return function(n,r,i){return t.call(e,n,r,i)}}return function(){return t.apply(e,arguments)}}},function(t,e,n){\"use strict\";var r=n(3);t.exports=function(t,e){return!!t&&r(function(){e?t.call(null,function(){},1):t.call(null)})}},function(t,e){var n=Math.ceil,r=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?r:n)(t)}},function(t,e,n){var r=n(20),i=n(48),o=n(9),s=n(6),u=n(68);t.exports=function(t,e){var n=1==t,a=2==t,c=3==t,l=4==t,f=6==t,h=5==t||f,d=e||u;return function(e,u,p){for(var v,g,m=o(e),y=i(m),b=r(u,p,3),_=s(y.length),w=0,x=n?d(e,_):a?d(e,0):void 0;_>w;w++)if((h||w in y)&&(v=y[w],g=b(v,w,m),t))if(n)x[w]=g;else if(g)switch(t){case 3:return!0;case 5:return v;case 6:return w;case 2:x.push(v)}else if(l)return!1;return f?-1:c||l?l:x}}},function(t,e){t.exports=function(t){if(void 0==t)throw TypeError(\"Can't call method on \"+t);return t}},function(t,e,n){var r=n(0),i=n(19),o=n(3);t.exports=function(t,e){var n=(i.Object||{})[t]||Object[t],s={};s[t]=e(n),r(r.S+r.F*o(function(){n(1)}),\"Object\",s)}},function(t,e,n){var r=n(4);t.exports=function(t,e){if(!r(t))return t;var n,i;if(e&&\"function\"==typeof(n=t.toString)&&!r(i=n.call(t)))return i;if(\"function\"==typeof(n=t.valueOf)&&!r(i=n.call(t)))return i;if(!e&&\"function\"==typeof(n=t.toString)&&!r(i=n.call(t)))return i;throw TypeError(\"Can't convert object to primitive value\")}},function(t,e,n){var r=n(124),i=n(0),o=n(50)(\"metadata\"),s=o.store||(o.store=new(n(128))),u=function(t,e,n){var i=s.get(t);if(!i){if(!n)return;s.set(t,i=new r)}var o=i.get(e);if(!o){if(!n)return;i.set(e,o=new r)}return o},a=function(t,e,n){var r=u(e,n,!1);return void 0!==r&&r.has(t)},c=function(t,e,n){var r=u(e,n,!1);return void 0===r?void 0:r.get(t)},l=function(t,e,n,r){u(n,r,!0).set(t,e)},f=function(t,e){var n=u(t,e,!1),r=[];return n&&n.forEach(function(t,e){r.push(e)}),r},h=function(t){return void 0===t||\"symbol\"==typeof t?t:String(t)},d=function(t){i(i.S,\"Reflect\",t)};t.exports={store:s,map:u,has:a,get:c,set:l,keys:f,key:h,exp:d}},function(t,e,n){\"use strict\";if(n(7)){var r=n(30),i=n(2),o=n(3),s=n(0),u=n(64),a=n(89),c=n(20),l=n(32),f=n(37),h=n(11),d=n(38),p=n(22),v=n(6),g=n(122),m=n(40),y=n(26),b=n(14),_=n(43),w=n(4),x=n(9),D=n(75),A=n(34),E=n(16),k=n(35).f,S=n(91),C=n(41),O=n(5),F=n(23),T=n(52),j=n(51),N=n(92),I=n(44),R=n(57),P=n(39),B=n(67),U=n(94),M=n(8),L=n(15),z=M.f,q=L.f,$=i.RangeError,W=i.TypeError,V=i.Uint8Array,Q=Array.prototype,H=a.ArrayBuffer,J=a.DataView,G=F(0),K=F(2),Y=F(3),X=F(4),Z=F(5),tt=F(6),et=T(!0),nt=T(!1),rt=N.values,it=N.keys,ot=N.entries,st=Q.lastIndexOf,ut=Q.reduce,at=Q.reduceRight,ct=Q.join,lt=Q.sort,ft=Q.slice,ht=Q.toString,dt=Q.toLocaleString,pt=O(\"iterator\"),vt=O(\"toStringTag\"),gt=C(\"typed_constructor\"),mt=C(\"def_constructor\"),yt=u.CONSTR,bt=u.TYPED,_t=u.VIEW,wt=F(1,function(t,e){return kt(j(t,t[mt]),e)}),xt=o(function(){return 1===new V(new Uint16Array([1]).buffer)[0]}),Dt=!!V&&!!V.prototype.set&&o(function(){new V(1).set({})}),At=function(t,e){var n=p(t);if(nn;)i[n]=e[n++];return i},Ot=function(t,e,n){z(t,e,{get:function(){return this._d[n]}})},Ft=function(t){var e,n,r,i,o,s,u=x(t),a=arguments.length,l=a>1?arguments[1]:void 0,f=void 0!==l,h=S(u);if(void 0!=h&&!D(h)){for(s=h.call(u),r=[],e=0;!(o=s.next()).done;e++)r.push(o.value);u=r}for(f&&a>2&&(l=c(l,arguments[2],2)),e=0,n=v(u.length),i=kt(this,n);n>e;e++)i[e]=f?l(u[e],e):u[e];return i},Tt=function(){for(var t=0,e=arguments.length,n=kt(this,e);e>t;)n[t]=arguments[t++];return n},jt=!!V&&o(function(){dt.call(new V(1))}),Nt=function(){return dt.apply(jt?ft.call(Et(this)):Et(this),arguments)},It={copyWithin:function(t,e){return U.call(Et(this),t,e,arguments.length>2?arguments[2]:void 0)},every:function(t){return X(Et(this),t,arguments.length>1?arguments[1]:void 0)},fill:function(t){return B.apply(Et(this),arguments)},filter:function(t){return St(this,K(Et(this),t,arguments.length>1?arguments[1]:void 0))},find:function(t){return Z(Et(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function(t){return tt(Et(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function(t){G(Et(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function(t){return nt(Et(this),t,arguments.length>1?arguments[1]:void 0)},includes:function(t){return et(Et(this),t,arguments.length>1?arguments[1]:void 0)},join:function(t){return ct.apply(Et(this),arguments)},lastIndexOf:function(t){return st.apply(Et(this),arguments)},map:function(t){return wt(Et(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function(t){return ut.apply(Et(this),arguments)},reduceRight:function(t){return at.apply(Et(this),arguments)},reverse:function(){for(var t,e=this,n=Et(e).length,r=Math.floor(n/2),i=0;i1?arguments[1]:void 0)},sort:function(t){return lt.call(Et(this),t)},subarray:function(t,e){var n=Et(this),r=n.length,i=m(t,r);return new(j(n,n[mt]))(n.buffer,n.byteOffset+i*n.BYTES_PER_ELEMENT,v((void 0===e?r:m(e,r))-i))}},Rt=function(t,e){return St(this,ft.call(Et(this),t,e))},Pt=function(t){Et(this);var e=At(arguments[1],1),n=this.length,r=x(t),i=v(r.length),o=0;if(i+e>n)throw $(\"Wrong length!\");for(;ol;l++)if((t||l in a)&&a[l]===n)return t||l||0;return!t&&-1}}},function(t,e,n){\"use strict\";var r=n(2),i=n(0),o=n(12),s=n(38),u=n(31),a=n(33),c=n(32),l=n(4),f=n(3),h=n(57),d=n(45),p=n(74);t.exports=function(t,e,n,v,g,m){var y=r[t],b=y,_=g?\"set\":\"add\",w=b&&b.prototype,x={},D=function(t){var e=w[t];o(w,t,\"delete\"==t?function(t){return!(m&&!l(t))&&e.call(this,0===t?0:t)}:\"has\"==t?function(t){return!(m&&!l(t))&&e.call(this,0===t?0:t)}:\"get\"==t?function(t){return m&&!l(t)?void 0:e.call(this,0===t?0:t)}:\"add\"==t?function(t){return e.call(this,0===t?0:t),this}:function(t,n){return e.call(this,0===t?0:t,n),this})};if(\"function\"==typeof b&&(m||w.forEach&&!f(function(){(new b).entries().next()}))){var A=new b,E=A[_](m?{}:-0,1)!=A,k=f(function(){A.has(1)}),S=h(function(t){new b(t)}),C=!m&&f(function(){for(var t=new b,e=5;e--;)t[_](e,e);return!t.has(-0)});S||(b=e(function(e,n){c(e,b,t);var r=p(new y,e,b);return void 0!=n&&a(n,g,r[_],r),r}),b.prototype=w,w.constructor=b),(k||C)&&(D(\"delete\"),D(\"has\"),g&&D(\"get\")),(C||E)&&D(_),m&&w.clear&&delete w.clear}else b=v.getConstructor(e,t,g,_),s(b.prototype,n),u.NEED=!0;return d(b,t),x[t]=b,i(i.G+i.W+i.F*(b!=y),x),m||v.setStrong(b,t,g),b}},function(t,e,n){\"use strict\";n(125);var r=n(12),i=n(11),o=n(3),s=n(24),u=n(5),a=n(82),c=u(\"species\"),l=!o(function(){var t=/./;return t.exec=function(){var t=[];return t.groups={a:\"7\"},t},\"7\"!==\"\".replace(t,\"$\")}),f=function(){var t=/(?:)/,e=t.exec;t.exec=function(){return e.apply(this,arguments)};var n=\"ab\".split(t);return 2===n.length&&\"a\"===n[0]&&\"b\"===n[1]}();t.exports=function(t,e,n){var h=u(t),d=!o(function(){var e={};return e[h]=function(){return 7},7!=\"\"[t](e)}),p=d?!o(function(){var e=!1,n=/a/;return n.exec=function(){return e=!0,null},\"split\"===t&&(n.constructor={},n.constructor[c]=function(){return n}),n[h](\"\"),!e}):void 0;if(!d||!p||\"replace\"===t&&!l||\"split\"===t&&!f){var v=/./[h],g=n(s,h,\"\"[t],function(t,e,n,r,i){return e.exec===a?d&&!i?{done:!0,value:v.call(e,n,r)}:{done:!0,value:t.call(n,e,r)}:{done:!1}}),m=g[0],y=g[1];r(String.prototype,t,m),i(RegExp.prototype,h,2==e?function(t,e){return y.call(t,this,e)}:function(t){return y.call(t,this)})}}},function(t,e,n){var r=n(18);t.exports=Array.isArray||function(t){return\"Array\"==r(t)}},function(t,e,n){var r=n(4),i=n(18),o=n(5)(\"match\");t.exports=function(t){var e;return r(t)&&(void 0!==(e=t[o])?!!e:\"RegExp\"==i(t))}},function(t,e,n){var r=n(5)(\"iterator\"),i=!1;try{var o=[7][r]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(t){}t.exports=function(t,e){if(!e&&!i)return!1;var n=!1;try{var o=[7],s=o[r]();s.next=function(){return{done:n=!0}},o[r]=function(){return s},t(o)}catch(t){}return n}},function(t,e,n){\"use strict\";t.exports=n(30)||!n(3)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete n(2)[t]})},function(t,e){e.f=Object.getOwnPropertySymbols},function(t,e,n){\"use strict\";var r=n(43),i=RegExp.prototype.exec;t.exports=function(t,e){var n=t.exec;if(\"function\"==typeof n){var o=n.call(t,e);if(\"object\"!=typeof o)throw new TypeError(\"RegExp exec method returned something other than an Object or null\");return o}if(\"RegExp\"!==r(t))throw new TypeError(\"RegExp#exec called on incompatible receiver\");return i.call(t,e)}},function(t,e,n){\"use strict\";var r=n(0),i=n(10),o=n(20),s=n(33);t.exports=function(t){r(r.S,t,{from:function(t){var e,n,r,u,a=arguments[1];return i(this),e=void 0!==a,e&&i(a),void 0==t?new this:(n=[],e?(r=0,u=o(a,arguments[2],2),s(t,!1,function(t){n.push(u(t,r++))})):s(t,!1,n.push,n),new this(n))}})}},function(t,e,n){\"use strict\";var r=n(0);t.exports=function(t){r(r.S,t,{of:function(){for(var t=arguments.length,e=new Array(t);t--;)e[t]=arguments[t];return new this(e)}})}},function(t,e,n){var r=n(22),i=n(24);t.exports=function(t){return function(e,n){var o,s,u=String(i(e)),a=r(n),c=u.length;return a=c?t?\"\":void 0:(o=u.charCodeAt(a),o56319||a+1===c||(s=u.charCodeAt(a+1))57343?t?u.charAt(a):o:t?u.slice(a,a+2):s-56320+(o-55296u;)e[u++]=t;return e}},function(t,e,n){var r=n(140);t.exports=function(t,e){return new(r(t))(e)}},function(t,e,n){\"use strict\";var r=n(8),i=n(37);t.exports=function(t,e,n){e in t?r.f(t,e,i(0,n)):t[e]=n}},function(t,e,n){var r=n(4),i=n(2).document,o=r(i)&&r(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,e){t.exports=\"constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf\".split(\",\")},function(t,e,n){var r=n(5)(\"match\");t.exports=function(t){var e=/./;try{\"/./\"[t](e)}catch(n){try{return e[r]=!1,!\"/./\"[t](e)}catch(t){}}return!0}},function(t,e,n){var r=n(2).document;t.exports=r&&r.documentElement},function(t,e,n){var r=n(4),i=n(83).set;t.exports=function(t,e,n){var o,s=e.constructor;return s!==n&&\"function\"==typeof s&&(o=s.prototype)!==n.prototype&&r(o)&&i&&i(t,o),t}},function(t,e,n){var r=n(44),i=n(5)(\"iterator\"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(r.Array===t||o[i]===t)}},function(t,e,n){\"use strict\";var r=n(34),i=n(37),o=n(45),s={};n(11)(s,n(5)(\"iterator\"),function(){return this}),t.exports=function(t,e,n){t.prototype=r(s,{next:i(1,n)}),o(t,e+\" Iterator\")}},function(t,e,n){\"use strict\";var r=n(30),i=n(0),o=n(12),s=n(11),u=n(44),a=n(76),c=n(45),l=n(16),f=n(5)(\"iterator\"),h=!([].keys&&\"next\"in[].keys()),d=function(){return this};t.exports=function(t,e,n,p,v,g,m){a(n,e,p);var y,b,_,w=function(t){if(!h&&t in E)return E[t];switch(t){case\"keys\":case\"values\":return function(){return new n(this,t)}}return function(){return new n(this,t)}},x=e+\" Iterator\",D=\"values\"==v,A=!1,E=t.prototype,k=E[f]||E[\"@@iterator\"]||v&&E[v],S=k||w(v),C=v?D?w(\"entries\"):S:void 0,O=\"Array\"==e?E.entries||k:k;if(O&&(_=l(O.call(new t)))!==Object.prototype&&_.next&&(c(_,x,!0),r||\"function\"==typeof _[f]||s(_,f,d)),D&&k&&\"values\"!==k.name&&(A=!0,S=function(){return k.call(this)}),r&&!m||!h&&!A&&E[f]||s(E,f,S),u[e]=S,u[x]=d,v)if(y={values:D?S:w(\"values\"),keys:g?S:w(\"keys\"),entries:C},m)for(b in y)b in E||o(E,b,y[b]);else i(i.P+i.F*(h||A),e,y);return y}},function(t,e){var n=Math.expm1;t.exports=!n||n(10)>22025.465794806718||n(10)-1e-6&&t>=1)&&(e+=e))1&o&&(n+=e);return n}},function(t,e){t.exports=\"\\t\\n\\v\\f\\r ᠎ \\u2028\\u2029\\ufeff\"},function(t,e,n){var r,i,o,s=n(20),u=n(103),a=n(73),c=n(70),l=n(2),f=l.process,h=l.setImmediate,d=l.clearImmediate,p=l.MessageChannel,v=l.Dispatch,g=0,m={},y=function(){var t=+this;if(m.hasOwnProperty(t)){var e=m[t];delete m[t],e()}},b=function(t){y.call(t.data)};h&&d||(h=function(t){for(var e=[],n=1;arguments.length>n;)e.push(arguments[n++]);return m[++g]=function(){u(\"function\"==typeof t?t:Function(t),e)},r(g),g},d=function(t){delete m[t]},\"process\"==n(18)(f)?r=function(t){f.nextTick(s(y,t,1))}:v&&v.now?r=function(t){v.now(s(y,t,1))}:p?(i=new p,o=i.port2,i.port1.onmessage=b,r=s(o.postMessage,o,1)):l.addEventListener&&\"function\"==typeof postMessage&&!l.importScripts?(r=function(t){l.postMessage(t+\"\",\"*\")},l.addEventListener(\"message\",b,!1)):r=\"onreadystatechange\"in c(\"script\")?function(t){a.appendChild(c(\"script\")).onreadystatechange=function(){a.removeChild(this),y.call(t)}}:function(t){setTimeout(s(y,t,1),0)}),t.exports={set:h,clear:d}},function(t,e,n){\"use strict\";function r(t,e,n){var r,i,o,s=new Array(n),u=8*n-e-1,a=(11,l=23===e?U(2,-24)-U(2,-77):0,f=0,h=t=a?(i=0,r=a):r+c>=1?(i=(t*o-1)*U(2,e),r+=c):(i=t*U(2,c-1)*U(2,e),r=0));e>=8;s[f++]=255&i,i/=256,e-=8);for(r=r>=7;u>0;l=256*l+t[a],a--,u-=8);for(r=l&(1=-u,u+=e;u>0;r=256*r+t[a],a--,u-=8);if(0===l)l=1-s;else{if(l===o)return r?NaN:c?-R:R;r+=U(2,e),l-=s}return(c?-1:1)*r*U(2,l-e)}function o(t){return t[3]16&255,t>>24&255]}function c(t){return r(t,52,8)}function l(t){return r(t,23,4)}function f(t,e,n){k(t[O],e,{get:function(){return this[n]}})}function h(t,e,n,r){var i=+n,o=A(i);if(o+e>t[$])throw I(F);var s=t[q]._b,u=o+t[W],a=s.slice(u,u+e);return r?a:a.reverse()}function d(t,e,n,r,i,o){var s=+n,u=A(s);if(u+e>t[$])throw I(F);for(var a=t[q]._b,c=u+t[W],l=r(+i),f=0;fJ;)(V=H[J++])in T||y(T,V,P[V]);g||(Q.constructor=T)}var G=new j(new T(2)),K=j[O].setInt8;G.setInt8(0,2147483648),G.setInt8(1,2147483649),!G.getInt8(0)&&G.getInt8(1)||b(j[O],{setInt8:function(t,e){K.call(this,t,e24)},setUint8:function(t,e){K.call(this,t,e24)}},!0)}else T=function(t){w(this,T,\"ArrayBuffer\");var e=A(t);this._b=S.call(new Array(e),0),this[$]=e},j=function(t,e,n){w(this,j,\"DataView\"),w(t,T,\"DataView\");var r=t[$],i=x(e);if(ir)throw I(\"Wrong offset!\");if(n=void 0===n?r-i:D(n),i+n>r)throw I(\"Wrong length!\");this[q]=t,this[W]=i,this[$]=n},v&&(f(T,\"byteLength\",\"_l\"),f(j,\"buffer\",\"_b\"),f(j,\"byteLength\",\"_l\"),f(j,\"byteOffset\",\"_o\")),b(j[O],{getInt8:function(t){return h(this,1,t)[0]24},getUint8:function(t){return h(this,1,t)[0]},getInt16:function(t){var e=h(this,2,t,arguments[1]);return(e[1]=t.length?(this._t=void 0,i(1)):\"keys\"==e?i(0,n):\"values\"==e?i(0,t[n]):i(0,[n,t[n]])},\"values\"),o.Arguments=o.Array,r(\"keys\"),r(\"values\"),r(\"entries\")},function(t,e,n){var r=n(18);t.exports=function(t,e){if(\"number\"!=typeof t&&\"Number\"!=r(t))throw TypeError(e);return+t}},function(t,e,n){\"use strict\";var r=n(9),i=n(40),o=n(6);t.exports=[].copyWithin||function(t,e){var n=r(this),s=o(n.length),u=i(t,s),a=i(e,s),c=arguments.length>2?arguments[2]:void 0,l=Math.min((void 0===c?s:i(c,s))-a,s-u),f=1;for(a-1e-8&&tl;)for(var d,p=a(arguments[l++]),v=f?i(p).concat(f(p)):i(p),g=v.length,m=0;g>m;)d=v[m++],r&&!h.call(p,d)||(n[d]=p[d]);return n}:c},function(t,e,n){var r=n(8),i=n(1),o=n(36);t.exports=n(7)?Object.defineProperties:function(t,e){i(t);for(var n,s=o(e),u=s.length,a=0;u>a;)r.f(t,n=s[a++],e[n]);return t}},function(t,e,n){var r=n(17),i=n(35).f,o={}.toString,s=\"object\"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],u=function(t){try{return i(t)}catch(t){return s.slice()}};t.exports.f=function(t){return s&&\"[object Window]\"==o.call(t)?u(t):i(r(t))}},function(t,e,n){var r=n(14),i=n(17),o=n(52)(!1),s=n(84)(\"IE_PROTO\");t.exports=function(t,e){var n,u=i(t),a=0,c=[];for(n in u)n!=s&&r(u,n)&&c.push(n);for(;e.length>a;)r(u,n=e[a++])&&(~o(c,n)||c.push(n));return c}},function(t,e,n){var r=n(7),i=n(36),o=n(17),s=n(49).f;t.exports=function(t){return function(e){for(var n,u=o(e),a=i(u),c=a.length,l=0,f=[];c>l;)n=a[l++],r&&!s.call(u,n)||f.push(t?[n,u[n]]:u[n]);return f}}},function(t,e,n){var r=n(35),i=n(59),o=n(1),s=n(2).Reflect;t.exports=s&&s.ownKeys||function(t){var e=r.f(o(t)),n=i.f;return n?e.concat(n(t)):e}},function(t,e,n){var r=n(2).parseFloat,i=n(46).trim;t.exports=1/r(n(87)+\"-0\")!=-1/0?function(t){var e=i(String(t),3),n=r(e);return 0===n&&\"-\"==e.charAt(0)?-0:n}:r},function(t,e,n){var r=n(2).parseInt,i=n(46).trim,o=n(87),s=/^[-+]?0[xX]/;t.exports=8!==r(o+\"08\")||22!==r(o+\"0x16\")?function(t,e){var n=i(String(t),3);return r(n,e>>>0||(s.test(n)?16:10))}:r},function(t,e){t.exports=function(t){try{return{e:!1,v:t()}}catch(t){return{e:!0,v:t}}}},function(t,e,n){var r=n(1),i=n(4),o=n(81);t.exports=function(t,e){if(r(t),i(e)&&e.constructor===t)return e;var n=o.f(t);return(0,n.resolve)(e),n.promise}},function(t,e){t.exports=Object.is||function(t,e){return t===e?0!==t||1/t==1/e:t!=t&&e!=e}},function(t,e,n){var r=n(6),i=n(86),o=n(24);t.exports=function(t,e,n,s){var u=String(o(t)),a=u.length,c=void 0===n?\" \":String(n),l=r(e);if(lf&&(h=h.slice(0,f)),s?h+u:u+h}},function(t,e,n){var r=n(22),i=n(6);t.exports=function(t){if(void 0===t)return 0;var e=r(t),n=i(e);if(e!==n)throw RangeError(\"Wrong length!\");return n}},function(t,e,n){e.f=n(5)},function(t,e,n){\"use strict\";var r=n(98),i=n(42);t.exports=n(53)(\"Map\",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function(t){var e=r.getEntry(i(this,\"Map\"),t);return e&&e.v},set:function(t,e){return r.def(i(this,\"Map\"),0===t?0:t,e)}},r,!0)},function(t,e,n){\"use strict\";var r=n(82);n(0)({target:\"RegExp\",proto:!0,forced:r!==/./.exec},{exec:r})},function(t,e,n){n(7)&&\"g\"!=/./g.flags&&n(8).f(RegExp.prototype,\"flags\",{configurable:!0,get:n(47)})},function(t,e,n){\"use strict\";var r=n(98),i=n(42);t.exports=n(53)(\"Set\",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return r.def(i(this,\"Set\"),t=0===t?0:t,t)}},r)},function(t,e,n){\"use strict\";var r,i=n(2),o=n(23)(0),s=n(12),u=n(31),a=n(110),c=n(100),l=n(4),f=n(42),h=n(42),d=!i.ActiveXObject&&\"ActiveXObject\"in i,p=u.getWeak,v=Object.isExtensible,g=c.ufstore,m=function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},y={get:function(t){if(l(t)){var e=p(t);return!0===e?g(f(this,\"WeakMap\")).get(t):e?e[this._i]:void 0}},set:function(t,e){return c.def(f(this,\"WeakMap\"),t,e)}},b=t.exports=n(53)(\"WeakMap\",m,y,c,!0,!0);h&&d&&(r=c.getConstructor(m,\"WeakMap\"),a(r.prototype,y),u.NEED=!0,o([\"delete\",\"has\",\"get\",\"set\"],function(t){var e=b.prototype,n=e[t];s(e,t,function(e,i){if(l(e)&&!v(e)){this._f||(this._f=new r);var o=this._f[t](e,i);return\"set\"==t?this:o}return n.call(this,e,i)})}))},function(t,e){var n;n=function(){return this}();try{n=n||Function(\"return this\")()||(0,eval)(\"this\")}catch(t){\"object\"==typeof window&&(n=window)}t.exports=n},function(t,e,n){\"use strict\";function r(t){return function(){var e=t.apply(this,arguments);return new Promise(function(t,n){function r(i,o){try{var s=e[i](o),u=s.value}catch(t){return void n(t)}if(!s.done)return Promise.resolve(u).then(function(t){r(\"next\",t)},function(t){r(\"throw\",t)});t(u)}return r(\"next\")})}}function i(t){var e=this;return e.init(t),e}function o(t){return new i(t)}var s=n(344).version,u=n(138),a=n(341),c=n(132),l=n(137),f=n(135),h=n(136),d=n(133),p=n(339),v=n(340),g=n(134),m={comment:\"\",nick:\"Anonymous\",mail:\"\",link:\"\",ua:navigator.userAgent,url:\"\"},y={\"zh-cn\":{head:{nick:\"昵称\",mail:\"邮箱\",link:\"网址(http://)\"},tips:{comments:\"评论\",sofa:\"快来做第一个评论的人吧~\",busy:\"还在提交中，请稍候...\",again:\"这么简单也能错，也是没谁了.\"},ctrl:{reply:\"回复\",ok:\"好的\",sure:\"确认\",cancel:\"取消\",confirm:\"确认\",continue:\"继续\",more:\"查看更多...\",try:\"再试试?\",preview:\"预览\",emoji:\"表情\",encrypt:\"加密评论\",decrypt:\"解密\",encrypted_tip:\"这是一条加密评论\"},error:{99:\"初始化失败，请检查init中的`el`元素.\",100:\"初始化失败，请检查你的AppId和AppKey.\",401:\"未经授权的操作，请检查你的AppId和AppKey.\",403:\"访问被api域名白名单拒绝，请检查你的安全域名设置.\"},timeago:{seconds:\"秒前\",minutes:\"分钟前\",hours:\"小时前\",days:\"天前\",now:\"刚刚\"}},en:{head:{nick:\"NickName\",mail:\"E-Mail\",link:\"Website(http://)\"},tips:{comments:\"Comments\",sofa:\"No comments yet.\",busy:\"Submit is busy, please wait...\",again:\"Sorry, this is a wrong calculation.\"},ctrl:{reply:\"Reply\",ok:\"Ok\",sure:\"Sure\",cancel:\"Cancel\",confirm:\"Confirm\",continue:\"Continue\",more:\"Load More...\",try:\"Once More?\",preview:\"Preview\",emoji:\"Emoji\",encrypt:\"Encrypt Comment\",decrypt:\"Decrypt\",encrypted_tip:\"This is an encrypted comment\"},error:{99:\"Initialization failed, Please check the `el` element in the init method.\",100:\"Initialization failed, Please check your appId and appKey.\",401:\"Unauthorized operation, Please check your appId and appKey.\",403:\"Access denied by api domain white list, Please check your security domain.\"},timeago:{seconds:\"seconds ago\",minutes:\"minutes ago\",hours:\"hours ago\",days:\"days ago\",now:\"just now\"}}},b={cdn:\"https://gravatar.loli.net/avatar/\",ds:[\"mp\",\"identicon\",\"monsterid\",\"wavatar\",\"robohash\",\"retro\",\"\"],params:\"\",hide:!1},_=[\"nick\",\"mail\",\"link\"],w=Storage&&localStorage&&localStorage instanceof Storage&&localStorage;i.prototype.init=function(t){var e=this;return e.config=t,\"undefined\"==typeof document?void console:(!!t&&e._init(),e)},i.prototype._init=function(){var t=this;try{var e=t.config,n=e.lang,r=e.langMode,i=e.avatar,o=e.avatarForce,u=e.avatar_cdn,c=e.notify,l=e.verify,f=e.visitor,d=e.path,w=void 0===d?location.pathname:d,x=e.pageSize,A=e.recordIP,E=e.clazzName,k=void 0===E?\"Comment\":E,S=e.crypto,C=void 0===S?{}:S;t.config.path=w.replace(/index\\.html?$/,\"\"),t.config.clazzName=k,t.crypto=C.enable?new g(C.salt||\"shimmer_blog_crypto_salt_2024\"):null;var O=b.ds,F=o?\"&q=\"+Math.random().toString(32).substring(2):\"\";n&&r&&t.installLocale(n,r),t.locale=t.locale||y[n||\"zh-cn\"],t.notify=c||!1,t.verify=l||!1,b.params=\"?d=\"+(O.indexOf(i)>-1?i:\"mp\")+\"&v=\"+s+F,b.hide=\"hide\"===i,b.cdn=/^https?\\:\\/\\//.test(u)?u:b.cdn;var T=Number(x||10);t.config.pageSize=isNaN(T)?10:T-1});var q=(0==t.config.meta.length?_:t.config.meta).map(function(e){var n=\"mail\"==e?\"email\":\"text\",r=\"\";return\"nick\"==e?r=' maxlength=\"10\"':\"mail\"==e?r=' maxlength=\"50\"':\"link\"==e&&(r=' maxlength=\"50\"'),_.indexOf(e)>-1?'-1)return void h.remove(e);if(i.indexOf(e.nodeName)>-1){var n=o[e.nodeName]||[],s=Array.from(e.attributes);h.each(s,function(t,r){var i=r.name.toLowerCase();if(i.startsWith(\"on\"))h.removeAttr(e,i);else if(\"style\"===i){var o=h.attr(e,\"style\");o&&(o=o.replace(/(expression|javascript|vbscript|behavior|binding|@import)/gi,\"\"),h.attr(e,\"style\",o))}else n.indexOf(i)>-1?u(e,i):\"class\"!==i&&h.removeAttr(e,i)}),\"A\"===e.nodeName&&(h.attr(e,\"target\",\"_blank\"),h.attr(e,\"rel\",\"noopener noreferrer\"))}else{var a=e.textContent||\"\",c=document.createTextNode(a);e.parentNode&&e.parentNode.replaceChild(c,e)}}}),e.innerHTML},P=function(t){if(!t)return{raw:\"\",safeHtml:\"\"};var e=t.trim();return e=d.parse(e),{raw:e,safeHtml:I(e)}},B=function(t){var e=t.value||\"\";e=d.parse(e),t.value=e;var n=P(e);m.comment=n.raw;var r=j(e),i=R(a.parse(r));o.innerHTML=i,e?c(t):c.destroy(t)};h.on(\"click\",s,function(t){h.attr(s,\"v\")?n.emoji.hide():n.emoji.show()}),h.on(\"click\",p,function(t){h.attr(p,\"v\")?n.preview.hide():n.preview.show()});var U=h.find(n.el,\".vimage-btn\"),M=h.find(n.el,\".vimage-input\"),L=h.find(n.el,\".vupload-progress\");h.on(\"click\",U,function(t){M.click()}),h.on(\"change\",M,function(t){var e=t.target.files;e&&e.length>0&&D(e)});var z=!1,q=\"\";if(n.crypto){var $=h.find(n.el,\".vencrypt-checkbox\"),W=h.find(n.el,\".vencrypt-password\");$&&h.on(\"change\",$,function(t){z=t.target.checked,z?(W.style.display=\"block\",W.focus()):(W.style.display=\"none\",q=\"\")}),W&&h.on(\"input\",W,function(t){q=t.target.value})}for(var V=n.config.meta,Q={},H={veditor:\"comment\"},J=0,G=V.length;J0&&void 0!==arguments[0]?arguments[0]:1,r=n.config.pageSize,i=Number(h.find(n.el,\".vnum\").innerText);n.loading.show();var o=n.Q(n.config.path);o.limit(r),o.skip((e-1)*r),o.find().then(function(o){for(var s=o.length,u=[],a=0;a0&&(m.link.length>200||!/^https?:\\/\\/.+/.test(m.link))?void Q.link.focus():\"\"==m.comment?void Q.comment.focus():(m.nick=m.nick||\"Anonymous\",z&&n.crypto?q&&\"\"!==q.trim()?void ht(q.trim()):(n.alert.show({type:0,text:\"❌ 请输入加密密钥\",ctxt:n.locale.ctrl.ok}),void h.find(n.el,\".vencrypt-password\").focus()):void(n.verify?mt(gt):gt()))},vt=function(){var t=new v.ACL;return t.setPublicReadAccess(!0),t.setPublicWriteAccess(!1),t},gt=function(){h.attr(dt,\"disabled\",!0),n.loading.show(!0),m.comment=j(m.comment);var t=v.Object.extend(n.config.clazzName||\"Comment\"),e=new t;if(m.url=decodeURI(n.config.path),m.insertedAt=new Date,ct.rid){var r=ct.pid||ct.rid;e.set(\"rid\",ct.rid),e.set(\"pid\",r),m.comment=m.comment.replace(\"\",''+ct.at+\" , \")}for(var i in m)if(m.hasOwnProperty(i)){var o=m[i];e.set(i,o)}e.setACL(vt()),e.save().then(function(t){\"Anonymous\"!=m.nick&&w&&w.setItem(\"ValineCache\",JSON.stringify({nick:m.nick,link:m.link,mail:m.mail}));var e=h.find(n.el,\".vnum\"),r=1;try{if(ct.rid){var i=h.find(n.el,'.vquote[rid=\"'+ct.rid+'\"]')||X(ct.rid);et(t,i,!0)}else e?(r=Number(e.innerText)+1,e.innerText=r):h.find(n.el,\".vcount\").innerHTML='1 '+n.locale.tips.comments,et(t,h.find(n.el,\".vlist\")),n.config.pageSize++;n.notify&&(m.mail&&yt({username:m.nick,mail:m.mail}),ct.at&&ct.rmail&&bt({username:ct.at.replace(\"@\",\"\"),mail:ct.rmail})),h.removeAttr(dt,\"disabled\"),n.loading.hide(),ft()}catch(t){n.ErrorHandler(t,\"save\")}}).catch(function(t){n.ErrorHandler(t,\"commitEvt\")})},mt=function t(e){var r=Math.floor(10*Math.random()+1),i=Math.floor(10*Math.random()+1),o=Math.floor(10*Math.random()+1),s=[\"+\",\"-\",\"x\"],u=s[Math.floor(3*Math.random())],a=s[Math.floor(3*Math.random())],c=\"\"+r+u+i+a+o,l=c+\" = \";n.alert.show({type:1,text:l,ctxt:n.locale.ctrl.cancel,otxt:n.locale.ctrl.ok,cb:function(){var r=+h.find(n.el,\".vcode\").value;new Function(\"return \"+c.replace(/x/g,\"*\"))()===r?e&&e():n.alert.show({type:1,text:\"(T＿T)\"+n.locale.tips.again,ctxt:n.locale.ctrl.cancel,otxt:n.locale.ctrl.try,cb:function(){t(e)}})}})},yt=function(t){var e=new v.User;return e.setUsername(t.username),e.setPassword(t.mail),e.setEmail(t.mail),e.setACL(vt()),e.signUp()},bt=function t(e){v.User.requestPasswordReset(e.mail).then(function(t){}).catch(function(r){1==r.code?n.alert.show({type:0,text:\"ヾ(ｏ･ω･)ﾉ At太频繁啦，提醒功能暂时宕机。\"+r.error,ctxt:n.locale.ctrl.ok}):yt(e).then(function(n){t(e)}).catch(function(t){})})};h.on(\"click\",dt,pt),h.on(\"keydown\",document,function(t){t=event||t;var e=t.keyCode||t.which||t.charCode;((t.ctrlKey||t.metaKey)&&13===e&&pt(),9===e)&&(\"veditor\"==(document.activeElement.id||\"\")&&(t.preventDefault(),Y(y,\" \")))}),h.on(\"paste\",document,function(){var t=r(regeneratorRuntime.mark(function t(n){var r,i;return regeneratorRuntime.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:if(n.target===y){t.next=2;break}return t.abrupt(\"return\");case 2:if((r=n.clipboardData||window.clipboardData)&&r.files&&0!==r.files.length){t.next=5;break}return t.abrupt(\"return\");case 5:if(i=Array.from(r.files).filter(function(t){return t.type.startsWith(\"image/\")}),0!==i.length){t.next=8;break}return t.abrupt(\"return\");case 8:return n.preventDefault(),t.prev=9,t.next=12,D(i);case 12:t.next=17;break;case 14:t.prev=14,t.t0=t.catch(9);case 17:case\"end\":return t.stop()}},t,e,[[9,14]])}));return function(e){return t.apply(this,arguments)}}()),h.on(\"dragover\",y,function(t){t.preventDefault(),t.stopPropagation(),y.style.backgroundColor=\"#f0f8ff\"}),h.on(\"dragleave\",y,function(t){t.preventDefault(),t.stopPropagation(),y.style.backgroundColor=\"\"}),h.on(\"drop\",y,function(){var t=r(regeneratorRuntime.mark(function t(r){var i,o;return regeneratorRuntime.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:if(r.preventDefault(),r.stopPropagation(),y.style.backgroundColor=\"\",!((i=r.dataTransfer.files)&&i.length>0)){t.next=17;break}if(o=Array.from(i).filter(function(t){return t.type.startsWith(\"image/\")}),0!==o.length){t.next=9;break}return n.alert&&n.alert.show({type:0,text:\"请拖拽图片文件\",ctxt:\"确定\"}),t.abrupt(\"return\");case 9:return t.prev=9,t.next=12,D(o);case 12:t.next=17;break;case 14:t.prev=14,t.t0=t.catch(9);case 17:case\"end\":return t.stop()}},t,e,[[9,14]])}));return function(e){return t.apply(this,arguments)}}())},t.exports=o,t.exports.default=o},function(t,e,n){\"use strict\";(function(t){function e(t,e,n){t[e]||Object[r](t,e,{writable:!0,configurable:!0,value:n})}if(n(338),n(343),n(139),t._babelPolyfill)throw new Error(\"only one instance of babel-polyfill is allowed\");t._babelPolyfill=!0;var r=\"defineProperty\";e(String.prototype,\"padLeft\",\"\".padStart),e(String.prototype,\"padRight\",\"\".padEnd),\"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill\".split(\",\").forEach(function(t){[][t]&&e(Array,t,Function.call.bind([][t]))})}).call(e,n(129))},function(t,e,n){var r,i,o;/*! autosize 4.0.4 license: MIT http://www.jacklmoore.com/autosize */ !function(n,s){i=[t,e],r=s,void 0!==(o=\"function\"==typeof r?r.apply(e,i):r)&&(t.exports=o)}(0,function(t,e){\"use strict\";function n(t){function e(e){var n=t.style.width;t.style.width=\"0px\",t.offsetWidth,t.style.width=n,t.style.overflowY=e}function n(t){for(var e=[];t&&t.parentNode&&t.parentNode instanceof Element;)t.parentNode.scrollTop&&e.push({node:t.parentNode,scrollTop:t.parentNode.scrollTop}),t=t.parentNode;return e}function r(){if(0!==t.scrollHeight){var e=n(t),r=document.documentElement&&document.documentElement.scrollTop;t.style.height=\"\",t.style.height=t.scrollHeight+u+\"px\",a=t.clientWidth,e.forEach(function(t){t.node.scrollTop=t.scrollTop}),r&&(document.documentElement.scrollTop=r)}}function i(){r();var n=Math.round(parseFloat(t.style.height)),i=window.getComputedStyle(t,null),o=\"content-box\"===i.boxSizing?Math.round(parseFloat(i.height)):t.offsetHeight;if(o-1},get:function(n){return e[t.indexOf(n)]},set:function(n,r){-1===t.indexOf(n)&&(t.push(n),e.push(r))},delete:function(n){var r=t.indexOf(n);r>-1&&(t.splice(r,1),e.splice(r,1))}}}(),s=function(t){return new Event(t,{bubbles:!0})};try{new Event(\"test\")}catch(t){s=function(t){var e=document.createEvent(\"Event\");return e.initEvent(t,!0,!1),e}}var u=null;\"undefined\"==typeof window||\"function\"!=typeof window.getComputedStyle?(u=function(t){return t},u.destroy=function(t){return t},u.update=function(t){return t}):(u=function(t,e){return t&&Array.prototype.forEach.call(t.length?t:[t],function(t){return n(t)}),t},u.destroy=function(t){return t&&Array.prototype.forEach.call(t.length?t:[t],r),t},u.update=function(t){return t&&Array.prototype.forEach.call(t.length?t:[t],i),t}),e.default=u,t.exports=e.default})},function(t,e,n){\"use strict\";var r={data:n(345),parse:function(t){return String(t).replace(/:(.+?):/g,function(t,e){return r.data[e]||t})}};t.exports=r},function(t,e,n){\"use strict\";function r(t){return function(){var e=t.apply(this,arguments);return new Promise(function(t,n){function r(i,o){try{var s=e[i](o),u=s.value}catch(t){return void n(t)}if(!s.done)return Promise.resolve(u).then(function(t){r(\"next\",t)},function(t){r(\"throw\",t)});t(u)}return r(\"next\")})}}function i(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}var o=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:\"\";if(i(this,t),this.secretKey=e||\"default_key\",!window.crypto||!window.crypto.subtle)throw new Error(\"Web Crypto API 不支持，请使用现代浏览器\")}return t.prototype.deriveKey=function(t){for(var e=new TextEncoder,n=e.encode(t),r=new Uint8Array(32),i=0;i=6,strength:t&&t.length>=12?\"strong\":\"medium\",message:t&&t.length>=6?\"密码强度良好\":\"密码长度至少6位\"}},t}();void 0!==t&&t.exports&&(t.exports=o),\"undefined\"!=typeof window&&(window.ValineCrypto=o)},function(t,e,n){\"use strict\";function r(t){var e=this,n={Trident:t.indexOf(\"Trident\")>-1||t.indexOf(\"NET CLR\")>-1,Presto:t.indexOf(\"Presto\")>-1,WebKit:t.indexOf(\"AppleWebKit\")>-1,Gecko:t.indexOf(\"Gecko/\")>-1,Safari:t.indexOf(\"Safari\")>-1,Chrome:t.indexOf(\"Chrome\")>-1||t.indexOf(\"CriOS\")>-1,IE:t.indexOf(\"MSIE\")>-1||t.indexOf(\"Trident\")>-1,Edge:t.indexOf(\"Edge\")>-1,Firefox:t.indexOf(\"Firefox\")>-1||t.indexOf(\"FxiOS\")>-1,\"Firefox Focus\":t.indexOf(\"Focus\")>-1,Chromium:t.indexOf(\"Chromium\")>-1,Opera:t.indexOf(\"Opera\")>-1||t.indexOf(\"OPR\")>-1,Vivaldi:t.indexOf(\"Vivaldi\")>-1,Yandex:t.indexOf(\"YaBrowser\")>-1,Kindle:t.indexOf(\"Kindle\")>-1||t.indexOf(\"Silk/\")>-1,360:t.indexOf(\"360EE\")>-1||t.indexOf(\"360SE\")>-1,UC:t.indexOf(\"UC\")>-1||t.indexOf(\" UBrowser\")>-1,QQBrowser:t.indexOf(\"QQBrowser\")>-1,QQ:t.indexOf(\"QQ/\")>-1,Baidu:t.indexOf(\"Baidu\")>-1||t.indexOf(\"BIDUBrowser\")>-1,Maxthon:t.indexOf(\"Maxthon\")>-1,Sogou:t.indexOf(\"MetaSr\")>-1||t.indexOf(\"Sogou\")>-1,LBBROWSER:t.indexOf(\"LBBROWSER\")>-1,\"2345Explorer\":t.indexOf(\"2345Explorer\")>-1,TheWorld:t.indexOf(\"TheWorld\")>-1,XiaoMi:t.indexOf(\"MiuiBrowser\")>-1,Quark:t.indexOf(\"Quark\")>-1,Qiyu:t.indexOf(\"Qiyu\")>-1,Wechat:t.indexOf(\"MicroMessenger\")>-1,Taobao:t.indexOf(\"AliApp(TB\")>-1,Alipay:t.indexOf(\"AliApp(AP\")>-1,Weibo:t.indexOf(\"Weibo\")>-1,Douban:t.indexOf(\"com.douban.frodo\")>-1,Suning:t.indexOf(\"SNEBUY-APP\")>-1,iQiYi:t.indexOf(\"IqiyiApp\")>-1,Windows:t.indexOf(\"Windows\")>-1,Linux:t.indexOf(\"Linux\")>-1||t.indexOf(\"X11\")>-1,\"Mac OS\":t.indexOf(\"Macintosh\")>-1,Android:t.indexOf(\"Android\")>-1||t.indexOf(\"Adr\")>-1,Ubuntu:t.indexOf(\"Ubuntu\")>-1,FreeBSD:t.indexOf(\"FreeBSD\")>-1,Debian:t.indexOf(\"Debian\")>-1,\"Windows Phone\":t.indexOf(\"IEMobile\")>-1||t.indexOf(\"Windows Phone\")>-1,BlackBerry:t.indexOf(\"BlackBerry\")>-1||t.indexOf(\"RIM\")>-1,MeeGo:t.indexOf(\"MeeGo\")>-1,Symbian:t.indexOf(\"Symbian\")>-1,iOS:t.indexOf(\"like Mac OS X\")>-1,\"Chrome OS\":t.indexOf(\"CrOS\")>-1,WebOS:t.indexOf(\"hpwOS\")>-1,Mobile:t.indexOf(\"Mobi\")>-1||t.indexOf(\"iPh\")>-1||t.indexOf(\"480\")>-1,Tablet:t.indexOf(\"Tablet\")>-1||t.indexOf(\"Pad\")>-1||t.indexOf(\"Nexus 7\")>-1};n.Mobile&&(n.Mobile=!(t.indexOf(\"iPad\")>-1));var r={engine:[\"WebKit\",\"Trident\",\"Gecko\",\"Presto\"],browser:[\"Safari\",\"Chrome\",\"Edge\",\"IE\",\"Firefox\",\"Firefox Focus\",\"Chromium\",\"Opera\",\"Vivaldi\",\"Yandex\",\"Kindle\",\"360\",\"UC\",\"QQBrowser\",\"QQ\",\"Baidu\",\"Maxthon\",\"Sogou\",\"LBBROWSER\",\"2345Explorer\",\"TheWorld\",\"XiaoMi\",\"Quark\",\"Qiyu\",\"Wechat\",\"Taobao\",\"Alipay\",\"Weibo\",\"Douban\",\"Suning\",\"iQiYi\"],os:[\"Windows\",\"Linux\",\"Mac OS\",\"Android\",\"Ubuntu\",\"FreeBSD\",\"Debian\",\"iOS\",\"Windows Phone\",\"BlackBerry\",\"MeeGo\",\"Symbian\",\"Chrome OS\",\"WebOS\"],device:[\"Mobile\",\"Tablet\"]};e.device=\"PC\";for(var i in r)for(var o=0;o27?e.engine=\"Blink\":\"Opera\"==e.browser&&parseInt(e.version)>12?e.engine=\"Blink\":\"Yandex\"==e.browser?e.engine=\"Blink\":void 0==e.browser&&(e.browser=\"Unknow App\")}function i(t){return new r(t)}t.exports=i},function(t,e,n){\"use strict\";var r=(window,document,{}),i={\"&\":\"&amp;\",\"\":\"&gt;\",'\"':\"&quot;\",\"'\":\"'\",\"`\":\"`\",\"\\\\\":\"\\\"};for(var o in i)r[i[o]]=o;var s=/[&\"'`\\\\]/g,u=RegExp(s.source),a=/&(?:amp|lt|gt|quot|#39|#x60|#x5c);/g,c=RegExp(a.source),l={on:function(t,e,n,r){t=t.split(\" \");for(var i=0,o=t.length;i-1?l.attr(t,\"class\",\"at\"):s.indexOf(\"vemoji\")>-1?l.attr(t,\"class\",\"vemoji\"):l.removeAttr(t,\"class\");break;default:if(n.indexOf(i)>-1)return!0;l.removeAttr(t,i)}}),t},remove:function(t){try{t.parentNode&&t.parentNode.removeChild(t)}catch(t){}},each:function(t,e){var n=0,r=t.length,i=[\"[object Array]\",\"[object NodeList]\"],o={}.toString.call(t);if(i.indexOf(o)>-1)for(;n16)+(n>>16)>5]|=128>9>e%32&255);return n}function p(t){var e,n=[];for(n[(t.length>>2)-1]=void 0,e=0;e5]|=(255&t.charCodeAt(e/8))4&15)+r.charAt(15&e);return i}function y(t){return unescape(encodeURIComponent(t))}function b(t){return v(y(t))}function _(t){return m(b(t))}function w(t,e){return g(y(t),y(e))}function x(t,e){return m(w(t,e))}function D(t,e,n){return e?n?w(e,t):x(e,t):n?b(t):_(t)}void 0!==(r=function(){return D}.call(e,n,e,t))&&(t.exports=r)}()},function(t,e,n){n(146),t.exports=n(19).RegExp.escape},function(t,e,n){var r=n(4),i=n(55),o=n(5)(\"species\");t.exports=function(t){var e;return i(t)&&(e=t.constructor,\"function\"!=typeof e||e!==Array&&!i(e.prototype)||(e=void 0),r(e)&&null===(e=e[o])&&(e=void 0)),void 0===e?Array:e}},function(t,e,n){\"use strict\";var r=n(3),i=Date.prototype.getTime,o=Date.prototype.toISOString,s=function(t){return t>9?t:\"0\"+t};t.exports=r(function(){return\"0385-07-25T07:06:39.999Z\"!=o.call(new Date(-5e13-1))})||!r(function(){o.call(new Date(NaN))})?function(){if(!isFinite(i.call(this)))throw RangeError(\"Invalid time value\");var t=this,e=t.getUTCFullYear(),n=t.getUTCMilliseconds(),r=e9999?\"+\":\"\";return r+(\"00000\"+Math.abs(e)).slice(r?-6:-4)+\"-\"+s(t.getUTCMonth()+1)+\"-\"+s(t.getUTCDate())+\"T\"+s(t.getUTCHours())+\":\"+s(t.getUTCMinutes())+\":\"+s(t.getUTCSeconds())+\".\"+(n>99?n:\"0\"+s(n))+\"Z\"}:o},function(t,e,n){\"use strict\";var r=n(1),i=n(26);t.exports=function(t){if(\"string\"!==t&&\"number\"!==t&&\"default\"!==t)throw TypeError(\"Incorrect hint\");return i(r(this),\"number\"!=t)}},function(t,e,n){var r=n(36),i=n(59),o=n(49);t.exports=function(t){var e=r(t),n=i.f;if(n)for(var s,u=n(t),a=o.f,c=0;u.length>c;)a.call(t,s=u[c++])&&e.push(s);return e}},function(t,e,n){t.exports=n(50)(\"native-function-to-string\",Function.toString)},function(t,e){t.exports=function(t,e){var n=e===Object(e)?function(t){return e[t]}:e;return function(e){return String(e).replace(t,n)}}},function(t,e,n){var r=n(0),i=n(145)(/[\\\\^$*+?.()|[\\]{}]/g,\"\\\\$&\");r(r.S,\"RegExp\",{escape:function(t){return i(t)}})},function(t,e,n){var r=n(0);r(r.P,\"Array\",{copyWithin:n(94)}),n(29)(\"copyWithin\")},function(t,e,n){\"use strict\";var r=n(0),i=n(23)(4);r(r.P+r.F*!n(21)([].every,!0),\"Array\",{every:function(t){return i(this,t,arguments[1])}})},function(t,e,n){var r=n(0);r(r.P,\"Array\",{fill:n(67)}),n(29)(\"fill\")},function(t,e,n){\"use strict\";var r=n(0),i=n(23)(2);r(r.P+r.F*!n(21)([].filter,!0),\"Array\",{filter:function(t){return i(this,t,arguments[1])}})},function(t,e,n){\"use strict\";var r=n(0),i=n(23)(6),o=\"findIndex\",s=!0;o in[]&&Array(1)[o](function(){s=!1}),r(r.P+r.F*s,\"Array\",{findIndex:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),n(29)(o)},function(t,e,n){\"use strict\";var r=n(0),i=n(23)(5),o=!0;\"find\"in[]&&Array(1).find(function(){o=!1}),r(r.P+r.F*o,\"Array\",{find:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),n(29)(\"find\")},function(t,e,n){\"use strict\";var r=n(0),i=n(23)(0),o=n(21)([].forEach,!0);r(r.P+r.F*!o,\"Array\",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,e,n){\"use strict\";var r=n(20),i=n(0),o=n(9),s=n(105),u=n(75),a=n(6),c=n(69),l=n(91);i(i.S+i.F*!n(57)(function(t){Array.from(t)}),\"Array\",{from:function(t){var e,n,i,f,h=o(t),d=\"function\"==typeof this?this:Array,p=arguments.length,v=p>1?arguments[1]:void 0,g=void 0!==v,m=0,y=l(h);if(g&&(v=r(v,p>2?arguments[2]:void 0,2)),void 0==y||d==Array&&u(y))for(e=a(h.length),n=new d(e);e>m;m++)c(n,m,g?v(h[m],m):h[m]);else for(f=y.call(h),n=new d;!(i=f.next()).done;m++)c(n,m,g?s(f,v,[i.value,m],!0):i.value);return n.length=m,n}})},function(t,e,n){\"use strict\";var r=n(0),i=n(52)(!1),o=[].indexOf,s=!!o&&1/[1].indexOf(1,-0)t;)i(n,t,arguments[t++]);return n.length=e,n}})},function(t,e,n){\"use strict\";var r=n(0),i=n(96);r(r.P+r.F*!n(21)([].reduceRight,!0),\"Array\",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,e,n){\"use strict\";var r=n(0),i=n(96);r(r.P+r.F*!n(21)([].reduce,!0),\"Array\",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,e,n){\"use strict\";var r=n(0),i=n(73),o=n(18),s=n(40),u=n(6),a=[].slice;r(r.P+r.F*n(3)(function(){i&&a.call(i)}),\"Array\",{slice:function(t,e){var n=u(this.length),r=o(this);if(e=void 0===e?n:e,\"Array\"==r)return a.call(this,t,e);for(var i=s(t,n),c=s(e,n),l=u(c-i),f=new Array(l),h=0;h>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,e,n){var r=n(0),i=Math.exp;r(r.S,\"Math\",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,e,n){var r=n(0),i=n(78);r(r.S+r.F*(i!=Math.expm1),\"Math\",{expm1:i})},function(t,e,n){var r=n(0);r(r.S,\"Math\",{fround:n(107)})},function(t,e,n){var r=n(0),i=Math.abs;r(r.S,\"Math\",{hypot:function(t,e){for(var n,r,o=0,s=0,u=arguments.length,a=0;s>>16)*o+i*(65535&r>>>16)>0)}})},function(t,e,n){var r=n(0);r(r.S,\"Math\",{log10:function(t){return Math.log(t)*Math.LOG10E}})},function(t,e,n){var r=n(0);r(r.S,\"Math\",{log1p:n(108)})},function(t,e,n){var r=n(0);r(r.S,\"Math\",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,e,n){var r=n(0);r(r.S,\"Math\",{sign:n(79)})},function(t,e,n){var r=n(0),i=n(78),o=Math.exp;r(r.S+r.F*n(3)(function(){return-2e-17!=!Math.sinh(-2e-17)}),\"Math\",{sinh:function(t){return Math.abs(t=+t)0?Math.floor:Math.ceil)(t)}})},function(t,e,n){\"use strict\";var r=n(2),i=n(14),o=n(18),s=n(74),u=n(26),a=n(3),c=n(35).f,l=n(15).f,f=n(8).f,h=n(46).trim,d=r.Number,p=d,v=d.prototype,g=\"Number\"==o(n(34)(v)),m=\"trim\"in String.prototype,y=function(t){var e=u(t,!1);if(\"string\"==typeof e&&e.length>2){e=m?e.trim():h(e,3);var n,r,i,o=e.charCodeAt(0);if(43===o||45===o){if(88===(n=e.charCodeAt(2))||120===n)return NaN}else if(48===o){switch(e.charCodeAt(1)){case 66:case 98:r=2,i=49;break;case 79:case 111:r=8,i=55;break;default:return+e}for(var s,a=e.slice(2),c=0,l=a.length;c=4096;)e+=12,n/=4096;for(;n>=2;)e+=1,n/=2;return e};r(r.P+r.F*(!!u&&(\"0.000\"!==8e-5.toFixed(3)||\"1\"!==.9.toFixed(0)||\"1.25\"!==1.255.toFixed(2)||\"1000000000000000128\"!==(0xde0b6b3a7640080).toFixed(0))||!n(3)(function(){u.call({})})),\"Number\",{toFixed:function(t){var e,n,r,u,a=o(this,l),c=i(t),g=\"\",m=\"0\";if(c20)throw RangeError(l);if(a!=a)return\"NaN\";if(a=1e21)return String(a);if(a1e-21)if(e=v(a*p(2,69,1))-69,n=e0){for(f(0,n),r=c;r>=7;)f(1e7,0),r-=7;for(f(p(10,r,1),0),r=e-1;r>=23;)h(1p?a.slice(0,p):a}:\"0\".split(void 0,0)[d]?function(t,e){return void 0===t&&0===e?[]:n.call(this,t,e)}:n,[function(n,r){var i=t(this),o=void 0==n?void 0:n[e];return void 0!==o?o.call(n,i,r):v.call(String(i),n,r)},function(t,e){var r=l(v,t,this,e,v!==n);if(r.done)return r.value;var c=i(t),h=String(this),d=o(c,RegExp),g=c.unicode,m=(c.ignoreCase?\"i\":\"\")+(c.multiline?\"m\":\"\")+(c.unicode?\"u\":\"\")+(p?\"y\":\"g\"),y=new d(p?c:\"^(?:\"+c.source+\")\",m),b=void 0===e?4294967295:e>>>0;if(0===b)return[];if(0===h.length)return null===a(y,h)?[h]:[];for(var _=0,w=0,x=[];ws;){if(e=+arguments[s++],i(e,1114111)!==e)throw RangeError(e+\" is not a valid code point\");n.push(e>10),e%1024+56320))}return n.join(\"\")}})},function(t,e,n){\"use strict\";var r=n(0),i=n(85);r(r.P+r.F*n(72)(\"includes\"),\"String\",{includes:function(t){return!!~i(this,t,\"includes\").indexOf(t,arguments.length>1?arguments[1]:void 0)}})},function(t,e,n){\"use strict\";n(13)(\"italics\",function(t){return function(){return t(this,\"i\",\"\",\"\")}})},function(t,e,n){\"use strict\";var r=n(63)(!0);n(77)(String,\"String\",function(t){this._t=String(t),this._i=0},function(){var t,e=this._t,n=this._i;return n>=e.length?{value:void 0,done:!0}:(t=r(e,n),this._i+=t.length,{value:t,done:!1})})},function(t,e,n){\"use strict\";n(13)(\"link\",function(t){return function(e){return t(this,\"a\",\"href\",e)}})},function(t,e,n){var r=n(0),i=n(17),o=n(6);r(r.S,\"String\",{raw:function(t){for(var e=i(t.raw),n=o(e.length),r=arguments.length,s=[],u=0;n>u;)s.push(String(e[u++])),u1?arguments[1]:void 0,e.length)),r=String(t);return s?s.call(e,r,n):e.slice(n,n+r.length)===r}})},function(t,e,n){\"use strict\";n(13)(\"strike\",function(t){return function(){return t(this,\"strike\",\"\",\"\")}})},function(t,e,n){\"use strict\";n(13)(\"sub\",function(t){return function(){return t(this,\"sub\",\"\",\"\")}})},function(t,e,n){\"use strict\";n(13)(\"sup\",function(t){return function(){return t(this,\"sup\",\"\",\"\")}})},function(t,e,n){\"use strict\";n(46)(\"trim\",function(t){return function(){return t(this,3)}})},function(t,e,n){\"use strict\";var r=n(2),i=n(14),o=n(7),s=n(0),u=n(12),a=n(31).KEY,c=n(3),l=n(50),f=n(45),h=n(41),d=n(5),p=n(123),v=n(90),g=n(143),m=n(55),y=n(1),b=n(4),_=n(9),w=n(17),x=n(26),D=n(37),A=n(34),E=n(112),k=n(15),S=n(59),C=n(8),O=n(36),F=k.f,T=C.f,j=E.f,N=r.Symbol,I=r.JSON,R=I&&I.stringify,P=d(\"_hidden\"),B=d(\"toPrimitive\"),U={}.propertyIsEnumerable,M=l(\"symbol-registry\"),L=l(\"symbols\"),z=l(\"op-symbols\"),q=Object.prototype,$=\"function\"==typeof N&&!!S.f,W=r.QObject,V=!W||!W.prototype||!W.prototype.findChild,Q=o&&c(function(){return 7!=A(T({},\"a\",{get:function(){return T(this,\"a\",{value:7}).a}})).a})?function(t,e,n){var r=F(q,e);r&&delete q[e],T(t,e,n),r&&t!==q&&T(q,e,r)}:T,H=function(t){var e=L[t]=A(N.prototype);return e._k=t,e},J=$&&\"symbol\"==typeof N.iterator?function(t){return\"symbol\"==typeof t}:function(t){return t instanceof N},G=function(t,e,n){return t===q&&G(z,e,n),y(t),e=x(e,!0),y(n),i(L,e)?(n.enumerable?(i(t,P)&&t[P][e]&&(t[P][e]=!1),n=A(n,{enumerable:D(0,!1)})):(i(t,P)||T(t,P,D(1,{})),t[P][e]=!0),Q(t,e,n)):T(t,e,n)},K=function(t,e){y(t);for(var n,r=g(e=w(e)),i=0,o=r.length;o>i;)G(t,n=r[i++],e[n]);return t},Y=function(t,e){return void 0===e?A(t):K(A(t),e)},X=function(t){var e=U.call(this,t=x(t,!0));return!(this===q&&i(L,t)&&!i(z,t))&&(!(e||!i(this,t)||!i(L,t)||i(this,P)&&this[P][t])||e)},Z=function(t,e){if(t=w(t),e=x(e,!0),t!==q||!i(L,e)||i(z,e)){var n=F(t,e);return!n||!i(L,e)||i(t,P)&&t[P][e]||(n.enumerable=!0),n}},tt=function(t){for(var e,n=j(w(t)),r=[],o=0;n.length>o;)i(L,e=n[o++])||e==P||e==a||r.push(e);return r},et=function(t){for(var e,n=t===q,r=j(n?z:w(t)),o=[],s=0;r.length>s;)!i(L,e=r[s++])||n&&!i(q,e)||o.push(L[e]);return o};$||(N=function(){if(this instanceof N)throw TypeError(\"Symbol is not a constructor!\");var t=h(arguments.length>0?arguments[0]:void 0),e=function(n){this===q&&e.call(z,n),i(this,P)&&i(this[P],t)&&(this[P][t]=!1),Q(this,t,D(1,n))};return o&&V&&Q(q,t,{configurable:!0,set:e}),H(t)},u(N.prototype,\"toString\",function(){return this._k}),k.f=Z,C.f=G,n(35).f=E.f=tt,n(49).f=X,S.f=et,o&&!n(30)&&u(q,\"propertyIsEnumerable\",X,!0),p.f=function(t){return H(d(t))}),s(s.G+s.W+s.F*!$,{Symbol:N});for(var nt=\"hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables\".split(\",\"),rt=0;nt.length>rt;)d(nt[rt++]);for(var it=O(d.store),ot=0;it.length>ot;)v(it[ot++]);s(s.S+s.F*!$,\"Symbol\",{for:function(t){return i(M,t+=\"\")?M[t]:M[t]=N(t)},keyFor:function(t){if(!J(t))throw TypeError(t+\" is not a symbol!\");for(var e in M)if(M[e]===t)return e},useSetter:function(){V=!0},useSimple:function(){V=!1}}),s(s.S+s.F*!$,\"Object\",{create:Y,defineProperty:G,defineProperties:K,getOwnPropertyDescriptor:Z,getOwnPropertyNames:tt,getOwnPropertySymbols:et});var st=c(function(){S.f(1)});s(s.S+s.F*st,\"Object\",{getOwnPropertySymbols:function(t){return S.f(_(t))}}),I&&s(s.S+s.F*(!$||c(function(){var t=N();return\"[null]\"!=R([t])||\"{}\"!=R({a:t})||\"{}\"!=R(Object(t))})),\"JSON\",{stringify:function(t){for(var e,n,r=[t],i=1;arguments.length>i;)r.push(arguments[i++]);if(n=e=r[1],(b(e)||void 0!==t)&&!J(t))return m(e)||(e=function(t,e){if(\"function\"==typeof n&&(e=n.call(this,t,e)),!J(e))return e}),r[1]=e,R.apply(I,r)}}),N.prototype[B]||n(11)(N.prototype,B,N.prototype.valueOf),f(N,\"Symbol\"),f(Math,\"Math\",!0),f(r.JSON,\"JSON\",!0)},function(t,e,n){\"use strict\";var r=n(0),i=n(64),o=n(89),s=n(1),u=n(40),a=n(6),c=n(4),l=n(2).ArrayBuffer,f=n(51),h=o.ArrayBuffer,d=o.DataView,p=i.ABV&&l.isView,v=h.prototype.slice,g=i.VIEW;r(r.G+r.W+r.F*(l!==h),{ArrayBuffer:h}),r(r.S+r.F*!i.CONSTR,\"ArrayBuffer\",{isView:function(t){return p&&p(t)||c(t)&&g in t}}),r(r.P+r.U+r.F*n(3)(function(){return!new h(2).slice(1,void 0).byteLength}),\"ArrayBuffer\",{slice:function(t,e){if(void 0!==v&&void 0===e)return v.call(s(this),t);for(var n=s(this).byteLength,r=u(t,n),i=u(void 0===e?n:e,n),o=new(f(this,h))(a(i-r)),c=new d(this),l=new d(o),p=0;r0?arguments[0]:void 0)}},{add:function(t){return r.def(i(this,\"WeakSet\"),t,!0)}},r,!1,!0)},function(t,e,n){\"use strict\";var r=n(0),i=n(101),o=n(9),s=n(6),u=n(10),a=n(68);r(r.P,\"Array\",{flatMap:function(t){var e,n,r=o(this);return u(t),e=s(r.length),n=a(r,0),i(n,r,r,e,0,1,t,arguments[1]),n}}),n(29)(\"flatMap\")},function(t,e,n){\"use strict\";var r=n(0),i=n(101),o=n(9),s=n(6),u=n(22),a=n(68);r(r.P,\"Array\",{flatten:function(){var t=arguments[0],e=o(this),n=s(e.length),r=a(e,0);return i(r,e,e,n,0,void 0===t?1:u(t)),r}}),n(29)(\"flatten\")},function(t,e,n){\"use strict\";var r=n(0),i=n(52)(!0);r(r.P,\"Array\",{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),n(29)(\"includes\")},function(t,e,n){var r=n(0),i=n(80)(),o=n(2).process,s=\"process\"==n(18)(o);r(r.G,{asap:function(t){var e=s&&o.domain;i(e?e.bind(t):t)}})},function(t,e,n){var r=n(0),i=n(18);r(r.S,\"Error\",{isError:function(t){return\"Error\"===i(t)}})},function(t,e,n){var r=n(0);r(r.G,{global:n(2)})},function(t,e,n){n(61)(\"Map\")},function(t,e,n){n(62)(\"Map\")},function(t,e,n){var r=n(0);r(r.P+r.R,\"Map\",{toJSON:n(99)(\"Map\")})},function(t,e,n){var r=n(0);r(r.S,\"Math\",{clamp:function(t,e,n){return Math.min(n,Math.max(e,t))}})},function(t,e,n){var r=n(0);r(r.S,\"Math\",{DEG_PER_RAD:Math.PI/180})},function(t,e,n){var r=n(0),i=180/Math.PI;r(r.S,\"Math\",{degrees:function(t){return t*i}})},function(t,e,n){var r=n(0),i=n(109),o=n(107);r(r.S,\"Math\",{fscale:function(t,e,n,r,s){return o(i(t,e,n,r,s))}})},function(t,e,n){var r=n(0);r(r.S,\"Math\",{iaddh:function(t,e,n,r){var i=t>>>0,o=e>>>0,s=n>>>0;return o+(r>>>0)+((i&s|(i|s)&~(i+s>>>0))>>>31)|0}})},function(t,e,n){var r=n(0);r(r.S,\"Math\",{imulh:function(t,e){var n=+t,r=+e,i=65535&n,o=65535&r,s=n>>16,u=r>>16,a=(s*o>>>0)+(i*o>>>16);return s*u+(a>>16)+((i*u>>>0)+(65535&a)>>16)}})},function(t,e,n){var r=n(0);r(r.S,\"Math\",{isubh:function(t,e,n,r){var i=t>>>0,o=e>>>0,s=n>>>0;return o-(r>>>0)-((~i&s|~(i^s)&i-s>>>0)>>>31)|0}})},function(t,e,n){var r=n(0);r(r.S,\"Math\",{RAD_PER_DEG:180/Math.PI})},function(t,e,n){var r=n(0),i=Math.PI/180;r(r.S,\"Math\",{radians:function(t){return t*i}})},function(t,e,n){var r=n(0);r(r.S,\"Math\",{scale:n(109)})},function(t,e,n){var r=n(0);r(r.S,\"Math\",{signbit:function(t){return(t=+t)!=t?t:0==t?1/t==1/0:t>0}})},function(t,e,n){var r=n(0);r(r.S,\"Math\",{umulh:function(t,e){var n=+t,r=+e,i=65535&n,o=65535&r,s=n>>>16,u=r>>>16,a=(s*o>>>0)+(i*o>>>16);return s*u+(a>>>16)+((i*u>>>0)+(65535&a)>>>16)}})},function(t,e,n){\"use strict\";var r=n(0),i=n(9),o=n(10),s=n(8);n(7)&&r(r.P+n(58),\"Object\",{__defineGetter__:function(t,e){s.f(i(this),t,{get:o(e),enumerable:!0,configurable:!0})}})},function(t,e,n){\"use strict\";var r=n(0),i=n(9),o=n(10),s=n(8);n(7)&&r(r.P+n(58),\"Object\",{__defineSetter__:function(t,e){s.f(i(this),t,{set:o(e),enumerable:!0,configurable:!0})}})},function(t,e,n){var r=n(0),i=n(114)(!0);r(r.S,\"Object\",{entries:function(t){return i(t)}})},function(t,e,n){var r=n(0),i=n(115),o=n(17),s=n(15),u=n(69);r(r.S,\"Object\",{getOwnPropertyDescriptors:function(t){for(var e,n,r=o(t),a=s.f,c=i(r),l={},f=0;c.length>f;)void 0!==(n=a(r,e=c[f++]))&&u(l,e,n);return l}})},function(t,e,n){\"use strict\";var r=n(0),i=n(9),o=n(26),s=n(16),u=n(15).f;n(7)&&r(r.P+n(58),\"Object\",{__lookupGetter__:function(t){var e,n=i(this),r=o(t,!0);do{if(e=u(n,r))return e.get}while(n=s(n))}})},function(t,e,n){\"use strict\";var r=n(0),i=n(9),o=n(26),s=n(16),u=n(15).f;n(7)&&r(r.P+n(58),\"Object\",{__lookupSetter__:function(t){var e,n=i(this),r=o(t,!0);do{if(e=u(n,r))return e.set}while(n=s(n))}})},function(t,e,n){var r=n(0),i=n(114)(!1);r(r.S,\"Object\",{values:function(t){return i(t)}})},function(t,e,n){\"use strict\";var r=n(0),i=n(2),o=n(19),s=n(80)(),u=n(5)(\"observable\"),a=n(10),c=n(1),l=n(32),f=n(38),h=n(11),d=n(33),p=d.RETURN,v=function(t){return null==t?void 0:a(t)},g=function(t){var e=t._c;e&&(t._c=void 0,e())},m=function(t){return void 0===t._o},y=function(t){m(t)||(t._o=void 0,g(t))},b=function(t,e){c(t),this._c=void 0,this._o=t,t=new _(this);try{var n=e(t),r=n;null!=n&&(\"function\"==typeof n.unsubscribe?n=function(){r.unsubscribe()}:a(n),this._c=n)}catch(e){return void t.error(e)}m(this)&&g(this)};b.prototype=f({},{unsubscribe:function(){y(this)}});var _=function(t){this._s=t};_.prototype=f({},{next:function(t){var e=this._s;if(!m(e)){var n=e._o;try{var r=v(n.next);if(r)return r.call(n,t)}catch(t){try{y(e)}finally{throw t}}}},error:function(t){var e=this._s;if(m(e))throw t;var n=e._o;e._o=void 0;try{var r=v(n.error);if(!r)throw t;t=r.call(n,t)}catch(t){try{g(e)}finally{throw t}}return g(e),t},complete:function(t){var e=this._s;if(!m(e)){var n=e._o;e._o=void 0;try{var r=v(n.complete);t=r?r.call(n,t):void 0}catch(t){try{g(e)}finally{throw t}}return g(e),t}}});var w=function(t){l(this,w,\"Observable\",\"_f\")._f=a(t)};f(w.prototype,{subscribe:function(t){return new b(t,this._f)},forEach:function(t){var e=this;return new(o.Promise||i.Promise)(function(n,r){a(t);var i=e.subscribe({next:function(e){try{return t(e)}catch(t){r(t),i.unsubscribe()}},error:r,complete:n})})}}),f(w,{from:function(t){var e=\"function\"==typeof this?this:w,n=v(c(t)[u]);if(n){var r=c(n.call(t));return r.constructor===e?r:new e(function(t){return r.subscribe(t)})}return new e(function(e){var n=!1;return s(function(){if(!n){try{if(d(t,!1,function(t){if(e.next(t),n)return p})===p)return}catch(t){if(n)throw t;return void e.error(t)}e.complete()}}),function(){n=!0}})},of:function(){for(var t=0,e=arguments.length,n=new Array(e);t","link":"/js/Valine.min.js"}],"posts":[{"title":"spark安装","text":"第十一节spark安装 安装 123cd /usr/appwget https://archive.apache.org/dist/spark/spark-2.0.0/spark-2.0.0-bin-hadoop2.7.tgztar -zxvf spark-2.0.0-bin-hadoop2.7.tgz spark-2.0.0-bin-hadoop2.7 添加环境变量 12345vi /etc/profile# 添加以下内容export Spark_HOME=/usr/app/spark-2.0.0-bin-hadoop2.7export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HBASE_HOME/bin:$HIVE_HOME/bin:$Flume_HOME/bin:$Spark_HOME/bin:$Scala_HOME/bin 配置./conf/slaves 12345678/usr/app/spark-2.0.0-bin-hadoop2.7/conf/# 首先将 slaves.template 拷贝一份cp -r slaves.template slaves# 修改 slaves 文件,添加hadoop11hadoop12hadoop13 配置./conf/spark-env.sh 123456789#将 spark-env.sh. template 拷贝一份cp -r spark-env.sh.template spark-env.shvi /conf/spark-env.sh#添加以下内容export JAVA_HOME=/usr/app/jdk1.8.0_77export Scala_HOME=scala-2.11.11export SPARK_MASTER_IP=hadoop11export SPARK_WORKER_MEMORY=2gexport MASTER=spark://hadoop11:7077 将 spark-2.0.0-bin-hadoop2.7 文件夹拷贝到另外两个结点 12scp -r /usr/app/spark-2.0.0-bin-hadoop2.7 root@hadoop12:/usr/appscp -r /usr/app/spark-2.0.0-bin-hadoop2.7 root@hadoop13:/usr/app 编辑其余两台的环境变量 12export Spark_HOME=/usr/app/spark-2.0.0-bin-hadoop2.7export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HBASE_HOME/bin:$Spark_HOME/bin:$S 启动 12/usr/app/spark-2.0.0-bin-hadoop2.7/sbin/start-all.sh #启动Spark集群/usr/app/spark-2.0.0-bin-hadoop2.7/bin/spark-shell #启动spark-shell","link":"/2020/05/08/11/"},{"title":"VMware16安装_Ubuntu","text":"第一节 VMware16安装Step1：下载VMware Workstation Pro要安装VMware，请首先在系统上下载二进制软件包。在VMware官方网站上找到最新的稳定版本。 1.打开一个Web浏览器，转到VMware的官方网站，然后按照以下路径导航到 Try VMware Workstation Pro page by following the path: Products &gt; Workstation Pro &gt; Try VMware Workstation Pro 2.由于要在Ubuntu上进行安装，请找到适用于Linux的安装软件，然后单击DOWNLOAD NOW。 Step2：安装先决条件GNU Compiler Collection和Build Essential是安装VMware Workstation所需的软件先决条件。 如果您的系统上没有它，请执行以下步骤安装它们： 1.右键单击窗口，然后选择“在终端中打开”，从“下载”文件夹中打开终端。 2.在安装任何软件之前，请确保使用以下命令更新软件包存储库： 1sudo apt update 3.然后，安装必备组件GNU Compiler Collection和Build Essential，这些必备组件将在安装过程中使用。运行命令： 1sudo apt install gcc build-essential 按y确认安装，然后按Enter。 Step3：提取VMware Installer在继续进行正式安装过程之前，在终端提取下载的.bundle文件。 1.在终端中打开下载的bundle文件目录,并为其添加可执行权限： 1sudo chmod +x VMware-Player-16.1.1-17801498.x86_64.bundle 复制完整的文件名，下一步将需要它。 2.接下来，通过键入命令sudo ./+完整的文件名来提取文件。 命令输出将是： 3.提取完文件后，它将自动打开一个新窗口，即VMware Workstation Installer。 Step4：安装VMware Workstation1.启动VMware Workstation Installer后，通过选择配置首选项并单击“下一步”来完成这些步骤。 2.完成安装后，它将显示“安装已成功”通知。 3.通过在Ubuntu Dash中键入名称搜索WMware。通过单击图标即可打开虚拟化软件。 4.在登陆VMware Workstation的 主窗口之前，它将要求您： 输入许可证密钥 免费试用30天。 1234567Serial keys: ZF3R0-FHED2-M80TY-8QYGC-NPKYFYF390-0HF8P-M81RQ-2DXQE-M2UT6ZF71R-DMX85-08DQY-8YMNC-PPHV8AZ3E8-DCD8J-0842Z-N6NZE-XPKYFFC11K-00DE0-0800Z-04Z5E-MC8T6(version for 16pro) 5.输入上述密钥之一后，即可打开VMware 开始体验。 截至目前，VMware已经安装完成，Centos镜像的安装请查看下一节","link":"/2020/05/08/1/"},{"title":"scala安装","text":"第十节 scala安装 安装 123cd /usr/app/wget https://downloads.lightbend.com/scala/2.11.11/scala-2.11.11.tgztar -zxvf scala-2.11.11.tgz 配置环境变量 1234567vi /etc/profile#添加以下内容export Scala_HOME=scala-2.11.11export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HBASE_HOME/bin:$HIVE_HOME/bin:$Flume_HOME/bin:$Scala_HOME/bin#刷新配置文件source /etc/profile 检测 scala 版本 12cd /usr/appscala -version 检测 scala 的客户端 12scala scala&gt; print(&quot;Hello Scala&quot;)","link":"/2020/05/08/10/"},{"title":"Centos7 安装","text":"第二节 Centos7 安装CentOS是基于Red Hat Enterprise Linux（RHEL）的开源Linux发行版。由于CentOS 7的稳定性和活跃的开发人员社区，它被视为Web托管的首选选项。 在本教程中，通过几个简单的步骤学习如何安装CentOS 7。 Prerequisites 建议最少10GB的可用磁盘空间 CentOS 7 ISO安装文件 Step1：下载CentOS 7要下载官方和最新的CentOS 7 ISO文件，请浏览至阿里云镜像。 建议Minimal-2009.iso 即可 Step2：配置CentOS 7镜像 打开Vmware ，点击左上角File选择New Virtual Machine 选择 Typical ,继续Next 选择 Use ISO image ,然后找到下载好的镜像文件，Next. Guest Operating System 选择Linux,Next. 选择虚拟机存放的位置（完整的集群环境需约15G的空间）,Next. 分配15G的磁盘空间，Next. FInsh. close. Step3：启动CentOS ISO镜像 开始安装过程。为此，请选择Install CentOS 7。 选择语言 中文，继续。 点击安装目标位置，默认即可 设置网络和主机名 设置主机名后，点击配置 点击VMware 左上角的Edit 选择 Virtual Network editor. 查看NAT设置中相应的IPV4地址及网关 在IPV4设置中，方法选择手动，将刚才记录的数据填入相应的虚拟机设置中，IP地址保持前三段数字相同，末尾段自定义。 设置root账号和自定义用户，Root用户仅需设置密码，然后点击创建用户，将用户名设为Hadoop，选择“将此用户做为管理员” 软件安装，选择最小安装。 等待安装完成（需要较长时间），点击重启 登录系统 输入对应的用户名与密码进入系统。 至此，centos7虚拟机安装完成。 下节Hadoop2.7 安装","link":"/2020/05/08/2/"},{"title":"Zookeeper安装","text":"第四节 Zookeeper安装zookeeper 安装 下载zookeeper 12cd /usr/appwget https://archive.apache.org/dist/zookeeper/zookeeper-3.4.8/zookeeper-3.4.8.tar.gz 解压 1tar -zxvf zookeeper-3.4.8.tar.gz 配置(先在一台节点上配置) 添加一个 zoo.cfg 配置文件 12cd zookeeper-3.4.8/conf/cp -r zoo_sample.cfg zoo.cfg 修改配置文件(zoo.cfg) 12# 建立/usr/app/zookeeper-3.4.8/data 目录,mkdir /usr/app/zookeeper-3.4.8/data 配置 zoo.cfg 12345dataDir=/usr/app/zookeeper-3.4.8/data #在最后一行添加server.1=hadoop11:2888:3888server.2=hadoop12:2888:3888server.3=hadoop13:2888:3888 创建一个 myid 文件, 12345cd /usr/app/zookeeper-3.4.8/datatouch myidvi myidecho &quot;1&quot; &gt;myid#里面内容是 server.N 中的 N(server.2 里面内容为 2) 拷贝 123456# 将配置好的 zk 拷贝到其他节点scp -r /usr/app/zookeeper-3.4.8/root@hadoop12:/usr/appscp -r /usr/app/zookeeper-3.4.8/root@hadoop13:/usr/app# 注意:在其他节点上一定要修改 myid 的内容# 在 hadoop12 应该讲 myid 的内容改为 2 (echo &quot;2&quot; &gt;myid)# 在 hadoop13 应该讲 myid 的内容改为 3 (echo &quot;3&quot; &gt;myid) 启动集群 1234# Zookeeper 启动及关闭命令/usr/app/zookeeper-3.4.8/bin/./zkServer.sh start/usr/app/zookeeper-3.4.8/bin/./zkServer.sh stop# 选出 leader 和 follower, 12#查看启动状态查看命令/usr/app/zookeeper-3.4.8/bin/./zkServer.sh status 至此，Zookeeper安装完成 下节Hbase安装","link":"/2020/05/08/4/"},{"title":"Hadoop2.7 安装","text":"第三节 Hadoop2.7 安装 介绍Step1: 配置远程登录由于我们没有安装桌面环境，虚拟机中Centos的终端相对简陋，我们在宿主机终端通过SSH登录Centos即可.（主机系统为Ubuntu ，我们不需要下载其他的远程连接工具） 将服务器IP设为静态 打开网络配置文件，命令如下 1sudo vi /etc/sysconfig/network-scripts/ifcfg-ens33 用如下内容替换文件中的内容，将注释内容更改为自己服务器相应的。 12345678TYPE=&quot;Ethernet&quot;BOOTPROTO=&quot;static&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot;IPADDR=192.168.200.101 #IPNETMASK=255.255.255.0 #子网掩码GATEWAY=192.168.200.2 #网关DNS1=114.114.114.114 重启网络 1sudo service network restart 在宿主机hosts文件中添加相应服务器的域名映射. 1sudo gedit /etc/hosts 测试SSH登录 1sudo ssh hadoop14 更改主机名 1sudo vi /etc/hostname # 修改为master Step2: 安装JDK Hadoop支持Openjdk ，因此我们可用使用命令 安装openjdk7，替代Oracle JDK。 1su -c &quot;yum install java-1.7.0-openjdk&quot; 查看Java版本 1java -version 配置Java环境变量 123sudo vi /etc/profile# javaexport JAVA_HOME=/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.261-2.6.22.2.el7_8.x86_64 Step3: 安装Hadoop2.7.3 新建资源目录 12sudo mkdir /opt/softwares sudo mkdir /opt/modules 安装wget 1yum install wget 下载hadoop2.7.3 ，速度较慢 推荐使用百度网盘下载到本地后，使用scp命令上传到服务器 链接: https://pan.baidu.com/s/1W_S5BcghFqjwdUi0GfqeSQ 密码: p2ek 123wget https://archive.apache.org/dist/hadoop/common/hadoop-2.7.3/hadoop-2.7.3.tar.gz #在线下载sudo scp -r hadoop-2.7.3.tar.gz hadoop14:/opt/softwares/ #本地上传 解压hadoop,转到hadoop文件夹下，执行以下命令。 1tar -xvf hadoop-2.7.3.tar.gz 关闭防火墙 由于hadoop需要打开的端口太多，因此此处暂时关闭了防火墙。要关闭防火墙，必须在root用户下使用以下命令： 1234#Close the firewallsystemctl stop firewalld.service#Turn off boot and self-startsystemctl disable firewalld.service 创建数据存储目录 123cd /usr/local/hadoopmkdir tmpmkdir -p hdfs/data hdfs/name 配置环境变量 12345678910111213141516171819202122 sudo vi /etc/profile export JAVA_HOME=/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.261-2.6.22.2.el7_8.x86_64 export PATH=$PATH:$JAVA_HOME/bin export CLASSPATH=.:$JAVA_HOME/jre/lib:$JAVA_HOME/lib:$JAVA_HOME/lib/tools.jar export HADOOP_HOME=/opt/softwares/hadoop export HADOOP_INSTALL=$HADOOP_HOME export HADOOP_MAPRED_HOME=$HADOOP_HOME export HADOOP_COMMON_HOME=$HADOOP_HOME export HADOOP_HDFS_HOME=$HADOOP_HOME export YARN_HOME=$HADOOP_HOME export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native export PATH=$PATH:$HADOOP_HOME/sbin:$HADOOP_HOME/bin使用以下命令初始化变量。 source /etc/profile完成后，您现在可以检查是否设置了环境变量。运行以下命令。 echo $JAVA_HOME它应该提供以下输出。 /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.261-2.6.22.2.el7_8.x86_64同时运行以下命令。 echo $HADOOP_HOME它应该显示以下输出。 /opt/softwares/hadoop 配置,进入hadoop目录下 1 修改core-site.xml文件 123456789101112131415&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://master:9000&lt;/value&gt; # &lt;/property&gt; &lt;property&gt; &lt;name&gt;io.file.buffer.size&lt;/name&gt; &lt;value&gt;131072&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/home/hadoop/tmp&lt;/value&gt; # &lt;description&gt;Abase for other temporary directories.&lt;/description&gt; &lt;/property&gt;&lt;/configuration&gt; 2 修改hdfs-site.xml文件 123456789101112131415161718192021222324&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt; &lt;value&gt;linux-node1:9001&lt;/value&gt; &lt;description&gt;# View HDFS status &lt;/description&gt; through the web interface &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/home/hadoop/dfs/name&lt;/value&gt; # &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/home/hadoop/dfs/data&lt;/value&gt; # &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;2&lt;/value&gt; &lt;description&gt;# Each Block has two backups &lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 3 修改mapred-site.xml (重命名mapred-site.xml.template并添加以下内容) (这是MapReduce任务的配置。因为Hadoop 2.x使用yarn框架来实现分布式部署，所以必须在mapreduce.framework.name属性下配置yarn。mapred.map.tasks和mapred.reduce.tasks分别是map和reduce的任务数。) 1mv mapred-site.xml.template mapred-site.xml 1234567891011121314&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt; &lt;value&gt;master:10020&lt;/value&gt; # &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt; &lt;value&gt;master:19888&lt;/value&gt; # &lt;/property&gt;&lt;/configuration&gt; 4 配置节点yarn-site.xml 1234567891011121314151617181920212223242526272829303132333435&lt;configuration&gt; &lt;!-- Site specific YARN configuration properties --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services.mapreduce.shuffle.class&lt;/name&gt; &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt; &lt;value&gt;master:8032&lt;/value&gt; # &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt; &lt;value&gt;master:8030&lt;/value&gt; # &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt; &lt;value&gt;master:8031&lt;/value&gt; # &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.admin.address&lt;/name&gt; &lt;value&gt;master:8033&lt;/value&gt; # &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt; &lt;value&gt;master:8088&lt;/value&gt; # &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt; &lt;value&gt;8192&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 5 配置hadoop环境变量 123456[root@master ~]$ vi /etc/profile#Replace the previously modified java environment variable.export JAVA_HOME=java-1.7.0-openjdk-1.7.0.261-2.6.22.2.el7_8.x86_64export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport HADOOP_HOME=/usr/local/hadoopexport PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin 12345[hadoop@master ~]$ vi ~/.bashrcexport JAVA_HOME=java-1.7.0-openjdk-1.7.0.261-2.6.22.2.el7_8.x86_64export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport HADOOP_HOME=/usr/local/hadoopexport PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin Step4:克隆虚拟机 克隆Hadoop02，Hadoop03节点。 关闭虚拟机master，然后在VMware左侧的虚拟机列表中右键单击【Hadoop01】，选择【Manager】-&gt;【Clone】 点击下一步,在Clone Type处选择Create a full clone 修改虚拟机名称与文件路径，点击完成，等待克隆完成 克隆Hadoop03的步骤同上 修改节点主机名 首先修改Hadoop02和Hadoop03的主机名（他们目前都是master） 123vi /etc/hostnames# Hadoop02修改为slave1# Hadoop03修改为slave2 修改IP 1234sudo vi /etc/sysconfig/network-scripts/ifcfg-ens33# 修改Hadoop02的IP为192.168.200.102# 修改Hadoop03的IP为192.168.200.103sudo service network restart #重启网络 添加域名解析 123456789分别修改Hadoop01,Hadoop02,Hadoop03,及宿主机的域名映射文件sudo vi /etc/hosts# 在host文件末尾追加以下内容：# 192.168.200.101 master# 192.168.200.102 slave1# 192.168.200.103 slave2 在各节点使用ping命令检查是否配置成功： 123ping masterping slave1ping slave2 Step5：配置ssh免密登录 生成密钥文件： 123ssh-keygen -t rsa# 生成中按enter即可# 在三台服务器中执行此命令 SSH分发 12345ssh-copy-id masterssh-copy-id slave1ssh-copy-id slave2# 在三台服务器中执行上述命令#Are you sure you want to continue connecting (yes/no)? 需输入yes 验证SSH登录 1234ssh masterssh slave1ssh slave2#三台机器中分别执行上述命令 格式化一个新的分布式文件系统： 12345hadoop namenode -format#在第一使用 Hadoop 之前，需要先格式化#在master上,执行上述命令#显示 tmp/dfs/name has been successfully formatted #及Exiting with status 0 表明格式化成功 Step6： 启动Hadoop123#在master上执行cd /usr/app/hadoop-2.7.3/sbin/./start-all.sh jps查看各节点启动进程 Step7： 集群web123Hadoop集群启动并运行后，可以通过web-ui进行集群查看，如下所述：然后本机访问http://(Hadoop01 IP):50070 #hdfshttp://(Hadoop01 IP):8088 #yarn Step8：验证 验证 HDFS HA 首先向 hdfs 上传一个文件 12hadoop fs -put /etc/profile /hadoop fs -ls / 通过浏览器访问:http://192.168.200.11:50070 验证 YARN 运行一下 hadoop 提供的 demo 中的 WordCount 程序: 1hadoop jar /usr/app/hadoop-2.7.3/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.3.jar wordcount /profile /out 至此，hadoop安装完成 下节Zookeeper安装","link":"/2020/05/08/3/"},{"title":"Hbase安装","text":"第五节 Hbase安装主节点安装 hbase 安装 hbase 12cd /usr/app wget https://archive.apache.org/dist/hbase/1.2.6/hbase-1.2.6-bin.tar.gz 解压 1tar –zxvf hbase-1.2.6-bin.tar.gz 配置 hbase 集群 把 hadoop 的 hdfs-site.xml 和 core-site.xml 放到 hbase/conf 修改 环境变量 12345Vi /etc/profileexport JAVA_HOME=/usr/app/jdk1.8.0_77export HADOOP_HOME=/usr/app/hadoop-2.7.3export HBASE_HOME=/usr/app/hbase-1.2.6export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HBASE_HOME/bin# 注意:source /etc/profile (刷新环境变量配置文件) 1234# 修改 hbase-env.sh /usr/app/hbase-1.2.6/conf/export JAVA_HOME= /usr/app/jdk1.8.0_77# hbase 使用外部的 zk,hbase自带的zk只可用于伪分布式export HBASE_MANAGES_ZK=false 修改 hbase-site.xml 配置 1vim hbase-site.xml 123456789101112131415161718192021&lt;configuration&gt;&lt;!-- 指定 hbase 在 HDFS 上存储的路径 --&gt;&lt;property&gt;&lt;name&gt;hbase.rootdir&lt;/name&gt;&lt;value&gt;hdfs://ns1/hbase&lt;/value&gt;&lt;/property&gt;&lt;!-- 指定 hbase 是分布式的 --&gt;&lt;property&gt;&lt;name&gt;hbase.cluster.distributed&lt;/name&gt;&lt;value&gt;true&lt;/value&gt;&lt;property&gt;&lt;name&gt;hbase.master.info.port&lt;/name&gt;&lt;value&gt;60010&lt;/value&gt;&lt;/property&gt;&lt;/property&gt;&lt;!-- 指定 zk 的地址,多个用“,”分割 --&gt;&lt;property&gt;&lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;&lt;value&gt;hadoop11:2181,hadoop12:2181,hadoop13:2181&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt; 增加 slave 的集群 1Vim /usr/app/hbase-1.2.6/conf/regionservers 1234# (部署到 datanode 上面,那一台启动 hbase 那一台就是 master) hadoop11 hadoop12 hadoop13 拷贝 hbase 到其他节点 12scp -r /usr/app/hbase-1.2.6 root@hadoop12:/usr/app/scp -r /usr/app/hbase-1.2.6 root@hadoop13:/usr/app/ 启动所有的 hbase 1234567# 前提需要:Zookeeper 和 Hdfs 启动# 分别启动 zk./zkServer.sh start# 启动 hbase 集群start-dfs.sh# 启动 hbase,在主节点上运行:/usr/app/hbase-1.2.6/bin/start-hbase.sh 通过浏览器访问 hbase 管理页面 1http://192.168.200.11:16010/master-status 为保证集群的可靠性,要启动多个 HMaster 1hbase-daemon.sh start master HBase Shell命令行操作 启动HBase Shell 1bin/hbase shell 创建表，需要创建表明，另外需要指定列簇(column family)。表名和列簇名都需要使用引号括起来。 1create 'test','f1' 向表中加入数据。这里使用关键字put。 1put 'test',1,'f1:id',100 删除表。连表也删除掉，使用关键字drop，但是不能直接drop，在drop之前需要先disable。 disable 'test' drop 'test' 至此，Hbase安装完成 下节MYSQL安装","link":"/2020/05/08/5/"},{"title":"主节点安装 Hive","text":"第七节 主节点安装 Hive 上传压缩包,解压 1wget https://archive.apache.org/dist/hive/hive-0.12.0/hive-0.12.0-bin.tar.gz 安装 mysql 服务器(见上一节) 配置环境变量 123456vi /etc/profile export JAVA_HOME=/usr/app/jdk1.8.0_77export HADOOP_HOME=/usr/app/hadoop-2.7.3export HBASE_HOME=/usr/app/hbase-1.2.6export HIVE_HOME=/usr/app/hive-0.12.0export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HBASE_HOME/bin:$HIVE_HOME/bin 进入 hive 的 conf 目录新建一个 hive-site.xml 12cd /usr/app/hive-0.12.0/touch hive-site.xml 在 hive-site.xml 中写入 mysql 连接信息 123456789101112131415161718192021222324252627282930&lt;configuration&gt;&lt;property&gt;&lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;&lt;value&gt;jdbc:mysql://hadoop11:3306/hive?createDatabaseIfNotExist=true&lt;/value&gt;&lt;description&gt;JDBC connect string for a JDBC metastore&lt;/description&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;&lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;&lt;description&gt;Driver class name for a JDBC metastore&lt;/description&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;&lt;value&gt;root&lt;/value&gt;&lt;description&gt;username to use against metastore database&lt;/description&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;&lt;value&gt;123456&lt;/value&gt;&lt;description&gt;password to use against metastore database&lt;/description&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;hive.server2.thrift.sasl.qop&lt;/name&gt;&lt;value&gt;auth&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;hive.metastore.schema.verification&lt;/name&gt;&lt;value&gt;false&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt; 将 mysql 的驱动包复制到 hive 的 lib 目录下 app/hive-0.12.0/lib 修改/usr/app/hive-0.12.0/conf/hive-env.sh 1234# 增加以下内容export JAVA_HOME=/usr/app/jdk1.8.0_77export HADOOP_HOME=/usr/app/hadoop-2.7.3export HBASE_HOME=/usr/app/hbase-1.2.6 验证hive安装 123456Sh /usr/app/hive-0.12.0/bin/hive #启动 hivehive&gt; create table test(id int,name string);hive&gt; show tables;[root@hadoop11 ~]# hadoop fs -lsr / 下节 flume安装","link":"/2020/05/08/7/"},{"title":"主节点安装 MySql","text":"第六节 主节点安装 MySql 安装 mysql 服务器命令如下: 1yum install mysql-server 设置开机启动命令如下: 1chkconfig mysqld on 启动 mysql 服务命令如下: 123service mysqld start#根据提示设置 root 的初试密码命令：mysqladmin -u root password 123456 进入 mysql 命令行命令如下: 123mysql -uroot –p#输入密码 123456 在 Mysql 中执行这四步: 1234create database hive DEFAULT CHARSET utf8 COLLATE utf8_general_ci;create database amon DEFAULT CHARSET utf8 COLLATE utf8_general_ci;grant all privileges on *.* to 'root'@'%' identified by '123456' with grant option;flush privileges; 备注说明:创建以下数据库: 12345678910111213141516171819#hivecreate database hive DEFAULT CHARSET utf8 COLLATE utf8_general_ci;#activity monitorcreate database amon DEFAULT CHARSET utf8 COLLATE utf8_general_ci;#设置 root 授权访问以上所有的数据库:#授权 root 用户在主节点拥有所有数据库的访问权限grant all privileges on *.* to 'root'@'n1' identified by 'xxxx' with grant option;flush privileges;grant all privileges on *.* to 'root'@'%' identified by '123456' with grant option;flush privileges;#对用户授权mysql&gt;grant rights on database.* to user@host identified by &quot;pass&quot;;#例 1:#增加一个用户 test1 密码为 abc,让他可以在任何主机上登录,并对所有数据库有查询、插#入、修改、删除的权限。grantselect,insert,update,delete on *.* to test1@&quot;%&quot; Identified by &quot;abc&quot;;ON 子句中*.* 说明符的意思是“所有数据库,所有的表”#例 2:#增加一个用户 test2 密码为 abc, 让他只可以在 localhost 上登录,并可以对数据库 mydb 进行#查询、插入、修改、删除的操作。grant select,insert,update,delete on mydb.* to test2@localhost identified by &quot;abc&quot;; 下节 主节点安装 hive 和启动 ```","link":"/2020/05/08/6/"},{"title":"flume安装","text":"第八节 flume安装 Flume 安装 1234cd /usr/app/wget http://archive.apache.org/dist/flume/1.6.0/apache-flume-1.6.0-bin.tar.gztar -zxvf apache-flume-1.6.0-bin.tar.gz mv apache-flume-1.6.0-bin flume1.6 #重命名 配置 12345678#添加环境变量vi /etc/profile#添加以下两行内容export Flume_HOME=/usr/app/flume1.6export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HBASE_HOME/bin:$HIVE_HOME/bin:$Flume_HOME/bin#更新profilesource /etc/profile 123456789#编辑/usr/app/flume1.6/conf/flume-env.shcd /usr/app/flume1.6/conf/cp -r flume-env.sh.template flume-env.shchmod 777 flume-env.shvi flume-env.sh#添加Java 路径export JAVA_HOME=/usr/app/jdk1.8.0_77# 设置权限chmod 777 flume-env.sh 测试配置 12#查看版本flume-ng version 下节kafka安装","link":"/2020/05/08/8/"},{"title":"当我们在谈论动态规划时，在谈些什么？","text":"初次接触动态规划时在算法课 知其然，知其所以然 动态规划的发明历程动态规划既是一种数学优化方法，也是一种计算机编程方法。该方法由Richard Bellman在 1950 年代开发，当时美国数学家Richard Bellman在研究多阶段决策过程的最优解时，提出了最优性原则，并将其应用到动态规划方法中。Bellman在其著作《动态规划》中详细介绍了这种方法，并且这本书的出版标志着动态规划作为一种数学方法的诞生。 动态规划最初的应用是在经济学中，用于解决投资和资源分配的问题。之后，动态规划方法被广泛地应用于许多其他领域，包括工程学、计算机科学、生物学和物理学等。特别是在计算机科学中，动态规划方法被广泛应用于算法设计和优化，如在图形处理、字符串匹配和最短路径等方面。 动态规划方法的本质是将大问题划分为若干个小问题，并将其按顺序求解。在求解每个小问题时，动态规划方法会保存已经解决的子问题的结果，以便后续计算时重复利用，避免重复计算，提高算法效率。因此，动态规划是一种非常强大的优化方法，能够解决很多复杂问题。 最优性原则是由Richard Bellman开发的动态规划的基本原则：最优路径具有以下特性：无论初始条件和初始阶段的控制变量（选择）如何，选择的控制（或决策变量）在剩下的时间段内，对于剩余的问题必须是最佳的，因为早期决定所导致的状态是最初的状况。 在编程中以背包问题为例： 定义状态：将问题抽象为状态。在背包问题中，状态可以定义为在前i个物品中选择一定物品放入一个容量为j的背包可以获得的最大价值。这里的i和j都是状态的变量。 定义状态转移方程：确定状态转移的方式和公式。在背包问题中，状态转移方程可以定义为：当选择第i个物品时，背包剩余的容量为j，此时背包可以装下的最大价值为f(i, j) = max{f(i-1, j), f(i-1, j-w(i))+v(i)}。其中w(i)和v(i)分别表示第i个物品的重量和价值。 确定边界条件：确定状态的起点和终点。在背包问题中，边界条件可以定义为：当i=0或j=0时，背包中的最大价值为0。 计算最终结果：根据状态转移方程和边界条件，通过迭代计算得到最终的结果。在背包问题中，最终的结果为f(n, C)，其中n表示物品的总数，C表示背包的容量。 总的来说，动态规划是一种通过将问题拆分为多个子问题并重复利用已经计算出来的结果来求解最优解的方法。它在计算机编程和数学优化中都有着广泛的应用，并为我们提供了一种强大的工具来解决复杂的问题。","link":"/2021/08/07/Dynamic-Programing/"},{"title":"GTK移植到Windows VS2017","text":"[GTK](https://baike.baidu.com/item/gtk/3138659?fr=aladdin)主要是Linux下的图形工具包,但在windows与Mac os下面也有相应的版本。 本篇博文废话不多直入正题，下面开始我们的教程：[本文具有时效性] 首先，你要有Git，会基本操作就可以，不会Git操作也没关系，跟着博文走就行. Visual Studio2017 的准备操作: 这三个打上对勾, 下面就开始安装GTK 首先来到GTK官网,下载windows所需的版本,(XL工具),然后(下面是可耻翻译的官网的一大段话,但是你也要按我下面的步骤来): 从vcpkg软件包中使用GTK警告：GTK团队不维护vcpkg打包，它使用的构建系统不同于GTK所使用的构建系统。如果使用vcpkg构建GTK或其依赖项时发生故障，请确保在vcpkg问题跟踪器（而不是GTK 问题）中打开一个问题。 安装Microsoft vcpkg项目将GTK库以及所有先决条件和许多语言绑定（例如C ++绑定gtkmm）打包在一起，以便与Visual Studio一起使用。这提供了一种非常简单的方法来设置开发环境以创建GTK应用程序。如果您希望通过命令行而不是使用Visual Studio进行更类似于UNIX的体验，则可能需要考虑从MSYS2安装GTK。 为了使用vcpkg软件包，首先需要克隆vcpkg存储库， 然后可以使用以下命令安装GTK软件包 ：冒号“：”后面的部分指定目标。完成此步骤后，在Visual Studio中创建的任何项目现在都将自动看到GTK库。依次在Git上敲击以下命令: git clone https://github.com/Microsoft/vcpkg cd vcpkg ./bootstrap-vcpkg.bat ./vcpkg install gtk:x64-windows构建和分发您的应用程序如上所述安装GTK后，编译GTK应用程序应该没有问题。为了成功运行它，您还将需要一个GTK主题。GTK中对Windows主题有一些旧的内置支持，但这使您的应用看起来像Windows 7应用。最好使用Windows 10主题，例如Windows 10 Transformation Pack。 gtk-3.20将该存储库的文件夹复制到share/themes/Windows10/gtk-3.0/安装文件夹中的文件夹中。您还需要复制Adwaita主题中的图标，可以从Linux框中获取图标，它们存储在其中 /usr/share/icons/Adwaita/；将此整个文件夹复制到 share/icons安装文件夹中的文件夹中。彩色图标的同上。为了使GTK能够使用此主题，请将文件settings.ini放在etc/gtk-3.0 安装文件夹中。它应该包含 并且最重要的是，找到其中的文件并将其复制到 。[Settings]gtk-theme-name=Windows10gtk-font-name=Segoe UI 9 gschemas.compiled/usr/share/glib-2.0/schemas/share/glib-2.0/schemas 然后，您可以压缩安装文件夹，或使用安装程序生成器为您执行此操作，然后分发结果。 最后,在VS上复制一下这段代码,应该可以成功运行,不能就在下面留言 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include &lt;gtk/gtk.h&gt;#pragma warning (disable:4996)/* 我们的回调。* 传到这个函数的数据被打印到标准输出 */void callback(GtkWidget *widget, gpointer data){ g_print(&quot;%s&quot;, (char *)data);}/* 这个回调退出程序 */gint delete_event(GtkWidget *widget, GdkEvent *event, gpointer data){ gtk_main_quit(); return FALSE;}int main(int argc, char *argv[]){ GtkWidget *window; GtkWidget *button; GtkWidget *table; gtk_init(&amp;argc, &amp;argv); /* 创建一个新窗口 */ window = gtk_window_new(GTK_WINDOW_TOPLEVEL); /* 设置窗口标题 */ gtk_window_set_title(GTK_WINDOW(window), &quot;Shimmer's Keyboard&quot;); /* 为 delete_event 设置一个立即退出 GTK 的处理函数。 */ g_signal_connect(G_OBJECT(window), &quot;delete_event&quot;, G_CALLBACK(delete_event), NULL); /* 设置窗口的边框宽度。 */ gtk_container_set_border_width(GTK_CONTAINER(window), 20); /* 创建一个 2x2 的表 */ table = gtk_table_new(4, 20, TRUE); /* 将表放进主窗口 */ gtk_container_add(GTK_CONTAINER(window), table); /* 创建第一个按钮 */ button = gtk_button_new_with_label(&quot;Q&quot;); /* 当这个按钮被点击时,我们调用 &quot;callback&quot; 函数,并将一个指向&quot;button 1&quot;的指针作为它的参数 */ g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;q&quot;); /* 将 button 1 插入表的左上象限(quadrant) */ gtk_table_attach_defaults(GTK_TABLE(table), button, 0, 2, 0, 1); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;W&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;w&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 2, 4, 0, 1); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;E&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;e&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 4, 6, 0, 1); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;R&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;r&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 6, 8, 0, 1); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;T&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;t&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 8, 10, 0, 1); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;Y&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;y&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 10, 12, 0, 1); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;U&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;u&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 12, 14, 0, 1); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;I&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;i&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 14, 16, 0, 1); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;O&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;o&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 16, 18, 0, 1); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;P&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;p&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 18, 20, 0, 1); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;A&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;a&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 1, 3, 1, 2); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;S&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;s&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 3, 5, 1, 2); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;D&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;d&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 5, 7, 1, 2); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;F&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;f&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 7, 9, 1, 2); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;G&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;g&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 9, 11, 1, 2); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;H&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;h&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 11, 13, 1, 2); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;J&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;j&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 13, 15, 1, 2); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;K&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;k&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 15, 17, 1, 2); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;L&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;l&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 17, 19, 1, 2); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;'&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;'&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 0, 2, 2, 3); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;Z&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;z&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 2, 4, 2, 3); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;X&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;x&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 4, 6, 2, 3); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;C&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;c&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 6, 8, 2, 3); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;V&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;v&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 8, 10, 2, 3); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;B&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;b&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 10, 12, 2, 3); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;N&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;n&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 12, 14, 2, 3); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;M&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;m&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 14, 16, 2, 3); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;,&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;,&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 16, 18, 2, 3); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;.&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;.&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 18, 20, 2, 3); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot;Enter&quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot;\\n&quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 2, 6, 3, 4); gtk_widget_show(button); /*********************/ button = gtk_button_new_with_label(&quot; &quot;); g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(callback), (gpointer) &quot; &quot;); gtk_table_attach_defaults(GTK_TABLE(table), button, 6, 16, 3, 4); gtk_widget_show(button); /* 创建&quot;Quit&quot;按钮 */ button = gtk_button_new_with_label(&quot;Quit&quot;); /* 当这个按钮被点击时,我们调用 &quot;delete_event&quot; 函数接着程序就退出了 */ g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(delete_event), NULL); /* 将退出按钮插入表的下面两个象限 */ gtk_table_attach_defaults(GTK_TABLE(table), button, 16, 19, 3, 4); gtk_widget_show(button); gtk_widget_show(table); gtk_widget_show(window); gtk_main(); return 0;}//The code is copied by others","link":"/2019/12/08/GTK%E7%A7%BB%E6%A4%8D%E5%88%B0Windows%E5%B9%B3%E5%8F%B0/"},{"title":"English grammar  affix","text":"[TOC] 词缀（affix） 是一种附着在词根或词干的语素，为规范词素，不能单独成字。词缀可以是派生变化，如英语的*-ness* and pre-*，也可以是屈折变化，如英语的复数 *-s 和过去式*-ed。* 依位置分类根据词缀和词干结合位置的不同，可分为不同的词缀。前缀和后缀在语言中较常见，中缀和环缀较少见，因为他们在欧洲语言中并不重要。其他的词缀罕见。 词缀 范例 模式 描述 前缀/词头 prefix undo 反战 前缀-词干 出现在词干之前 后缀/词尾 suffix looking 吃了 词干-后缀 出现在词干之后 中缀/词嵌[1] infix saxomaphone 吃过饭 词干&lt;中缀&gt;词干 出现在词干之中，常见于婆罗洲-菲律宾语系 或南岛语系里。 环缀 circumfix ascattered 环缀&gt;词干&lt;环缀 一部分出现在词干前，另一部分出现在词干后 间缀 interfix speedometer 词干a-间缀-词干b 连结两个词干使成为复合字 复缀 duplifix moneyshmoney看一看 词干~复缀 复制一部分的词干，可出现在前、中、后的位置 插缀 transfix 马耳他语： kiteb （他写）、词根ktb（写） 一清二楚、三不五时、七零八落 词干&lt;插缀&gt;词干&lt;插缀&gt;词干 非连续性的词缀穿插在单一词干之中 屈折缀 simulfix mouse → mice 词干内部屈折变化 改变词干的一部分 变调缀 suprafix product（名词） produce（动词） 词干语音的声调或重音变化 改变音素的音韵性质 减缀 disfix 阿拉巴马语：tipli（打破） 词根tipasli（破） 词干一部分删减 一部分的词干省略 前缀和后缀统称为外缀(adfix)，与内缀(infix)相对。[2] 在相互对应注解（interlinear glossing）中，简单的词缀如外缀用-与词干分开；打断词干或不连续的词缀用&lt;&gt;表示；复缀用~标记；不能分开的词缀用\\。 依功能性分类不同语言各有不同的语法,使用词缀的方式也不尽相同,以下是英语与汉语的词缀用法 英语词缀（affix）根据语法功能、特性，可区分为： derivational affix[3]或中译为派生词缀：会造成词性以及语意变化，产生一个词性不同的新词。例如，“run”的词性是动词，在之后加上“er”变成“runner”，词性变为名词，意思也略有转变，“er”在此就是派生词缀。 inflectional affix或中译为曲/屈折词缀：只会改变一词的文法特性，并不改其语意。例如，在“run”之后加上“ing”成为“running”，表示进行中的概念(ing后亦有引申用来表示持续、未完成等等概念的用法)，“ing”在此就是曲折词缀。 汉语词缀根据语法功能、特性，可区分为： word-formation affix[4]或称为构词词缀、词变词缀：会造成词性以及语意变化，产生一个词性不同的新词。例如，“跑”的词性是动词，在之后加上“者”变成“跑者”，词性变为名词，意思也略有转变，“者”在此就是构词词缀。 Grammatical affix或称为语法词缀：只会改变一词的文法特性，并不改其语义。例如，在“跑”之后加上“著”成为“跑着”，表示持续进行的概念(“著”后来亦有引申用来表示状态持续存在等概念的用法)，“著”在此就是语法词缀。 变格变格（declension）在语言学上是指名词、代词、冠词、形容词在句子中为了实现特定的语法功能而产生的词形变化。动词的这种屈折变化一般被称作变位。 词通过变格能够反映自身的性（阴性、阳性、中性等）、数（单数、双数、复数等）、格（主格、宾格、与格、属格等）及其他语法范畴上的归属。 许多语言都存在变格。在印欧语系、班图语支、闪米特语族、芬兰-乌戈尔语族、突厥语族诸语言中，变格都是相当重要的一部分。 现代英语主条目：英语语法 现代英语的变格系统几近消失，仅保留了人称代词的部分性数格变化、名词的部分数格变化。 现代英语的名词大部分的格变化都已消失，仅属格（或称所有格）仍保留变格。亦即名词的宾格、与格等语义格与主格完全一致，没有屈折变化，共享一个语法格；仅名词的属格需要进行屈折变化。属格的变格由附着语素-‘s来表现。对于以s结尾的名词（如大多数名词的复数形式），其属格则只需附着语素*-‘*。 以“boy”（男孩）为例，下表展示了该名词的全部变格： 单数 复数 普通（主格、目的格等） boy boys 属格（所有格） boy**’s** boys’ 不过有些名词的复数形式稍显复杂。以“man”（人／男人）为例： 单数 复数 普通（主格、目的格等） man men 属格（所有格） man**’s** men**’s** 一般认为，名词的派生变化不属于变格。如名词“Britain”（不列颠）派生出形容词“British”（不列颠的）和区域居民称谓词“Briton”（不列颠人）。尽管这些词显然互相关联，属于同源词，但一般不被视作同一个词的形态变化，因此不属于变格。 人称代词变格现代英语的人称代词变格略为复杂，详见下表。 人称 性 数 主格 宾格、与格 属格限定词 属格代词 反身代词 第一人称 单数 I me my mine myself 第二人称 you your yours yourself 第三人称 阳性 he him his himself 阴性 she her hers herself 中性 it its itself 第一人称 复数 we us our ours ourselves 第二人称 you your yours yourselves 第三人称 they them their theirs themselves 名词的主格和宾格并无区别，但部分人称代词的主格和宾格并不相同。此外，疑问代词“who”（谁）也有不同的主格（“who”）、宾格（“whom”)、属格（“whose”）形态，不过主格和宾格均使用“who”已经越来越常见。 现代英语中唯一仍保留性变化的就是第三人称单数的人称代词。不过名词仍可以被赋予性别，只是不再是语法上必须的变格。外来词，尤其是来自拉丁语和其他罗曼语族语言的的借词，其变格通常会被保留。如“alumnus”（校友，阳性单数）和“alumna”（校友，阴性单数）。 形容词变格多数形容词无任何变格。不过当形容词用作名词时需要变格。比如，将“I’ll take the red wines”（我选红酒）省略作“I’ll take the reds”（我选红的）时，省略了“red wines”（红酒）中的名词“wines”（酒），以形容词“red”（红色的）临时充当名词，因此形容词“red”需临时承担名词“wine”的变格任务。因为“wine”采用了复数形式“wines”，所以省略后“red”亦须变格为“reds”以反映指代的是一个复数名词。 此外，指示限定词“this”（这个）和“that”（那个）有数的变化。其复数形式分别为“these”（这些）和“those”（那些）。 自其他语言借入的形容词也可能（亦或被允许）必须保留其性的变化。比如“blond”（金色的，阳性）、“blonde”（金色的，阴性）。 现代英语中形容词不根据主格、宾格等语法格进行变格，不过古英语中有此要求。 冠词变格现代英语中，冠词无需变格。不过正式而言，“that”（那个）和“she”（她）分别来自古英语冠词“sē”的中性变格“þæt”和阴性变格“sēo”。 语素语素（Morpheme）又称形态素、义基[1]，在语素构词学里指最小的语法单位，是最小的语音语义结合体。[2] 在口语中，语素是由音位这一种能区别的最小声音单位所组成的，而在文字形式语言中，语素则是由字位所组成的。因为汉语是一字一音，所以可按照音位的个数，区分成单音节语素、双音节语素、多音节语素和非音节语素。[2] 语素和词不同，有许多的语素不能够单独地构成词。依据是否可单独成词，语素可分为自由语素和规范语素（又称不自由语素）。[3] 以英语为例，unbreakable 这个词有三个语素：un-（规范语素）、break（自由语素）和 -able（自由语素）。","link":"/2021/04/08/English-words/"},{"title":"Git基础命令","text":"基本概念Git是一个开源的分布式版本控制系统,可以有效,高速的处理从小到非常大的项目 版本管理.不同于SVN. 工作区:文件夹中能看到的目录,不包括隐藏目录 暂存区:一般是存放在”.git目录下的”index文件.用git add的文件都会放在这里. 版本库:工作区下隐藏目录.git. .gitignore 文件是一个文本文件，通常位于 Git 仓库的根目录，用于指定要忽略的文件和目录的规则。可以使用 # 符号在文件中添加注释。 123456789101112# 忽略所有 .log 文件*.log # 忽略所有 .tmp 和 .bak 文件*.tmp*.bak # 忽略 build 目录及其内容/build/ # 但是不忽略 build/logs 目录!/build/logs/ 新建文件夹,git init 初始化目录,作用将一个已经存在的文件夹,置于Git的 控制管理之下. git add ,将创建或者修改的文件添加到本地的暂存区,保存临时更改. 123git add &lt;file&gt; # 将指定文件添加到暂存区git add &lt;directory&gt; # 将指定目录及其内容添加到暂存区git add . # 将当前目录下的所有更改添加到暂存区 git commit 提交文件到本地仓库.git commit -m &quot;注释&quot; git pull从远程存储库获取最新的更改并将它们合并到目前的分支。git pull 实际上包含了两个步骤：git fetch 和 git merge 或 git rebase,它用于更新本地分支以反映远程分支的最新状态。 1git pull origin main git push 将本地代码库同步到远端仓库. 1git push origin main git clone [url]克隆仓库到本地. git checkout 用于在不同的分支、提交和标签之间切换，以及在工作目录中还原文件的状态。 切换分支： 切换到已存在的本地分支：git checkout &lt;branch-name&gt; 创建并切换到新分支：git checkout -b &lt;new-branch-name&gt; 例如，要切换到一个名为 feature-branch 的分支，可以运行： 1git checkout feature-branch 要创建并切换到一个名为 new-feature 的新分支，可以运行： 1git checkout -b new-feature 切换到特定提交： 你可以使用 git checkout 切换到特定提交，这会使你进入分离头状态（detached HEAD），可以查看特定提交的文件状态。 1git checkout &lt;commit-hash&gt; 例如，要查看特定提交 abcd123 的文件状态，可以运行： 1git checkout abcd123 切换到标签（tags）： 你可以使用 git checkout 切换到一个标签（tags），这会将你的 HEAD 移动到标签所指向的特定提交，通常用于查看和测试特定版本。 1git checkout &lt;tag-name&gt; 例如，要切换到标签 v1.0，可以运行： 1git checkout v1.0 恢复单个文件： git checkout 还可以用于还原单个文件的状态。这在你不小心更改了某个文件，想要将其还原到最后一个提交状态时非常有用。 1git checkout -- &lt;file&gt; 例如，要还原名为 my-file.txt 的文件到最后一个提交状态，可以运行： 1git checkout -- my-file.txt git merge 将一个分支的更改合并到另一个分支中，通常将特性分支的更改合并到主分支（如 master 或 main）以更新项目的主要版本。 1git merge &lt;branch-name&gt; git remote add orgin 仓库链接将本地仓库连接到GitHub仓库 orign是这个仓库的小名,方便以后沟通,通常默认用orign表示 启用Vim编辑器:vim 文件名, 按i进入插入模式, 按ESC退出插入模式,再键入 :wq 回车,Vim就会保存文件并退出.","link":"/2020/02/25/Git%E6%9D%82%E8%AE%B0/"},{"title":"Google开发者模式","text":"1, Google F12 打开控制台界面,详情如图. Elements:页面元素,可以进行编辑,查看实时效果 Console:模拟JS控制台,可以在此处直接写代码(脚本文件),实现一些自动化任务 Sources:查看加载本页面所调用的资源 Network:查看js模拟的http请求可以实时的看到请求地址，点击请求地址，会把请求的头信息和响应信息等数据展示出来 Performance:性能分析 2,源码定位:右键点击检查,定位到指定元素的源码. 3, - console.log:用于输出普通信息 console.info:用于输出提示性信息 console.error:用于输出错误信息 console.warn:用于输出警示信息 console.debug:用于输出调试信息 console.group:输出一组信息的开头 console.groupEnd:结束一组输出信息 console.assert:对输入的表达式进行断言,表达式为False输出相应信息 console.count:统计它本身被调用的次数,接受一个参数作为标签,对不同函数执行次数进行分类,图示: console.dir():打印特定对象的详细信息.可以将DOM结点以DOM树的结构进行输出 console.time(),console.timeEnd:统计之间代码运行时间","link":"/2020/03/23/Google%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"title":"HTTP协议深度解析：从基础到现代演进","text":"概述HTTP（HyperText Transfer Protocol，超文本传输协议）是现代互联网架构的核心基石，作为应用层协议规范了客户端与服务器之间的通信标准。自1990年Tim Berners-Lee在CERN首次提出以来，HTTP协议经历了四个主要版本的演进：从极简的HTTP/0.9到革命性的HTTP/3，每次迭代都针对当时的性能瓶颈和新兴应用需求进行了深度优化。 协议演进概览： HTTP/0.9 (1991)：极简单行协议，仅支持GET方法 HTTP/1.0 (1996)：引入头部机制和状态码系统 HTTP/1.1 (1997)：持久连接和管道化，奠定现代Web基础 HTTP/2 (2015)：二进制分帧和多路复用，解决队头阻塞 HTTP/3 (2022)：基于QUIC的传输层革新，实现真正的流独立性 本文将深入剖析HTTP协议的技术演进脉络，详细解析各版本的核心机制与性能优化策略，并通过与RPC通信模式的对比分析，为现代Web架构设计提供全面的技术指导。 HTTP协议核心特征HTTP协议的设计哲学体现了互联网分布式系统的核心原则，具有以下关键技术特征： 无状态性（Stateless）HTTP采用无状态设计，服务器不维护客户端的会话状态信息。每个HTTP请求都是完全独立的事务单元，包含了处理该请求所需的全部上下文信息。 设计原理： 123请求1: GET /page1 → 服务器处理 → 响应1 (服务器忘记此交互)请求2: GET /page2 → 服务器处理 → 响应2 (独立处理，无历史记忆)请求3: POST /data → 服务器处理 → 响应3 (不依赖前序请求) 技术影响分析： 架构优势： 服务器实现简化，无需维护会话状态 水平扩展能力强，任意服务器可处理任意请求 故障恢复快速，服务器重启不影响客户端 负载均衡简单，无会话粘性要求 实现挑战： 用户认证状态需要每次传递 购物车等临时状态需要额外存储 个性化体验需要状态重建机制 解决方案演进： 123456789101112131415// 1. Cookie-based状态管理document.cookie = &quot;sessionId=abc123; path=/; secure; httpOnly&quot;;// 2. JWT令牌方案const token = jwt.sign( { userId: 123, role: 'user' }, secretKey, { expiresIn: '1h' });// 3. 现代状态管理const authHeader = `Bearer ${accessToken}`;fetch('/api/data', { headers: { 'Authorization': authHeader }}); 明文传输与安全性原始HTTP协议设计时采用明文传输机制，所有数据以ASCII文本形式在网络中传输，这在早期简单的学术网络环境中是可接受的，但随着商业应用的普及，安全问题日益突出。 安全风险分析： 12345网络传输路径：客户端 → 路由器 → ISP → 互联网 → 目标服务器风险点：任何中间节点都可以：- 窃听（Eavesdropping）：读取传输内容- 篡改（Tampering）：修改请求/响应数据- 伪装（Impersonation）：冒充服务器身份 HTTPS安全演进历程： 12345671994: SSL 1.0 (未公开发布)1995: SSL 2.0 → 存在严重安全漏洞1996: SSL 3.0 → 修复主要安全问题1999: TLS 1.0 → 标准化SSL 3.02006: TLS 1.1 → 防御CBC攻击2008: TLS 1.2 → 现代加密算法支持2018: TLS 1.3 → 简化握手，增强安全性 TLS 1.3关键改进： 1234567891011121314151617181920# TLS 1.3握手优化class TLS13Handshake: def __init__(self): self.supported_groups = ['x25519', 'secp256r1'] self.cipher_suites = [ 'TLS_AES_128_GCM_SHA256', 'TLS_AES_256_GCM_SHA384', 'TLS_CHACHA20_POLY1305_SHA256' ] def perform_handshake(self): # 1-RTT握手流程 client_hello = self.generate_client_hello() server_hello = self.process_server_hello() # 0-RTT恢复（可选） if self.has_psk(): return self.resume_with_psk() return self.complete_handshake() 请求-响应模式HTTP采用严格的请求-响应通信模式，遵循客户端主动发起、服务器被动响应的交互原则。这种单向通信模式保证了协议的简单性和可靠性，但也限制了实时双向通信的能力。 标准通信流程： 1234567891011121314阶段1: 连接建立客户端 → TCP SYN → 服务器客户端 ← TCP SYN-ACK ← 服务器 客户端 → TCP ACK → 服务器阶段2: HTTP事务客户端 → HTTP请求 → 服务器 (方法 + URI + 头部 + 体)客户端 ← HTTP响应 ← 服务器 (状态码 + 头部 + 体)阶段3: 连接管理- HTTP/1.0: 立即关闭连接- HTTP/1.1+: 可选择保持连接(keep-alive) 模式限制与解决方案： 限制 影响 解决方案 单向通信 服务器无法主动推送 WebSocket, SSE, HTTP/2 Push 同步阻塞 客户端等待响应 异步请求, Promise/async-await 无状态性 无法维持会话 Cookie, Session, JWT 文本协议 解析开销大 HTTP/2二进制分帧 现代扩展技术： 12345678910111213141516171819// 1. Server-Sent Events (单向推送)const eventSource = new EventSource('/api/events');eventSource.onmessage = function(event) { console.log('服务器推送:', event.data);};// 2. WebSocket (双向通信)const ws = new WebSocket('wss://example.com/socket');ws.onopen = () =&gt; ws.send('Hello Server');ws.onmessage = (event) =&gt; console.log('收到:', event.data);// 3. HTTP/2 Server Push (资源预推送)// 服务器端配置app.get('/index.html', (req, res) =&gt; { // 推送关键资源 res.push('/css/style.css'); res.push('/js/app.js'); res.sendFile('index.html');}); HTTP协议演进历程HTTP/0.9：极简起点（1991年）HTTP/0.9是最初的协议版本，设计极其简单： 技术特征： 仅支持GET方法 无HTTP头部信息 仅传输HTML文档 每次请求建立新的TCP连接 无状态码概念 请求示例： 1GET /path/index.html&lt;CR&gt;&lt;LF&gt; 局限性：功能过于简单，无法满足复杂Web应用需求。 HTTP/1.0：功能扩展（1996年）HTTP/1.0引入了现代HTTP的基础概念： 核心改进： 多种请求方法：GET、POST、HEAD HTTP头部机制：支持元数据传输 状态码系统：标准化响应状态 多媒体支持：通过MIME类型支持各种文件格式 版本标识：请求中包含协议版本 请求格式： 1234GET /index.html HTTP/1.0Host: www.example.comUser-Agent: Mozilla/5.0Accept: text/html 技术限制： 每个请求需要新的TCP连接 连接开销大，性能受限 无法复用连接资源 HTTP/1.1：性能优化（1997年）HTTP/1.1是使用最广泛的版本，引入了多项关键优化： 持久连接（Persistent Connections）技术原理： 默认启用Connection: keep-alive 单个TCP连接可处理多个HTTP请求 显著减少连接建立开销 性能提升： 12传统模式：每请求建立连接 → 3次握手开销 × N持久连接：复用连接 → 3次握手开销 × 1 管道化（Pipelining）实现机制： 客户端可连续发送多个请求 无需等待前一个响应 服务器按顺序返回响应 代码示例： 123456789# 管道化请求GET /resource1 HTTP/1.1GET /resource2 HTTP/1.1GET /resource3 HTTP/1.1# 顺序响应HTTP/1.1 200 OK (resource1)HTTP/1.1 200 OK (resource2)HTTP/1.1 200 OK (resource3) 分块传输编码（Chunked Transfer Encoding）应用场景： 动态生成内容 大文件传输 流式数据处理 编码格式： 123456789HTTP/1.1 200 OKTransfer-Encoding: chunked7\\r\\nMozilla\\r\\n9\\r\\nDeveloper\\r\\n0\\r\\n\\r\\n 缓存控制机制Cache-Control指令： 1234# 缓存策略示例Cache-Control: max-age=3600, publicCache-Control: no-cache, must-revalidateCache-Control: private, max-age=0 ETag验证： 12345678# 服务器响应ETag: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;# 客户端条件请求If-None-Match: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;# 304响应（未修改）HTTP/1.1 304 Not Modified 强制Host头部技术意义： 支持虚拟主机 单IP多域名部署 提高服务器资源利用率 配置示例： 12GET /index.html HTTP/1.1Host: www.example.com 方法扩展新增方法： PUT：资源更新/创建 DELETE：资源删除 OPTIONS：查询支持的方法 TRACE：请求路径追踪 HTTP/1.1的性能瓶颈尽管HTTP/1.1带来了显著改进，但仍存在性能限制： 队头阻塞（Head-of-Line Blocking）HTTP/1.1的管道化机制虽然允许客户端连续发送多个请求，但服务器必须按照请求的发送顺序返回响应，这导致了应用层的队头阻塞问题。 技术原理分析： 123456789101112131415161718管道化请求序列:时间轴: 0ms 50ms 100ms 150ms 200ms请求: REQ1 REQ2 REQ3 REQ4 REQ5 (快) (慢) (快) (快) (快)理想响应时间:REQ1: 100msREQ2: 2000ms ← 慢请求REQ3: 100msREQ4: 100msREQ5: 100ms实际响应序列（必须按序）:RESP1: 100ms ✓ 正常返回RESP2: 2000ms ✗ 阻塞点RESP3: 2100ms ✗ 被阻塞 (本应100ms)RESP4: 2200ms ✗ 被阻塞 (本应100ms)RESP5: 2300ms ✗ 被阻塞 (本应100ms) 性能影响量化： 12345678910111213141516171819202122232425262728class HOLBlockingAnalysis: def calculate_impact(self, requests): # 无阻塞理想情况 ideal_time = max(req.processing_time for req in requests) # 队头阻塞实际情况 actual_time = 0 for req in requests: actual_time += req.processing_time # 性能损失 performance_loss = (actual_time - ideal_time) / ideal_time return { 'ideal_completion': ideal_time, 'actual_completion': actual_time, 'performance_degradation': f'{performance_loss:.1%}' }# 示例计算requests = [ Request(processing_time=100), # 快请求 Request(processing_time=2000), # 慢请求 Request(processing_time=100), # 快请求 Request(processing_time=100), # 快请求]result = HOLBlockingAnalysis().calculate_impact(requests)# 输出: {'ideal_completion': 2000ms, 'actual_completion': 2300ms, 'performance_degradation': '15.0%'} 缓解策略： 1234567891011121314151617181920212223242526272829303132333435// 1. 域名分片 (Domain Sharding)const domains = [ 'static1.example.com', 'static2.example.com', 'static3.example.com', 'static4.example.com'];function loadResource(url, index) { const domain = domains[index % domains.length]; return fetch(`https://${domain}${url}`);}// 2. 资源优先级管理class ResourceLoader { constructor() { this.highPriority = []; this.lowPriority = []; } addResource(url, priority = 'normal') { if (priority === 'high') { this.highPriority.push(url); } else { this.lowPriority.push(url); } } async loadAll() { // 优先加载高优先级资源 await Promise.all(this.highPriority.map(url =&gt; fetch(url))); // 然后加载低优先级资源 await Promise.all(this.lowPriority.map(url =&gt; fetch(url))); }} 头部冗余问题表现： 每个请求重复发送相同头部 增加带宽消耗 特别影响移动网络 数据示例： 12345# 重复的头部信息User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)...Accept: text/html,application/xhtml+xml,application/xml...Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8...Accept-Encoding: gzip, deflate, br HTTP/2：二进制革命（2015年）HTTP/2基于Google的SPDY协议，实现了协议层面的重大革新： 设计理念核心目标： 保持HTTP/1.1语义兼容性 显著提升传输性能 减少延迟，提高吞吐量 优化移动网络体验 二进制分帧层（Binary Framing Layer）架构变革： 12HTTP/1.1: 文本协议 → TCPHTTP/2: 应用层 → 二进制分帧层 → TCP 帧结构设计帧格式： 123456789+-----------------------------------------------+| Length (24) |+---------------+---------------+---------------+| Type (8) | Flags (8) |+-+-------------+---------------+-------------------------------+|R| Stream Identifier (31) |+=+=============================================================+| Frame Payload (0...) ...+---------------------------------------------------------------+ 关键字段： Length：帧负载长度（最大16MB） Type：帧类型标识 Flags：帧特定标志 Stream Identifier：流标识符 核心帧类型DATA帧： 1234567+---------------+|Pad Length? (8)|+---------------+-----------------------------------------------+| Data (*) ...+---------------------------------------------------------------+| Padding (*) ...+---------------------------------------------------------------+ HEADERS帧： 1234567891011+---------------+|Pad Length? (8)|+-+-------------+-----------------------------------------------+|E| Stream Dependency? (31) |+-+-------------+-----------------------------------------------+| Weight? (8) |+-+-------------+-----------------------------------------------+| Header Block Fragment (*) ...+---------------------------------------------------------------+| Padding (*) ...+---------------------------------------------------------------+ SETTINGS帧： 12345+-------------------------------+| Identifier (16) |+-------------------------------+-------------------------------+| Value (32) |+---------------------------------------------------------------+ 多路复用（Multiplexing）流（Stream）概念技术定义： 流是HTTP/2连接中的独立双向通信通道 每个流有唯一标识符 多个流可并发传输 流状态机： 12345678910111213141516171819202122232425262728 +--------+ send PP | | recv PP ,--------| idle |--------. / | | \\ v +--------+ v +----------+ | +----------+ | | | send H / | |,------| reserved | | recv H | reserved |------.| | (local) | | | (remote) | || +----------+ v +----------+ || | +--------+ | || | recv ES | | send ES | || send H | ,-------| open |-------. | recv H || | / | | \\ | || v v +--------+ v v || +----------+ | +----------+ || | half | | | half | || | closed | | send R / | closed | || | (remote) | | recv R | (local) | || +----------+ | +----------+ || | | | || | send ES / | recv ES / | || | send R / v send R / | || | recv R +--------+ recv R | || send R / `-----------&gt;| |&lt;-----------' send R / || recv R | closed | recv R |`-----------------------&gt;| |&lt;----------------------' +--------+ 并发传输机制HTTP/2的多路复用通过在单个TCP连接上创建多个独立的逻辑流来实现真正的并发传输，彻底解决了HTTP/1.1的队头阻塞问题。 核心实现原理： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788class HTTP2Connection: def __init__(self): self.streams = {} # 活跃流字典 self.next_stream_id = 1 # 客户端流ID从1开始 self.connection_window = 65535 # 连接级流量控制窗口 self.max_concurrent_streams = 100 # 最大并发流数 def create_stream(self, headers, data=None, priority=None): # 检查并发流限制 if len(self.streams) &gt;= self.max_concurrent_streams: raise StreamLimitExceeded(&quot;达到最大并发流限制&quot;) stream_id = self.next_stream_id self.next_stream_id += 2 # 客户端使用奇数ID # 创建流对象 stream = HTTP2Stream( stream_id=stream_id, state='idle', priority=priority or StreamPriority(weight=16) ) self.streams[stream_id] = stream # 发送HEADERS帧 headers_frame = HeadersFrame( stream_id=stream_id, headers=headers, end_headers=True, end_stream=(data is None) ) self.send_frame(headers_frame) stream.state = 'open' # 发送DATA帧（如果有数据） if data: data_frame = DataFrame( stream_id=stream_id, data=data, end_stream=True ) self.send_frame(data_frame) stream.state = 'half_closed_local' return stream_id def handle_concurrent_requests(self, requests): &quot;&quot;&quot;并发处理多个请求&quot;&quot;&quot; stream_mapping = {} # 批量创建流 for i, req in enumerate(requests): try: # 设置优先级（重要资源优先） priority = self.calculate_priority(req) stream_id = self.create_stream( headers=req.headers, data=req.data, priority=priority ) stream_mapping[stream_id] = req except StreamLimitExceeded: # 达到限制时排队等待 self.queue_request(req) return stream_mapping def calculate_priority(self, request): &quot;&quot;&quot;根据资源类型计算优先级&quot;&quot;&quot; resource_priorities = { 'text/html': StreamPriority(weight=256, exclusive=True), 'text/css': StreamPriority(weight=220), 'application/javascript': StreamPriority(weight=200), 'image/': StreamPriority(weight=100), 'font/': StreamPriority(weight=80) } content_type = request.headers.get('accept', '') for mime_type, priority in resource_priorities.items(): if mime_type in content_type: return priority return StreamPriority(weight=16) # 默认优先级class StreamPriority: def __init__(self, weight=16, exclusive=False, dependency=0): self.weight = weight # 权重 (1-256) self.exclusive = exclusive # 是否独占依赖 self.dependency = dependency # 依赖的流ID 流状态管理： 123456789101112131415161718192021222324252627282930class HTTP2Stream: def __init__(self, stream_id, state='idle', priority=None): self.stream_id = stream_id self.state = state self.priority = priority self.window_size = 65535 # 流级流量控制窗口 self.headers_received = [] self.data_received = b'' def transition_state(self, event, frame_type=None): &quot;&quot;&quot;状态机转换&quot;&quot;&quot; transitions = { ('idle', 'send_headers'): 'open', ('idle', 'recv_headers'): 'open', ('open', 'send_end_stream'): 'half_closed_local', ('open', 'recv_end_stream'): 'half_closed_remote', ('half_closed_local', 'recv_end_stream'): 'closed', ('half_closed_remote', 'send_end_stream'): 'closed' } key = (self.state, event) if key in transitions: old_state = self.state self.state = transitions[key] self.on_state_change(old_state, self.state) def on_state_change(self, old_state, new_state): &quot;&quot;&quot;状态变化回调&quot;&quot;&quot; if new_state == 'closed': self.cleanup_resources() 性能优势延迟对比： 123456789101112HTTP/1.1 (6个并发连接):请求1: 0ms → 响应: 100ms请求2: 0ms → 响应: 100ms请求3: 0ms → 响应: 100ms请求4: 100ms → 响应: 200ms请求5: 100ms → 响应: 200ms请求6: 100ms → 响应: 200ms总时间: 200msHTTP/2 (单连接多路复用):请求1-6: 0ms → 响应: 100ms总时间: 100ms 流量控制控制机制： 基于信用的流量控制 连接级和流级双重控制 防止快速发送方压垮接收方 WINDOW_UPDATE帧： 123+-+-------------------------------------------------------------+|R| Window Size Increment (31) |+-+-------------------------------------------------------------+ 流量控制算法： 1234567891011121314class FlowControl: def __init__(self, initial_window_size=65535): self.window_size = initial_window_size self.consumed = 0 def can_send(self, data_size): return data_size &lt;= self.window_size def consume_window(self, data_size): self.window_size -= data_size self.consumed += data_size def update_window(self, increment): self.window_size += increment HPACK头部压缩压缩原理技术组件： 静态表：预定义的常用头部字段 动态表：连接期间构建的头部缓存 霍夫曼编码：字符串压缩算法 静态表示例1234567891011121314+-------+-----------------------------+---------------+| Index | Header Name | Header Value |+-------+-----------------------------+---------------+| 1 | :authority | || 2 | :method | GET || 3 | :method | POST || 4 | :path | / || 5 | :path | /index.html || 6 | :scheme | http || 7 | :scheme | https || 8 | :status | 200 || 9 | :status | 204 || 10 | :status | 206 |+-------+-----------------------------+---------------+ 动态表机制工作流程： 12345678910111213141516171819202122232425class DynamicTable: def __init__(self, max_size=4096): self.entries = [] self.max_size = max_size self.current_size = 0 def add_entry(self, name, value): entry = (name, value) entry_size = len(name) + len(value) + 32 # RFC 7541 # 驱逐旧条目 while self.current_size + entry_size &gt; self.max_size: if not self.entries: break removed = self.entries.pop() self.current_size -= len(removed[0]) + len(removed[1]) + 32 # 添加新条目 self.entries.insert(0, entry) self.current_size += entry_size def get_entry(self, index): if 1 &lt;= index &lt;= len(self.entries): return self.entries[index - 1] return None 霍夫曼编码编码表（部分）： 12345678910+------+----------+----------+| sym | code | len |+------+----------+----------+| '0' | 00110000 | 8 || '1' | 00110001 | 8 || '2' | 00110010 | 8 || 'A' | 01000001 | 8 || 'a' | 01100001 | 8 || ' ' | 010100 | 6 |+------+----------+----------+ 压缩效果压缩示例： 1234567891011121314原始头部 (HTTP/1.1):GET /index.html HTTP/1.1Host: www.example.comUser-Agent: Mozilla/5.0...Accept: text/html,application/xhtml+xml...Accept-Language: en-US,en;q=0.9...Accept-Encoding: gzip, deflate, brConnection: keep-alive总大小: ~800字节HPACK压缩后 (HTTP/2):索引引用 + 霍夫曼编码总大小: ~200字节压缩率: 75% 服务器推送（Server Push）实现机制PUSH_PROMISE帧： 123456789+---------------+|Pad Length? (8)|+-+-------------+-----------------------------------------------+|R| Promised Stream ID (31) |+-+---------------------------------------------------------------|+| Header Block Fragment (*) ...+---------------------------------------------------------------+| Padding (*) ...+---------------------------------------------------------------+ 推送流程12345678910111213141516171819class ServerPush: def handle_request(self, stream_id, request): # 处理主请求 response = self.process_request(request) # 分析需要推送的资源 push_resources = self.analyze_push_candidates(request) for resource in push_resources: # 发送PUSH_PROMISE promised_stream_id = self.next_stream_id self.send_push_promise(stream_id, promised_stream_id, resource.headers) # 推送资源 resource_data = self.load_resource(resource.path) self.send_response(promised_stream_id, resource_data) # 发送主响应 self.send_response(stream_id, response) 缓存挑战问题分析： 客户端可能已缓存推送资源 推送可能浪费带宽 需要智能推送策略 解决方案： 123456789101112131415161718192021222324252627// 客户端推送缓存管理class PushCache { constructor() { this.cache = new Map(); } onPushPromise(streamId, headers) { const url = this.extractUrl(headers); // 检查是否已缓存 if (this.cache.has(url)) { // 发送RST_STREAM取消推送 this.sendRstStream(streamId, 'CANCEL'); return; } // 接受推送 this.pendingPushes.set(streamId, url); } onPushData(streamId, data) { const url = this.pendingPushes.get(streamId); if (url) { this.cache.set(url, data); } }} HTTP/2性能评估延迟优化测试场景：100个小资源请求 12345678910HTTP/1.1 (6连接):- 连接建立: 6 × 100ms = 600ms- 请求处理: 17轮 × 50ms = 850ms- 总延迟: 1450msHTTP/2 (1连接):- 连接建立: 1 × 100ms = 100ms- 并发处理: 1轮 × 50ms = 50ms- 总延迟: 150ms- 性能提升: 90% 带宽利用率头部压缩效果： 12345678910测试条件: 1000个请求，典型Web应用头部HTTP/1.1:- 平均头部大小: 800字节- 总头部开销: 800KBHTTP/2 (HPACK):- 压缩后头部: 200字节- 总头部开销: 200KB- 带宽节省: 75% 服务器资源优化连接数对比： 12345678910HTTP/1.1:- 每客户端连接数: 6-8个- 1000用户: 6000-8000连接- 内存消耗: ~2GBHTTP/2:- 每客户端连接数: 1个- 1000用户: 1000连接- 内存消耗: ~300MB- 资源节省: 85% HTTP/2部署挑战TLS要求技术要求： 虽然RFC未强制，但主流浏览器仅支持基于TLS的HTTP/2 需要TLS 1.2+和ALPN扩展 增加了部署复杂度 配置示例（Nginx）： 12345678910111213server { listen 443 ssl http2; ssl_certificate /path/to/cert.pem; ssl_certificate_key /path/to/key.pem; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384; # HTTP/2推送配置 location / { http2_push /css/style.css; http2_push /js/app.js; }} TCP层限制队头阻塞问题： HTTP/2解决了应用层队头阻塞 TCP层队头阻塞仍然存在 丢包影响整个连接 问题示例： 1234567TCP数据包序列: [1][2][3][4][5]丢包情况: [1][X][3][4][5]影响:- 包2丢失阻塞包3-5的处理- 所有HTTP/2流都受影响- 需要等待重传 中间件兼容性挑战领域： 代理服务器升级 负载均衡器支持 防火墙规则调整 监控工具适配 HTTP/3：QUIC革命（2022年）HTTP/3代表了Web协议的又一次重大革新，通过采用QUIC传输协议解决了TCP的固有限制。 设计动机TCP的根本限制连接建立延迟： 12345678910TCP + TLS握手:客户端 → SYN → 服务器客户端 ← SYN-ACK ← 服务器客户端 → ACK → 服务器客户端 → ClientHello → 服务器客户端 ← ServerHello ← 服务器客户端 → Finished → 服务器客户端 ← Finished ← 服务器总RTT: 3-4个往返 队头阻塞： 1234TCP字节流特性:应用数据: [HTTP请求1][HTTP请求2][HTTP请求3]TCP视角: 连续字节流，必须按序交付丢包影响: 任何包丢失都阻塞后续数据 QUIC的解决方案核心创新： 基于UDP构建可靠传输 内置TLS 1.3加密 连接级多路复用 0-RTT连接恢复 QUIC核心机制连接建立优化1-RTT连接建立： 12345客户端 → Initial包(ClientHello) → 服务器客户端 ← Handshake包(ServerHello + 证书) ← 服务器客户端 → Handshake包(Finished) → 服务器总RTT: 1个往返 0-RTT连接恢复： 1234567891011121314151617181920class QUICConnection: def __init__(self): self.session_ticket = None self.early_data_key = None def establish_0rtt_connection(self, server_config): if self.session_ticket and self.early_data_key: # 使用缓存的会话票据 early_data = self.encrypt_early_data(self.early_data_key) # 立即发送应用数据 packet = QUICPacket( type='0-RTT', connection_id=self.connection_id, payload=early_data ) return packet return None 流独立性QUIC流设计： 123456789QUIC连接├── 流1: [帧1][帧2][帧3]├── 流2: [帧1][帧2]└── 流3: [帧1][帧2][帧3][帧4]特性:- 每个流独立排序- 流间无阻塞依赖- 丢包仅影响对应流 流类型分类： 流类型 方向性 用途 示例 客户端双向流 双向 HTTP请求/响应 0, 4, 8, 12… 服务器双向流 双向 服务器推送 1, 5, 9, 13… 客户端单向流 单向 控制信息 2, 6, 10, 14… 服务器单向流 单向 控制信息 3, 7, 11, 15… 流量控制多级流量控制： 1234567891011121314151617181920212223242526class QUICFlowControl: def __init__(self): self.connection_window = 1048576 # 1MB self.stream_windows = {} # 每流窗口 def can_send_data(self, stream_id, data_size): # 检查连接级窗口 if data_size &gt; self.connection_window: return False # 检查流级窗口 stream_window = self.stream_windows.get(stream_id, 65536) if data_size &gt; stream_window: return False return True def consume_window(self, stream_id, data_size): self.connection_window -= data_size self.stream_windows[stream_id] -= data_size def update_window(self, stream_id, increment): if stream_id == 0: # 连接级更新 self.connection_window += increment else: # 流级更新 self.stream_windows[stream_id] += increment 连接迁移Connection ID机制设计原理： 连接由Connection ID标识，而非IP+端口 支持网络切换时的连接保持 特别适用于移动设备 实现示例： 1234567891011121314151617181920class ConnectionMigration: def __init__(self): self.connection_ids = [] self.current_path = None self.backup_paths = [] def handle_network_change(self, new_path): # 验证新路径 if self.validate_path(new_path): # 更新当前路径 self.backup_paths.append(self.current_path) self.current_path = new_path # 发送路径验证帧 self.send_path_challenge(new_path) def validate_path(self, path): challenge = self.generate_challenge() response = self.send_path_challenge(path, challenge) return self.verify_challenge_response(challenge, response) 路径验证验证流程： 123451. 客户端检测到网络变化2. 发送PATH_CHALLENGE帧到新路径3. 服务器在新路径返回PATH_RESPONSE帧4. 验证成功后切换到新路径5. 旧路径保持一段时间作为备份 帧格式： 123456789PATH_CHALLENGE帧:+------+------+------+------+------+------+------+------+| Challenge Data (64) |+------+------+------+------+------+------+------+------+PATH_RESPONSE帧:+------+------+------+------+------+------+------+------+| Challenge Data (64) |+------+------+------+------+------+------+------+------+ 传输层安全增强全程加密加密范围： 1234567891011QUIC数据包结构:+----------+------------------+| 明文头部 | 加密负载 |+----------+------------------+ ↑ 仅包含路由必需信息加密内容:- 所有帧数据- 大部分头部字段- 连接状态信息 TLS 1.3集成集成优势： 减少握手往返 统一密钥管理 前向安全保证 0-RTT数据保护 密钥派生： 123456789101112131415161718192021222324252627class QUICCrypto: def derive_keys(self, master_secret, connection_id): # 派生初始密钥 initial_secret = self.hkdf_extract(connection_id) # 派生各阶段密钥 keys = { 'initial': self.derive_initial_keys(initial_secret), 'handshake': self.derive_handshake_keys(master_secret), 'application': self.derive_app_keys(master_secret) } return keys def encrypt_packet(self, packet, keys, packet_number): # 构造AAD (Additional Authenticated Data) aad = self.build_aad(packet.header, packet_number) # 加密负载 ciphertext = self.aead_encrypt( key=keys['key'], nonce=self.build_nonce(keys['iv'], packet_number), plaintext=packet.payload, aad=aad ) return ciphertext 拥塞控制算法BBR算法核心思想： 基于带宽和RTT的拥塞控制 主动探测网络容量 避免传统算法的缓冲区膨胀 算法实现： 1234567891011121314151617181920212223242526272829303132333435class BBRCongestionControl: def __init__(self): self.max_bandwidth = 0 self.min_rtt = float('inf') self.pacing_rate = 0 self.cwnd = 10 # 初始拥塞窗口 # BBR状态 self.state = 'STARTUP' self.probe_bandwidth_cycles = 0 def on_ack_received(self, acked_bytes, rtt): # 更新带宽估计 self.update_bandwidth(acked_bytes, rtt) # 更新最小RTT self.min_rtt = min(self.min_rtt, rtt) # 状态机转换 self.update_state() # 更新发送速率 self.update_pacing_rate() def update_bandwidth(self, acked_bytes, rtt): bandwidth = acked_bytes / rtt self.max_bandwidth = max(self.max_bandwidth, bandwidth) def update_pacing_rate(self): if self.state == 'STARTUP': self.pacing_rate = 2.0 * self.max_bandwidth elif self.state == 'DRAIN': self.pacing_rate = self.max_bandwidth / 2.77 else: # PROBE_BW or PROBE_RTT self.pacing_rate = self.max_bandwidth CUBIC算法算法特点： 立方函数增长 适合高带宽长延迟网络 TCP友好性 1234567891011121314151617181920212223242526272829class CUBICCongestionControl: def __init__(self): self.cwnd = 10 self.ssthresh = 65535 self.beta = 0.7 # 乘性减少因子 self.c = 0.4 # CUBIC参数 self.w_max = 0 # 上次丢包前的窗口大小 self.t_start = 0 # 进入拥塞避免的时间 def on_congestion_event(self): self.w_max = self.cwnd self.cwnd = self.cwnd * self.beta self.ssthresh = self.cwnd self.t_start = time.time() def on_ack_received(self): if self.cwnd &lt; self.ssthresh: # 慢启动阶段 self.cwnd += 1 else: # 拥塞避免阶段 - CUBIC增长 t = time.time() - self.t_start k = (self.w_max * (1 - self.beta) / self.c) ** (1/3) w_cubic = self.c * (t - k) ** 3 + self.w_max if w_cubic &gt; self.cwnd: self.cwnd = w_cubic QPACK头部压缩设计改进相比HPACK的优势： 解决队头阻塞问题 支持乱序头部块 动态表更新与数据传输解耦 架构设计： 123456789QPACK组件:├── 编码器流 (Encoder Stream)├── 解码器流 (Decoder Stream) └── 头部块 (Header Blocks)数据流向:编码器 → 编码器流 → 动态表更新编码器 → 头部块 → 压缩头部数据解码器 → 解码器流 → 确认/取消指令 实现机制1234567891011121314151617181920212223242526272829303132333435363738class QPACKEncoder: def __init__(self): self.static_table = self.load_static_table() self.dynamic_table = DynamicTable() self.encoder_stream = EncoderStream() self.max_blocked_streams = 100 self.blocked_streams = set() def encode_headers(self, headers, stream_id): encoded_headers = [] for name, value in headers: # 查找静态表 static_index = self.find_in_static_table(name, value) if static_index: encoded_headers.append(('indexed', static_index)) continue # 查找动态表 dynamic_index = self.find_in_dynamic_table(name, value) if dynamic_index: # 检查是否会导致阻塞 if self.would_block(dynamic_index, stream_id): # 使用字面量编码 encoded_headers.append(('literal', name, value)) else: encoded_headers.append(('dynamic', dynamic_index)) continue # 决定是否添加到动态表 if self.should_add_to_dynamic_table(name, value): self.add_to_dynamic_table(name, value) self.encoder_stream.send_insert_instruction(name, value) encoded_headers.append(('literal', name, value)) return self.serialize_headers(encoded_headers) 服务器推送优化推送机制改进HTTP/3推送特点： 基于QUIC流的独立推送 更细粒度的推送控制 减少推送取消的开销 推送流程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class HTTP3ServerPush: def __init__(self): self.push_streams = {} self.push_id_counter = 0 def initiate_push(self, request_stream_id, push_url, push_headers): # 分配推送ID push_id = self.push_id_counter self.push_id_counter += 1 # 创建推送流 push_stream_id = self.allocate_stream_id() # 发送PUSH_PROMISE帧 push_promise = { 'type': 'PUSH_PROMISE', 'stream_id': request_stream_id, 'push_id': push_id, 'headers': push_headers } self.send_frame(push_promise) # 在推送流上发送响应 self.send_push_response(push_stream_id, push_id, push_url) def send_push_response(self, stream_id, push_id, url): # 加载推送资源 resource = self.load_resource(url) # 发送响应头部 headers_frame = { 'type': 'HEADERS', 'stream_id': stream_id, 'headers': resource.headers } self.send_frame(headers_frame) # 发送响应数据 data_frame = { 'type': 'DATA', 'stream_id': stream_id, 'data': resource.data, 'end_stream': True } self.send_frame(data_frame) HTTP/3交互示例完整请求流程123456789101112131415161718192021221. QUIC连接建立 (1-RTT)客户端 → Initial[ClientHello] → 服务器客户端 ← Handshake[ServerHello+Cert] ← 服务器客户端 → Handshake[Finished] → 服务器2. HTTP/3设置交换客户端 → SETTINGS[max_table_capacity=4096] → 服务器客户端 ← SETTINGS[max_blocked_streams=100] ← 服务器3. 并发HTTP请求流4: GET /index.html流8: GET /style.css 流12: GET /script.js4. 服务器推送服务器 → PUSH_PROMISE[push_id=0, /logo.png] → 客户端服务器 → 推送流16: 200 OK + logo.png数据5. 响应返回流4: 200 OK + HTML内容流8: 200 OK + CSS内容流12: 200 OK + JS内容 HTTP/3性能分析高丢包环境测试条件：1%丢包率，100ms RTT 12345678910HTTP/2 (TCP):- 丢包影响整个连接- 所有流等待重传- 平均延迟: 800msHTTP/3 (QUIC):- 丢包仅影响对应流- 其他流正常传输- 平均延迟: 150ms- 性能提升: 81% 高延迟网络测试条件：卫星网络，600ms RTT 123456789101112131415HTTP/1.1:- 连接建立: 3 RTT = 1800ms- 请求处理: 串行等待- 总延迟: 4200msHTTP/2:- 连接建立: 3 RTT = 1800ms- 并发处理: 1 RTT = 600ms- 总延迟: 2400msHTTP/3:- 连接建立: 1 RTT = 600ms- 并发处理: 1 RTT = 600ms- 总延迟: 1200ms- 性能提升: 50% 移动网络切换场景：WiFi到4G网络切换 12345678910111213HTTP/2:1. 检测网络变化2. TCP连接断开3. 重新建立连接 (3 RTT)4. 重新发送请求总中断时间: 2-5秒HTTP/3:1. 检测网络变化2. 发送PATH_CHALLENGE3. 接收PATH_RESPONSE4. 切换到新路径总中断时间: 100-200ms HTTP/3部署挑战网络基础设施兼容性UDP支持问题： 部分企业防火墙阻止UDP流量 中间件对UDP支持不完善 NAT设备UDP会话超时较短 解决策略： 123456789101112131415161718192021222324class HTTP3Fallback: def __init__(self): self.protocols = ['h3', 'h2', 'http/1.1'] self.connection_attempts = {} def connect(self, host, port): for protocol in self.protocols: try: if protocol == 'h3': return self.connect_quic(host, port) elif protocol == 'h2': return self.connect_http2(host, port) else: return self.connect_http1(host, port) except ConnectionError: continue raise ConnectionError(&quot;All protocols failed&quot;) def connect_quic(self, host, port): # 尝试QUIC连接 connection = QUICConnection() connection.connect(host, port + 443) # QUIC通常使用443端口 return connection 计算资源开销加密开销： 每个数据包都需要加密/解密 CPU使用率增加15-25% 需要硬件加速支持 内存使用： 12345678910111213141516class ResourceMonitoring: def measure_memory_usage(self): return { 'http1': { 'per_connection': '8KB', 'total_1000_users': '8MB' }, 'http2': { 'per_connection': '32KB', 'total_1000_users': '32MB' }, 'http3': { 'per_connection': '64KB', # QUIC状态开销 'total_1000_users': '64MB' } } 网络可观测性监控挑战： 传统网络工具无法解析QUIC 需要应用层监控 调试复杂度增加 监控方案： 1234567891011121314151617181920212223class QUICMonitoring: def __init__(self): self.metrics = { 'connection_establishment_time': [], 'stream_creation_rate': [], 'packet_loss_rate': [], 'migration_events': [], 'crypto_overhead': [] } def log_connection_event(self, event_type, details): timestamp = time.time() if event_type == 'connection_established': rtt = details['handshake_time'] self.metrics['connection_establishment_time'].append(rtt) elif event_type == 'packet_lost': loss_rate = details['loss_rate'] self.metrics['packet_loss_rate'].append(loss_rate) # 导出到监控系统 self.export_metrics() HTTP与RPC深度对比设计哲学差异资源导向 vs 行为导向HTTP/REST设计理念： 将系统建模为资源集合 通过统一接口操作资源 强调资源状态的表述性传输 示例对比： 123456# HTTP/REST风格GET /users/123 # 获取用户信息PUT /users/123 # 更新用户信息DELETE /users/123 # 删除用户POST /users/123/orders # 创建订单GET /users/123/orders/456 # 获取特定订单 RPC设计理念： 将系统建模为服务和方法 直接调用远程过程 强调行为和操作的执行 12345678// gRPC服务定义service UserService { rpc GetUser(GetUserRequest) returns (User); rpc UpdateUser(UpdateUserRequest) returns (User); rpc DeleteUser(DeleteUserRequest) returns (Empty); rpc CreateOrder(CreateOrderRequest) returns (Order); rpc GetOrder(GetOrderRequest) returns (Order);} 技术实现对比序列化机制HTTP序列化选择： 123456789101112131415161718192021// JSON序列化 (HTTP常用)const user = { id: 123, name: &quot;John Doe&quot;, email: &quot;john@example.com&quot;, created_at: &quot;2024-01-15T10:30:00Z&quot;};// 序列化后大小: ~85字节const json = JSON.stringify(user);// XML序列化 (较少使用)const xml = `&lt;user&gt; &lt;id&gt;123&lt;/id&gt; &lt;name&gt;John Doe&lt;/name&gt; &lt;email&gt;john@example.com&lt;/email&gt; &lt;created_at&gt;2024-01-15T10:30:00Z&lt;/created_at&gt;&lt;/user&gt;`;// 序列化后大小: ~150字节 RPC序列化优势： 12345678910// Protocol Buffers定义message User { int32 id = 1; string name = 2; string email = 3; google.protobuf.Timestamp created_at = 4;}// 二进制序列化后大小: ~35字节// 压缩率: 60%提升 性能对比测试： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import jsonimport pickleimport msgpackfrom google.protobuf import messagedef benchmark_serialization(data, iterations=10000): results = {} # JSON序列化 start = time.time() for _ in range(iterations): serialized = json.dumps(data) deserialized = json.loads(serialized) results['json'] = { 'time': time.time() - start, 'size': len(json.dumps(data)) } # MessagePack序列化 start = time.time() for _ in range(iterations): serialized = msgpack.packb(data) deserialized = msgpack.unpackb(serialized) results['msgpack'] = { 'time': time.time() - start, 'size': len(msgpack.packb(data)) } # Protocol Buffers (模拟) start = time.time() for _ in range(iterations): # 实际会使用protobuf编译的类 serialized = simulate_protobuf_encode(data) deserialized = simulate_protobuf_decode(serialized) results['protobuf'] = { 'time': time.time() - start, 'size': len(simulate_protobuf_encode(data)) } return results# 测试结果示例# JSON: 时间=100ms, 大小=1000字节# MessagePack: 时间=60ms, 大小=800字节# ProtoBuf: 时间=40ms, 大小=400字节 连接管理策略HTTP连接模式： 12345678910111213141516171819202122232425262728class HTTPConnectionPool: def __init__(self, max_connections=10): self.pool = queue.Queue(maxsize=max_connections) self.active_connections = 0 def get_connection(self, host, port): try: # 尝试复用现有连接 connection = self.pool.get_nowait() if connection.is_alive(): return connection except queue.Empty: pass # 创建新连接 if self.active_connections &lt; self.max_connections: connection = HTTPConnection(host, port) self.active_connections += 1 return connection # 等待可用连接 return self.pool.get(timeout=30) def return_connection(self, connection): if connection.is_alive(): self.pool.put(connection) else: self.active_connections -= 1 RPC连接模式： 123456789101112131415161718192021222324class gRPCChannelPool: def __init__(self, target, max_channels=5): self.target = target self.channels = [] self.current_index = 0 # 预建立长连接 for _ in range(max_channels): channel = grpc.insecure_channel( target, options=[ ('grpc.keepalive_time_ms', 30000), ('grpc.keepalive_timeout_ms', 5000), ('grpc.keepalive_permit_without_calls', True), ('grpc.http2.max_pings_without_data', 0), ] ) self.channels.append(channel) def get_channel(self): # 轮询选择通道 channel = self.channels[self.current_index] self.current_index = (self.current_index + 1) % len(self.channels) return channel 批量处理能力HTTP批量请求： 12345678910111213141516171819202122232425262728293031// HTTP批量请求需要多次往返class HTTPBatchProcessor { async processBatch(requests) { const promises = requests.map(request =&gt; fetch(request.url, { method: request.method, headers: request.headers, body: JSON.stringify(request.data) }) ); // 并发执行，但每个请求都是独立的HTTP事务 const responses = await Promise.all(promises); return responses.map(r =&gt; r.json()); }}// 使用示例const processor = new HTTPBatchProcessor();const requests = [ { url: '/api/users/1', method: 'GET' }, { url: '/api/users/2', method: 'GET' }, { url: '/api/users/3', method: 'GET' }];// 性能测试const startTime = performance.now();processor.processBatch(requests).then(results =&gt; { const endTime = performance.now(); console.log(`HTTP批量处理耗时: ${endTime - startTime}ms`);}); RPC批量处理： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# gRPC流式批量处理class gRPCBatchProcessor: def __init__(self, channel): self.stub = UserServiceStub(channel) def batch_get_users(self, user_ids): &quot;&quot;&quot;使用流式RPC进行批量处理&quot;&quot;&quot; def request_generator(): for user_id in user_ids: yield GetUserRequest(user_id=user_id) # 客户端流式调用 response = self.stub.BatchGetUsers(request_generator()) return [user for user in response.users] def parallel_batch_process(self, batches): &quot;&quot;&quot;并行批量处理&quot;&quot;&quot; import concurrent.futures with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor: futures = [] for batch in batches: future = executor.submit(self.batch_get_users, batch) futures.append(future) results = [] for future in concurrent.futures.as_completed(futures): results.extend(future.result()) return results# Protocol Buffers批量消息定义&quot;&quot;&quot;syntax = &quot;proto3&quot;;message BatchGetUsersRequest { repeated int32 user_ids = 1;}message BatchGetUsersResponse { repeated User users = 1; int32 total_count = 2; repeated Error errors = 3;}message User { int32 id = 1; string name = 2; string email = 3;}message Error { int32 user_id = 1; string message = 2;}service UserService { rpc BatchGetUsers(BatchGetUsersRequest) returns (BatchGetUsersResponse); rpc StreamBatchGetUsers(stream GetUserRequest) returns (stream User);}&quot;&quot;&quot; 性能对比分析： 处理方式 网络往返 连接开销 序列化效率 错误处理 HTTP REST N次独立请求 每请求建连 JSON较大 独立处理 HTTP GraphQL 1次请求 单次建连 JSON优化 统一处理 gRPC 批量 1次请求 复用连接 Protobuf高效 结构化错误 gRPC 流式 1次连接 长连接 流式传输 实时错误反馈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# 批量处理性能测试import timeimport asyncioclass PerformanceComparison: def __init__(self): self.results = {} async def test_http_batch(self, user_ids): &quot;&quot;&quot;测试HTTP批量请求性能&quot;&quot;&quot; start_time = time.time() # 模拟HTTP请求 tasks = [] for user_id in user_ids: task = asyncio.create_task(self.mock_http_request(user_id)) tasks.append(task) results = await asyncio.gather(*tasks) end_time = time.time() self.results['http_batch'] = { 'time': end_time - start_time, 'requests': len(user_ids), 'avg_latency': (end_time - start_time) / len(user_ids) } return results def test_grpc_batch(self, user_ids): &quot;&quot;&quot;测试gRPC批量请求性能&quot;&quot;&quot; start_time = time.time() # 模拟gRPC批量调用 request = BatchGetUsersRequest(user_ids=user_ids) response = self.mock_grpc_batch_call(request) end_time = time.time() self.results['grpc_batch'] = { 'time': end_time - start_time, 'requests': len(user_ids), 'avg_latency': end_time - start_time # 单次请求 } return response.users async def mock_http_request(self, user_id): # 模拟网络延迟 await asyncio.sleep(0.01) return {'id': user_id, 'name': f'User{user_id}'} def mock_grpc_batch_call(self, request): # 模拟批量处理延迟 time.sleep(0.05) # 批量处理固定开销 users = [User(id=uid, name=f'User{uid}') for uid in request.user_ids] return BatchGetUsersResponse(users=users) def print_comparison(self): print(&quot;\\n=== 批量处理性能对比 ===&quot;) for method, metrics in self.results.items(): print(f&quot;{method}:&quot;) print(f&quot; 总耗时: {metrics['time']:.3f}s&quot;) print(f&quot; 请求数: {metrics['requests']}&quot;) print(f&quot; 平均延迟: {metrics['avg_latency']:.3f}s&quot;) print(f&quot; 吞吐量: {metrics['requests']/metrics['time']:.1f} req/s&quot;)# 运行性能测试async def run_performance_test(): tester = PerformanceComparison() user_ids = list(range(1, 101)) # 100个用户ID # 测试HTTP批量处理 await tester.test_http_batch(user_ids) # 测试gRPC批量处理 tester.test_grpc_batch(user_ids) # 打印对比结果 tester.print_comparison()# asyncio.run(run_performance_test()) 技术选型建议HTTP适用场景 Web应用前端：浏览器原生支持，开发简单 公开API：标准化程度高，易于集成 微服务网关：统一入口，协议转换 缓存友好：GET请求可缓存 RPC适用场景 内部服务通信：性能要求高，类型安全 实时系统：低延迟，高吞吐量 复杂业务逻辑：强类型，接口定义清晰 跨语言服务：代码生成，接口一致性 总结HTTP协议作为互联网的基础协议，经历了从HTTP/0.9到HTTP/3的重大演进。每个版本都针对当时的技术挑战提出了创新解决方案： 技术演进脉络： HTTP/1.0: 建立了基础的请求-响应模型 HTTP/1.1: 引入持久连接，解决连接复用问题 HTTP/2: 通过多路复用和二进制分帧，解决队头阻塞 HTTP/3: 基于QUIC，从传输层根本解决TCP限制 核心技术突破： 连接管理优化：从短连接到持久连接，再到多路复用 传输效率提升：从文本协议到二进制分帧，压缩算法不断改进 安全性增强：从可选HTTPS到默认加密传输 性能优化：服务器推送、流量控制、拥塞控制算法优化 与RPC的互补关系：HTTP和RPC并非竞争关系，而是在不同场景下的最优选择。HTTP更适合面向资源的Web应用，RPC更适合面向服务的内部通信。现代架构中，两者常常结合使用，形成完整的通信解决方案。 未来发展趋势： HTTP/3普及：随着QUIC协议成熟，HTTP/3将成为主流 边缘计算优化：协议将更好地支持CDN和边缘节点 物联网适配：轻量化版本适应IoT设备限制 安全性强化：零信任架构下的协议安全增强 HTTP协议的演进体现了互联网技术的发展规律：在保持向后兼容的前提下，不断优化性能、增强安全性、提升用户体验。理解这些技术细节，有助于我们在实际项目中做出更好的架构决策。","link":"/2020/04/08/HTTP%E5%8D%8F%E8%AE%AE/"},{"title":"Hexo安装记录","text":"前言此处是废话，可以跳过。&emsp;&emsp;作为一名未来的挨踢人,博客是必不可少的一个工具，记录日常中做的项目，遇到的Bug等等（好记性不如烂笔头嘛！） &emsp;&emsp;&nbsp;目前，国内的博客平台主要有CSDN，博客园，简书等，但是他们往往无法满足人们个性化的要求，因此，我们选择白嫖Github 提供的Github Pages(静态网页托管服务) 搭建我们的静态博客。&emsp;&emsp;目前静态博客框架主要有Hexo,Hugo,Jekyll,Ghost，Gridea，此处博主选用Hexo，Hexo网上资料比较多:wink: Github 配置开启Github Pages服务 首先你需要有一个GitHub账号:如果没有,点击这里注册,过程不详述. 新建一个GitHub仓库，图例奉上:点击主页的加号，选择 New repository后进入此页面:Repository name处（仓库名称)切记命名为Username.github.io,([你的Github用户名]+[.github.io]),可能你会对仓库命名(Username.github.io)感到不解,这是Github Pages的命名规范,疑惑解答详见官方文档 安装配置Git Bash下载官网，选择合适的版本，如果没有梯子的话，建议用迅雷下载。 查看是否安装成功: 安装完成后,在cmd窗口输入命令git --version #查看git版本号 cmd打开方法:快捷键win+R打开运行,输入cmd回车即可进入命令提示符.配置Git Bash:打开Git Bash ，输入git config --global user.name&quot; &quot; 回车,配置用户名,再输入git config --global user.email&quot; &quot;回车,配置邮箱 配置SSH免密登录:打开Git Bash,输入ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; ，然后一直回车就OK,再然后转到 .ssh目录下：id_rsa和id_rsa.pub,用记事本打开.ssh目录下的id_rsa.pub文件，复制里面的内容；转到Github,点击Settings ,选择SSH and GPG keys 标题随意填写，在Key处填入刚才复制的公钥。 测试 ssh :输入 ssh -T git@github.com,出现Successfully，至此配置完成；操作图例: 安装Node js 点击此处,访问官网,下载相应版本. 检验是否安装成功,在cmd中输入 node -v npm -v ，出现相应版本号，至此安装完成。 Hexo配置 替换原有镜像源,安装命令: 12npm i -g cnpm --registry=https://registry.npm.taobao.org 安装hexo 12cnpm install hexo-cli -g cnpm install hexo-deployer-git --save Hexo初始化 1234567891. 新建文件夹，用于存放博客文件。2. 使用Gitbash进入到该文件夹下: - 鼠标右键点击该文件夹，选择Git Bash Here， - 或者打开gitbash，输入命令`cd 文件夹绝对路径` 3. 在Gitbash内输入以下命令:hexo init Hexo 文件配置 关联远程仓库 打开博客文件夹下的_config.yml（主配置文件）,在文件末尾加入以下内容，并修改相应的配置信息。1234deploy: type: git repository: git@github.com:username/username.github.io #username替换为你的用户名 branch: master 操作图例: 至此，博客初步搭建完成，执行以下命令，即可打开 http://localhost:4000/或者访问`xxx.github.io` 查看效果 123hexo g #生成静态文件hexo d#部署到githubhexo s #启动端口 显示以下信息说明操作成功： 1INFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 常用命令12345678hexo init //初始化博客文件hexo g //生成静态文件hexo d //部署到githubhexo s //启动端口hexo clean //清除缓存hexo new post &quot;postname&quot; //生成新文章hexo new page &quot;pageName&quot; //新建页面hexo version //查看hexo的版本 更换主题 打开GitHub,搜索hexo theme，挑选喜欢的主题,使用Git Bash克隆到博客目录下的themes文件夹下. ，修改博客目录下的_config.yml文件.找到theme,将默认的landscape替换为你心仪的主题即可,Github克隆速度不太稳定,推荐使用码云作为中转,然后再用Git Bash克隆到本地。 主题个性定制等有缘再更,推荐多阅读官方文档. Hexo 推荐 hexo-admin #方便管理文章 hexo-blog-encrypt #加密文章 typora #好用的markdown写作工具 PIGO+又拍云等 #作为图床 购买自己的域名 #目前国内Github访问速度不是很理想，你也可以用国内的码云，coding等，但是他们的限制比Github多，推荐（V2，SSR，XX-net） ，至此，就可以开始你的折腾了！","link":"/2020/02/10/Hexo%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/"},{"title":"Java基础语法及其特性","text":"发展 Java是一种面向对象的编程语言,现归属于ORACLE公司 JVM[Java virtual machine]:Java虚拟机,Java技术的核心,实现Java的跨平台,包含Java运行环境JRE,Java工具和Java基础类库. JDK[Java Development Kit]:Java的软件开发工具包,在JDK的安装目录下有一个jre目录,里面有两个文件夹bin和lib,可以理解为bin里的就是jvm,lib里的就是jvm工作所需的类库,而jvm和lib结合起来称为jre. JRE[Java Runtime Environment]:Java运行环境,包含JVM标准实现及Java核心类库(不是开发环境,不包含开发工具,例如编译器,调试器). Java 编译:Java语言编写的源程序,先通过Java编译器,编译成与平台无关的’字节码程序’(.class文件,二进制程序)然后通过Java解释器 解释执行. 12javac hello.java #编译成字节码文件.java hello #解释字节码. 运算符 算术运算符、位运算符、逻辑运算符、关系运算符 位运算符 名称 描述 举例 &amp; 按位与 如果相对应位都是 1，则结果为 1，否则为 0 （a＆b），得到 12，即 0000 1100 丨 按位或 如果相对应位都是 0，则结果为 0，否则为 1 （ a 丨 b ）得到 61，即 0011 1101 ^ 按位异或 如果相对应位值相同，则结果为 0，否则为 1 （a^b）得到 49，即 0011 0001 ~ 按位补 翻转操作数的每一位，即 0 变成 1，1 变成 0 （~a）得到 -61，即 1100 0011 &lt;&lt; 按位左移 左操作数按位左移右操作数指定的位数 a&lt;&lt;2 得到 240，即 1111 0000 &gt;&gt; 按位右移 左操作数按位右移右操作数指定的位数 a&gt;&gt;2 得到 15 即 1111 &gt;&gt;&gt; 按位右移补零 左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充 a&gt;&gt;&gt;2 得到 15 即 0000 1111 逻辑运算符 名称 描述 类型 举例 &amp;&amp; 或 &amp; 与 当且仅当两个操作数都为真，条件才为真 双目运算符 (a &amp;&amp; b) 或 (a &amp; b) 为假 || 或 | 或 两个操作数任何一个为真，条件为真 双目运算符 （a || b) 或 (a | b) 为真 ! 非 用来反转操作数的逻辑状态。如果条件为真，则逻辑非运算符将得到假 单目运算符 （!a）为假 ^ 异或 如果两个操作数逻辑相同，则结果为假，否则为真 双目运算符 (a ^ b) 为真 运算符优先级： 基本数据类型基本数据类型是CPU可以直接进行运算的类型。Java定义了以下几种基本数据类型： 整数类型：byte，short，int，long 浮点数类型：float，double 字符类型：char 布尔类型：boolean 12345计算机内存的最小存储单元是字节（byte），一个字节就是一个8位二进制数，即8个bit。它的二进制表示范围从00000000~11111111，换算成十进制是0~255，换算成十六进制是00~ff。 1234567内存单元从0开始编号，称为内存地址。每个内存单元可以看作一间房间，内存地址就是门牌号。 0 1 2 3 4 5 6 ...┌───┬───┬───┬───┬───┬───┬───┐│ │ │ │ │ │ │ │...└───┴───┴───┴───┴───┴───┴───┘ 123456789一个字节是1byte，1024字节是1K，1024K是1M，1024M是1G，1024G是1T。一个拥有4T内存的计算机的字节数量就是：4T = 4 x 1024G = 4 x 1024 x 1024M = 4 x 1024 x 1024 x 1024K = 4 x 1024 x 1024 x 1024 x 1024 = 4398046511104 不同的数据类型占用的字节数不一样。我们看一下Java基本数据类型占用的字节数： 1234567891011121314151617181920212223 ┌───┐ byte │ │ └───┘ ┌───┬───┐ short │ │ │ └───┴───┘ ┌───┬───┬───┬───┐ int │ │ │ │ │ └───┴───┴───┴───┘ ┌───┬───┬───┬───┬───┬───┬───┬───┐ long │ │ │ │ │ │ │ │ │ └───┴───┴───┴───┴───┴───┴───┴───┘ ┌───┬───┬───┬───┐ float │ │ │ │ │ └───┴───┴───┴───┘ ┌───┬───┬───┬───┬───┬───┬───┬───┐double │ │ │ │ │ │ │ │ │ └───┴───┴───┴───┴───┴───┴───┴───┘ ┌───┬───┐ char │ │ │ └───┴───┘ byte恰好就是一个字节，而long和double需要8个字节。 对于整型类型，Java只定义了带符号的整型，因此，最高位的bit表示符号位（0表示正数，1表示负数）。各种整型能表示的最大范围如下： byte：-128 ~ 127 short: -32768 ~ 32767 int: -2147483648 ~ 2147483647 long: -9223372036854775808 ~ 9223372036854775807 浮点型浮点类型的数就是小数，因为小数用科学计数法表示的时候，小数点是可以“浮动”的，如1234.5可以表示成12.345x102，也可以表示成1.2345x103，所以称为浮点数。 下面是定义浮点数的例子： 12345float f1 = 3.14f;float f2 = 3.14e38f; // 科学计数法表示的3.14x10^38double d = 1.79e308;double d2 = -1.79e308;double d3 = 4.9e-324; // 科学计数法表示的4.9x10^-324 对于float类型，需要加上f后缀。 浮点数可表示的范围非常大，float类型可最大表示3.4x1038，而double类型可最大表示1.79x10308。 布尔类型布尔类型boolean只有true和false两个值，布尔类型总是关系运算的计算结果： 12345boolean b1 = true;boolean b2 = false;boolean isGreater = 5 &gt; 3; // 计算结果为trueint age = 12;boolean isAdult = age &gt;= 18; // 计算结果为false Java语言对布尔类型的存储并没有做规定，因为理论上存储布尔类型只需要1 bit，但是通常JVM内部会把boolean表示为4字节整数。 字符类型字符类型char表示一个字符。Java的char类型除了可表示标准的ASCII外，还可以表示一个Unicode字符：注意char类型使用单引号’，且仅有一个字符，要和双引号”的字符串类型区分开。 引用类型除了上述基本类型的变量，剩下的都是引用类型。例如，引用类型最常用的就是String字符串： String s = “hello”;引用类型的变量类似于C语言的指针，它内部存储一个“地址”，指向某个对象在内存的位置，后续我们介绍类的概念时会详细讨论。 常量定义变量的时候，如果加上final修饰符，这个变量就变成了常量： 1234final double PI = 3.14; // PI是一个常量double r = 5.0;double area = PI * r * r;PI = 300; // compile error! 常量在定义时进行初始化后就不可再次赋值，再次赋值会导致编译错误。 常量的作用是用有意义的变量名来避免魔术数字（Magic number），例如，不要在代码中到处写3.14，而是定义一个常量。如果将来需要提高计算精度，我们只需要在常量的定义处修改，例如，改成3.1416，而不必在所有地方替换3.14。 根据习惯，常量名通常全部大写。 var关键字有些时候，类型的名字太长，写起来比较麻烦。例如： StringBuilder sb = new StringBuilder();这个时候，如果想省略变量类型，可以使用var关键字： var sb = new StringBuilder();编译器会根据赋值语句自动推断出变量sb的类型是StringBuilder。对编译器来说，语句： var sb = new StringBuilder();实际上会自动变成： StringBuilder sb = new StringBuilder();因此，使用var定义变量，仅仅是少写了变量类型而已。 命名规范#####规范是为了可读性，不是强制措施。1,项目名全部小写2,包名全部小写，点分隔符之间有且仅有一个自然语义的英语单词，包名统一单数形式，但类名如果有复数含义，类名可以用复数形式3,类名首字母大写,其余组成词首字母依次大写4,变量名,参数名，方法名首字母小写，如果名称由多个单词组成，除首字母外的每个单词的首字母都要大写5.常量名全部大写，单词间下划线隔开。6，命名规范遵从以下原则： 名称只能由字母、下划线、数字、$符号组成。 不能以数字开头 名称不能使用Java中的关键字 不允许出现中文及拼音命名 7.抽象类名使用Abstract或Base开头，异常类命名使用Exception结尾；测试类名要以测试的类的名称开始，以Test结尾。例：AbstractClass、CommonException、DemoTest.8.枚举类名带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开。例：枚举名字为ProcessStatusEnum的成员名称：SUCCESS 、 UNKNOWN_REASON 上转型在继承关系中,会存在对象的上转型关系,例如 父类People,子类Asian, 123People zhang= new People();Asian li =new Asian();zhang=li; //称对象zhang是对象li的上转型对象 上转型对象不能操纵子类的新增成员,不能调用子类的新增方法 上转型对象可以访问子类继承或隐藏的成员变量,可以调用子类继承或重写的实例方法, 子类如果重写了父类的静态方法,那么子类对象的上转型对象不能调用子类重写的静态方法,只能调用父类的静态方法 上转型对象可以被强制转化为子类对象, 抽象类使用abstract修饰的类称为abstract类, abstract类不能用new运算符创建该类对象 非抽象类中不能有abstract方法 abstract 类的子类 其子类为非abstract类,则必须重写父类的abstract方法,给出方法体,若为abstract类,可以继承,也可以重写使用abstract修饰的方法称为abstract方法, 不允许使用final与abstract同时修饰一个类和方法, 不允许使用static修饰abstract方法, abstract方法必须是实例方法 方法类型前有static的为类方法，反之则为实例方法 实例方法在对象被创建后,被加载, 类方法在类文件加载到内存时就已经创建 abstract方法,只允许声明,不允许实现 蓝桥杯 B组,求黄金分割率(0.618)精确到100位小数.Java中,提供的最大整形范围是64位 long型整数 java中能处理大数的类有两个,位于java.math包中,导入语句import java.math.*; 高精度大整数: BigInteger. 内部用一个int[] 数组来模拟一个非常大的整数.BigInteger.ONE… ZERO.. TEN分别代表1,0,10, 赋值示例 12345BigInteger b=new BigInteger(&quot;1234567890&quot;);BigInteger c=new BigInteger.ONE;BigInteger d=new BigInteger.ZERO;BigInteger e=BigInteger.valueOf(2);sysout(b.pow(5)); //此处简打输出函数 对BigInteger做运算的时候,只能使用实例方法add,multiply,divide,mod,subtract,abs,pow,gcd,compareTo.不能使用算术运算符(如+,-,*) 12BigInteger a=c.add(b); // a=c+bBigInteger f=d.multiply(b.add(BigInteger.valueOf(8))) //f=d*(b+8) 和long型整数运算比，BigInteger不会有范围限制，但缺点是速度比较慢。 也可以把BigInteger转换成long型： 123BigInteger i = new BigInteger(&quot;123456789000&quot;);System.out.println(i.longValue()); // 123456789000System.out.println(i.multiply(i).longValueExact()); // java.lang.ArithmeticException: BigInteger out of long range 使用longValueExact()方法时，如果超出了long型的范围，会抛出ArithmeticException。 BigInteger和Integer、Long一样，也是不可变类，并且也继承自Number类。因为Number定义了转换为基本类型的几个方法： 转换为byte：byteValue() 转换为short：shortValue() 转换为int：intValue() 转换为long：longValue() 转换为float：floatValue() 转换为double：doubleValue() 因此，通过上述方法，可以把BigInteger转换成基本类型。如果BigInteger表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用intValueExact()、longValueExact()等方法，在转换时如果超出范围，将直接抛出ArithmeticException异常。 高精度浮点数: BigDecimal BigDecimal用scale()表示小数位数,eg: 1234BigDecimal d1=new BigDecimal(&quot;12345.67890&quot;)BigDecimal d2=new BigDecimal(&quot;1234.5&quot;)sysout(d1.scale())// 输出5sysout(d2.scale())//输出1 stripTrailingZeros()方法可以将一个BigDecimal格式化为一个相等的,但去掉了末尾0的BigDecimal; 123456789BigDecimal d1 = new BigDecimal(&quot;123.4500&quot;);BigDecimal d2 = d1.stripTrailingZeros();System.out.println(d1.scale()); // 4System.out.println(d2.scale()); // 2,因为去掉了00BigDecimal d3 = new BigDecimal(&quot;1234500&quot;);BigDecimal d4 = d3.stripTrailingZeros();System.out.println(d3.scale()); // 0System.out.println(d4.scale()); // -2 例子转自廖雪峰 如果一个BigDecimal的scale()返回负数,例如,-2,表示这个数是个整数,并且末尾有2个0 BigDecimal 设置小数位长度 BigDecimal.setScale()方法用于格式化小数点 setScale(1)表示保留一位小数,默认用四舍五入方式 setScale(1,BigDecimal.ROUND_DOWN) //直接删除多余的小数位,如1.23-&gt;1.2 setScale(1,BigDecimal.ROUND_UP) //进位处理,如1.23-&gt;1.2 setScale(1,BigDecimal.ROUND_HALF_UP) //四舍五入 setScale(1,BigDecimal.ROUND_HALF_DOWN) //四舍五入,小数位是5则是向下舍 Java 四舍五入:观察前一位奇偶性,奇数,5入;偶数,5舍 dividerAndRemainder()方法,返回数组包含两个BigDecimal,分别是商和余数 capareTo()比较两个BigDecimal的值是否相等,而不能使用equals();","link":"/2020/04/01/Java%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/"},{"title":"Linux命令杂记","text":"ls:查看当前目录中的内容cd:进入目录 cd .. &nbsp; :返回上一级目录 cd - &nbsp;: 返回上一次所在的目录 cd ~ &nbsp;:回到当前用户的主目录 mkdir 文件夹名称:在当前目录下创建文件夹touch 文件名:新建文件,不会覆盖已有文件cp 文件名 指定目录:复制文件到指定目录 cp -r 文件夹名 指定目录:复制文件夹到指定目录 rm 需删除文件名:删除指定文件 rm -r 需删除文件夹名称:删除指定文件夹 mv 移动文件夹/文件名 指定目录:移动文件夹/文件 mv 也可以为文件重命名:例如mv test1 test2 就可以 把test1重命名为test2 cat 文件目录/文件名:把文件中的内容打印到屏幕中 cat -n 文件名 :可以带行号打印文件内容 man 命令名称:可以获取命令详细的帮助文档 ,按q退出man 实践出真知!","link":"/2020/02/19/Linux%20%E5%91%BD%E4%BB%A4%E6%9D%82%E8%AE%B0/"},{"title":"kafka安装","text":"第九节 kafka安装Kafka 安装和使用 安装 1234cd /usr/appwget https://archive.apache.org/dist/kafka/0.8.1.1/kafka_2.10-0.8.1.1.tgztar –zxvf kafka_2.10-0.8.1.1.tgzmv kafka_2.10-0.8.1.1 kafka2.10 配置 123456789101112131415cd /usr/app/kafka2.10#编辑配置文件server.propertiesvi /usr/app/kafka2.10/config/server.properties#添加下面两行host.name=hadoop11zookeeper.connect=hadoop11:2181,hadoop12:2181,hadoop13:2181#传到其余机器scp -r /usr/app/kafka2.10 root@hadoop12:/usr/appscp -r /usr/app/kafka2.10 root@hadoop13:/usr/app#复制完之后分别修改修改slave1、slave2的Kafka安装目录下的config/server.properties文件 broker.id# slave1broker.id=2# slave2broker.id=3 启动kfaka 12#启动 kafka 之前,需要启动 Zookeeper/usr/app/kafka2.10/bin/kafka-server-start.sh -daemon /usr/app/kafka2.10/config/server.properties&amp; Kafka 命令行操作 生产者接收用户的标准输入发送到 Kafka，消费者则一直尝试从 Kafka 中拉取生产的数据， 并打印到标准输出中。下面使用 Kafka 命令行客户端创建主题、 生产者与消费者，以测试 Kafka 集群能否正常使用。","link":"/2020/05/08/9/"},{"title":"python GIL","text":"CPython 中的 GIL：影响与应对方法 Python 官方文档 global interpreter lock:The mechanism used by the CPython interpreter to assure that only one thread executes Python bytecode at a time. This simplifies the CPython implementation by making the object model (including critical built-in types such as dict) implicitly safe against concurrent access. Locking the entire interpreter makes it easier for the interpreter to be multi-threaded, at the expense of much of the parallelism afforded by multi-processor machines. However, some extension modules, either standard or third-party, are designed so as to release the GIL when doing computationally intensive tasks such as compression or hashing. Also, the GIL is always released when doing I/O. Past efforts to create a “free-threaded” interpreter (one which locks shared data at a much finer granularity) have not been successful because performance suffered in the common single-processor case. It is believed that overcoming this performance issue would make the implementation much more complicated and therefore costlier to maintain. 全局解释程序锁：全局解释程序锁（GIL）是 CPython 解释器的一个特性，确保一次只有一个线程可以执行 Python 字节码。GIL 的存在简化了 CPython 的实现，通过隐式地为对象模型提供并发访问安全性，甚至包括关键的内置类型，如字典。虽然全局解释程序锁会限制多线程环境中并行执行的能力，但通过将同步复杂性集中到解释器级别，它使得解释器更容易支持多线程。然而，这也导致多核处理器提供的并行性大部分被消耗。不过，一些扩展模块（无论是标准的还是第三方的）被设计为在执行计算密集型任务（如压缩或散列）时会释放 GIL。此外，在执行 I/O 操作时，GIL 总是会被释放。过去创建“自由线程”解释器（以更细的粒度锁定共享数据的解释器）的努力没有成功，因为在常见的单处理器情况下性能受到影响。据信，克服该性能问题将使实现复杂得多，并且因此维护成本更高。 不同 Python 解释器的特点及 GIL 影响 Python 生态系统中有多种 Python 解释器实现，每个实现都有其独特的特点： CPython：作为 Python 的标准解释器，使用 C 语言开发，对 Python 语言特性的支持最全面，广泛被使用。 Jython：基于 Java 开发，能够将 Python 代码编译为 Java 字节码，运行在 JVM 上，且可以调用 Java 库。 IronPython：使用 C# 开发，运行在 .NET 平台上，可以调用 C# 库和 .NET 框架。 PyPy：使用 Python 开发，通过 JIT 技术提高执行效率，与 CPython 兼容性较好。 Cython：并非独立的解释器，而是一种能够将 Python 扩展为可编译成 C 语言的语法扩展，可以生成 C 语言代码以提高效率，需要编译后才能在 CPython 中使用。 还有其他实现如 Stackless Python、MicroPython 等。 CPython 作为使用 C 语言开发的标准解释器，存在全局解释器锁（GIL）的问题，从而导致多线程无法充分利用多核 CPU。 Jython 和 IronPython：由于基于 Java 和 .NET 运行时，不存在 GIL 问题，可以在多核 CPU 上充分发挥优势。 PyPy：虽然 PyPy 也有 GIL，但其使用 JIT 编译技术，部分优化了 GIL 带来的问题。 Cython：Cython 本身并非独立的解释器，但它可以通过编译成 C 语言的扩展来提高 Python 解释器的效率，不受 GIL 影响。 为什么 CPython 中存在 GIL？ CPython 中存在全局解释器锁（GIL）的主要原因是其历史和设计初衷。 历史背景： Python 最初在单核 CPU 时代诞生，其设计初衷并未考虑多线程并发执行的场景。在此背景下，设计师并没有着重解决多线程竞争问题。 引用计数内存管理机制： CPython 主要使用引用计数内存管理机制。然而，这种机制并不是线程安全的。具体而言，引用计数机制在多线程环境中容易出现问题，多个线程同时对对象引用计数进行增减操作可能引发竞争条件和线程安全问题。 为了避免这些问题，CPython 在执行 Python 字节码时引入了 GIL。这个机制确保同一时刻只有一个线程可以执行 Python 字节码，从而简化了内存管理。然而，这也限制了在多核 CPU 下实现真正的并发执行。 尽管 GIL 在某些情况下降低了多线程编程的便利性，但它在某些方面也有好处，例如在 I/O 密集型任务中释放 GIL，允许其他线程执行。 CPython 使用 C 扩展库： CPython 广泛使用 C 语言扩展库来提升性能。在多线程环境下，C 扩展库需要自己实现线程同步，这可能增加复杂性和错误的可能性。 降低 GIL 影响的方法： 降低 GIL 影响的策略包括但不限于以下方法： 利用多进程充分利用多核 CPU，从而避免 GIL 的限制。 使用异步编程来优化 I/O 密集型应用的并发性。 使用 C 扩展库或 Cython 优化计算密集型代码的执行效率。 利用 multiprocessing 模块提供的进程池实现多进程并发。 考虑使用无 GIL 的解释器，如 Jython、IronPython。 使用并行计算框架如 Dask、Joblib 支持并行计算。 优化算法和数据结构以减少竞争锁的使用。 分离计算密集型代码和 I/O 操作，充分利用 GIL 的释放。 对于 I/O 密集型任务，使用多线程优化而非计算密集型任务。 合理设置线程数量，避免过多线程竞争。 使用原生线程或 asyncio 等作为并发手段。 在适当的情况下使用共享内存和消息传递，减少锁的竞争。","link":"/2020/04/24/Python-GIL/"},{"title":"Python浅拷贝、深拷贝与赋值","text":"首先是python的基本数据类型： Number(数字) String(字符串) bool(布尔类型) List(列表) Tuple(元组) Set(集合) Dictory(字典) 不可变类型：Number(数字) Tuple(元组) String(字符串) bool(布尔类型) 可变类型：List(列表)Set(集合)Dictory(字典) 可变类型与不可变类型对比1234a = 45print(id(a)) # 94458411934400a = 56print(id(a)) # 94458411934752 在上述代码中，我们对变量a进行了赋值操作。初始时，变量a引用整数对象45，其内存地址为94458411934400。然后，我们将a赋值为56，此时会新开辟内存空间存储整数对象56，并将变量a重新指向该内存地址，其内存地址变为94458411934752。这是因为不可变类型（如整数）在值发生变化时会创建新的对象，而不是修改原有对象。 1234b = [1, 2, 3]print(id(b)) # 139680049341440b.append(5)print(id(b)) # 139680049341440 在上述代码中，我们创建了一个列表对象b，初始时包含元素[1, 2, 3]，其内存地址为139680049341440。然后，我们使用append方法向列表b中添加元素5。由于列表是可变类型，添加元素并不会创建新的对象，而是在原有对象的内存空间上进行修改，因此列表b的内存地址保持不变。 通过以上代码示例，我们可以看出不可变类型在值发生变化时会创建新的对象并修改变量的引用，而可变类型在修改值时会直接在原有对象的内存空间上进行操作，不改变变量的引用。 python中的变量声明是动态的，变量的类型是根据赋值自动推断的，不需要显示指定变量的类型。 123456789101112直接赋值：是对象的引用a = 10000# 创建一个整数对象10000，在内存中分配一块空间用于存储它的值，并将创建的对象与变量a相关联，变量a引用了该对象b = a# 变量b被赋值为变量a，b引用了与变量a相同的地址，指向同一个整数对象c = 10000# 变量c被赋值为10000，又创建了一个新的整数对象，并将变量c与该对象相关联print(id(a)) # 139680049769968print(id(b)) # 139680049769968# 变量a和变量b指向相同的对象，它们的内存地址是相同的print(id(c)) # 139680049766704# 变量c指向新的对象，因此它的内存地址与变量a和变量b不同 在上述代码中，变量a、b和c都被赋值为整数对象10000，但是变量a和变量b指向同一个对象，它们的内存地址是相同的，而变量c则指向一个新的对象，因此其内存地址与变量a和变量b不同。 需要注意的是，变量在赋值时实际上是引用了对象，而不是直接存储对象的值。这意味着变量可以引用不同类型的对象，因为类型是根据对象自动推断的。 浅拷贝与深拷贝在Python中，我们可以使用浅拷贝和深拷贝来复制对象，Python中的拷贝操作可以使用copy模块中的copy函数进行浅拷贝，使用copy模块中的deepcopy函数进行深拷贝。它们的区别在于： 浅拷贝：创建一个新的对象，然后将原始对象的引用复制给新对象，这样原始对象和新对象将引用同一个内存地址，它们指向相同的对象。只拷贝父对象本身，不会拷贝父对象的子对象 深拷贝：创建一个新对象，并递归的复制原始对象及子对象。深拷贝会创建一个独立的对象，即新对象和原始对象是独立的，它们拥有不同的内存地址。深拷贝会完全拷贝父对象及子对象 123456789#浅拷贝与深拷贝import copya=[100,2,3]b=copy.copy(a)c=copy.deepcopy(b)a.append(5)print(id(a))#139679863695488print(id(b))#139679863460160print(id(c))#139679863461632 观察输出结果可以发现： 列表a发生了变化，添加了一个新的元素5。 列表b保持不变，它仍然是原始的浅拷贝，因此不会受到a的修改的影响。 列表c也保持不变，它是原始的深拷贝，因此不会受到a的修改的影响。 打印出的内存地址（id）可以看到，a、b和c指向的是不同的内存空间，它们是相互独立的对象。 这个例子展示了浅拷贝和深拷贝的不同行为。浅拷贝只复制了对象的引用，而深拷贝递归地复制了整个对象及其子对象。因此，在修改原始对象时，浅拷贝不会受到影响，而深拷贝则是完全独立的副本。 12345import copya = [[100, 4, 8], 2, 3]b = copy.copy(a)c = copy.deepcopy(b)a[0].append(5) 输出结果如下： 123456[[100, 4, 8, 5], 2, 3][[100, 4, 8, 5], 2, 3][[100, 4, 8], 2, 3]139679893614720139679893614720139679893614592 从输出结果可以观察到以下情况： 列表 a 的第一个元素是一个嵌套列表 [100, 4, 8]，在进行浅拷贝后，列表 b 也引用了相同的嵌套列表对象。因此，对 a[0] 进行修改会影响到 b[0]，导致它们的值都增加了 5。 使用深拷贝 copy.deepcopy() 创建的列表 c，在进行修改时并不会影响原始的列表 a 和浅拷贝的列表 b。因此，c[0] 的值保持不变。 尽管 a[0] 和 b[0] 的值相同，但它们的内存地址是不同的。 综上所述，浅拷贝只复制了列表对象的引用，因此对可变对象的修改会影响到原始对象和浅拷贝对象。而深拷贝创建了原始对象及其所有嵌套对象的独立副本，因此对副本的修改不会影响到原始对象。此外，内存地址的不同也说明了它们是不同的对象。","link":"/2020/04/24/Python%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E8%B5%8B%E5%80%BC/"},{"title":"MBTI(迈尔斯布里格斯类型指标)","text":"最近刷知乎,不时看到关于intp,intj人格的问题. 刚开始看到的时候感觉这和星座差不多,模棱两可，真正发现内心的自己确实有点难度。 我还是把这几种人格的表格列一下吧,权当故事看.(表格来源 百度百科) 今天又刷到一则学生跳楼的新闻,也许有时候把人分为不同的性格,以相应的方式分别对待会好点吧,人就是这么脆弱. 以前以为人可以掌控自己的性格,自己的情绪,现在也同样如此.但是真正到自己面临时,却又很难走出来. 迈尔斯布里格斯类型指标（MBTI）表中人的性格，是美国心理学家伊莎贝尔·布里格斯·迈尔斯和她的母亲凯瑟琳·库克·布里格斯制定的。 该指标以瑞士心理学家荣格划分的8种类型为基础，经过二十多年的研究后，编制成了《迈尔斯-布里格斯类型指标》，从而把荣格的类型理论付诸实践。迈尔斯在荣格的优势功能和劣势功能、主导功能和从属功能等概念的基础上，进一步提出功能等级等概念，并有效的为每一种类型确定了其功能等级的次序，又提出了类型的终生发展理论，形成四个维度。约翰.毕比博士在《类型与原型》中，将心理类型理论和原型理论系统地结合在一起。华南师范大学申荷永教授将心理类型引进了中国并加以扩展。这四个维度就是四把标尺，每个人的性格都会落在标尺的某个点上，这个点靠近哪个端点，就意味着这个人就有哪方面的偏好. 类型名称 相对应英文字母简称 类型名称 相对应英文字母简称 内倾感觉思维判断 （ISTJ） 内倾感觉情感判断 （ISFJ） 内倾直觉情感判断 （INFJ） 内倾直觉思维判断 （INTJ） 内倾感觉思维知觉 （ISTP） 内倾感觉情感知觉 （ISFP） 内倾直觉情感知觉 （INFP） 内倾直觉思维知觉 （INTP） 外倾感觉思维判断 （ESTJ） 外倾感觉情感判断 （ESFJ） 外倾直觉情感判断 （ENFJ） 外倾直觉思维判断 （ENTJ） 外倾感觉思维知觉 （ESTP） 外倾感觉情感知觉 （ESFP） 外倾直觉情感知觉 （ENFP） 外倾直觉思维知觉 （ENTP） 十六种人格 维度 类型 相对应类型英文及缩写 类型 相对应类型英文缩写 注意力方向（精力来源） 外倾（外向） E（Extrovert） 内倾（内向） I（Introvert） 认知方式（如何搜集信息） 实感（感觉） S（Sensing） 直觉（直觉） N（iNtuition） 判断方式（如何做决定） 思维（理性） T（Thinking） 情感（感性） F（Feeling） 生活方式（如何应对外部世界） 判断（主观） J（Judgement） 知觉（客观） P（Perceiving） 外倾型（E） 内倾型（I） 与他人相处时精力充沛 独处时精力充沛 行动先于思考 思考先于行动 喜欢边想边说出声 在心中思考问题 易于“读”和了解；随意地分享个人情况 更封闭，更愿意在经挑选的小群体中分享个人的情况 说的多于听的 听的比说的多 高度热情地社交 不把兴奋说出来 反应快，喜欢快节奏 仔细考虑后，才有所反应 重于广度而不是深度（心理能量的获得途径和与外界相互作用的程度） 喜欢深度而不是广度（心理能量的获得途径和与外界相互作用的程度） 感觉型（S） 直觉型（N） 相信确定和有形的东西 相信灵感或推理 对概念和理论兴趣不大，除非它们有着实际的效用 对概念和理论感兴趣 重视现实性和常情 重视可能性和独创性 喜欢使用和琢磨已知的技能 喜欢学习新技能，但掌握之后很容易就厌倦了 留意具体的、特定的事物；进行细节描述 留意事物的整体概况、普遍规律及象征含义；用概括、隐喻等方式进行表述 循序渐进地讲述有关情况 跳跃性地展现事实 着眼于现实 着眼于未来，留意事物的变化趋势，惯于从长远角度看待事物 喜欢深度而不是广度（接受信息上） 重于广度而不是深度（接受信息上） 思维型（T） 情感型（F） 退后一步思考，对问题进行客观的、非个人立场的分析 超前思考，考虑行为对他人的影响 重视符合逻辑、公正、公平的价值；一视同仁 重视同情与和睦：重视准则的例外性 被认为冷酷、麻木、漠不关心 被认为感情过多，缺少逻辑性，软弱 认为坦率比圆通更重要 认为圆通比坦率更重要 只有当情感符合逻辑时，才认为它可取 无论是否有意义，认为任何感情都可取 被“获取成就”所激励 被“获得欣赏”所激励 很自然地看到缺点，倾向于批评 惯于迎合他人，着重维护人脉资源 判断型（J） 知觉型（P） 做了决定后最为高兴 当各种选择都存在时，感到高兴 有“工作原则”：工作第一，玩其次（如果有时间的话） “玩的原则”：现在享受，然后再完成工作（如果有时间的话） 建立目标，准时地完成 随着新信息的获取，不断改变目标 愿意知道它们将面对的情况 喜欢适应新情况 着重结果（重点在于完成任务） 着重过程（重点在于如何完成工作） 满足感来源于完成计划 满足感来源于计划的开始 把时间看作有限的资源，认真地对待最后期限 认为时间是可更新的资源，而且最后期限也是有收缩的 人格类型ISTJ1.严肃、安静、藉由集中心志与全力投入、及可被信赖获致成功。 2.行事务实、有序、实际、逻辑、真实及可信赖。 3.十分留意且乐于任何事（工作、居家、生活均有良好组织及有序）。 4.负责任。 5.照设定成效来作出决策且不畏阻挠与闲言会坚定为之。 6.重视传统与忠诚。 7.传统性的思考者或经理。 ISFJ1.安静、和善、负责任且有良心。 2.行事尽责投入。 3.安定性高，常居项目工作或团体之安定力量。 4.愿投入、吃苦及力求精确。 5.兴趣通常不在于科技方面。对细节事务有耐心。 6.忠诚、考虑周到、知性且会关切他人感受。 7.致力于创构有序及和谐的工作与家庭环境。 INFJ1.因为坚忍、创意及必须达成的意图而能成功。 2.会在工作中投注最大的努力。 3.默默强力的、诚挚的及用心的关切他人。 4.因坚守原则而受敬重。 5.提出造福大众利益的明确远景而为人所尊敬与追随。 6.追求创见、关系及物质财物的意义及关联。 7.想了解什么能激励别人及对他人具洞察力。 8.光明正大且坚信其价值观。 9.有组织且果断地履行其愿景。 INTJ1.具强大动力与本意来达成目的与创意—固执顽固者。 2.有宏大的愿景且能快速在众多外界事件中找出有意义的模范。 3.对所承负职务，具良好能力于策划工作并完成。 4.具怀疑心、挑剔性、独立性、果决，对专业水准及绩效要求高。 ISTP1.冷静旁观者—安静、预留余地、弹性及会以无偏见的好奇心与未预期原始的幽默观察与分析。 2.有兴趣于探索原因及效果，技术事件是为何及如何运作且使用逻辑的原理组构事实、重视效能。 3.擅长于掌握问题核心及找出解决方式。 4.分析成事的缘由且能实时由大量资料中找出实际问题的核心。 ISFP1.羞怯的、安宁和善地、敏感的、亲切的、且行事谦虚。 2.喜于避开争论，不对他人强加已见或价值观。 3.无意于领导却常是忠诚的追随者。 4.办事不急躁，安于现状无意于以过度的急切或努力破坏现况，且非成果导向。 5.喜欢有自有的空间及照自订的时程办事。 INFP1安静观察者，具理想性与对其价值观及重要之人具忠诚心。 2.希望在生活形态与内在价值观相吻合。 3.具好奇心且很快能看出机会所在。常担负开发创意的触媒者。 4.除非价值观受侵犯，行事会具弹性、适应力高且承受力强。 5.具想了解及发展他人潜能的企图。想作太多且作事全神贯注。 6.对所处境遇及拥有不太在意。 7.具适应力、有弹性除非价值观受到威胁。 INTP1.安静、自持、弹性及具适应力。 2.特别喜爱追求理论与科学事理。 3.习于以逻辑及分析来解决问题—问题解决者。 4.最有兴趣于创意事务及特定工作，对聚会与闲聊无大兴趣。 5.追求可发挥个人强烈兴趣的生涯。 6.追求发展对有兴趣事务之逻辑解释。 ESTP1.擅长现场实时解决问题—解决问题者。 2.喜欢办事并乐于其中及过程。 3.倾向于喜好技术事务及运动，交结同好友人。 4.具适应性、容忍度、务实性；投注心力于会很快具成效工作。 5.不喜欢冗长概念的解释及理论。 6.最专精于可操作、处理、分解或组合的真实事务。 ESFP1.外向、和善、接受性、乐于分享喜乐予他人。 2.喜欢与他人一起行动且促成事件发生，在学习时亦然。 3.知晓事件未来的发展并会热列参与。 4.最擅长于人际相处能力及具备完备常识，很有弹性能立即适应他人与环境。 5.对生命、人、物质享受的热爱者。 ENFP1.充满热忱、活力充沛、聪明的、富有想象力的，生命中充满机会且其能很快得到他人肯定与支持。 2.几乎能达成所有有兴趣的事。 3.对难题很快就有对策并能对有困难的人施予援手。 4.依赖能改善的能力而无须预作规划准备。 5.为达目的常能找出强制自己为之的理由。 6.即兴执行者。 ENTP1.反应快、聪明、长于多样事务。 2.具激励伙伴、敏捷及直言讳专长。 3.会为了有趣对问题的两面加予争辩。 4.对解决新及挑战性的问题富有策略，但会轻忽或厌烦经常的任务与细节。 5.兴趣多元，易倾向于转移至新生的兴趣。 6.对所想要的会有技巧地找出逻辑的理由。 7.长于看清楚他人，有智能去解决新或有挑战的问题。 ESTJ1.务实、真实、事实倾向，具企业或技术天份。 2.不喜欢抽象理论；最喜欢学习可立即运用事理。 3.喜好组织与管理活动且专注以最有效率方式行事以达致成效。 4.具决断力、关注细节且很快作出决策—优秀行政者。 5.会忽略他人感受。 6.喜作领导者或企业主管。 7.做事风格比较偏向于权威指挥性。 ESFJ1.诚挚、爱说话、合作性高、受欢迎、光明正大的—天生的合作者及活跃的组织成员。 2.重和谐且长于创造和谐。 3.常作对他人有益事务。 4.给予鼓励及称许会有更佳工作成效。 5.最有兴趣于会直接及有形影响人们生活的事务。 6.喜欢与他人共事去精确且准时地完成工作。 ENFJ1.热忱、易感应及负责任的、具有能鼓励他人的领导风格。 2.对别人所想或希求会表达真正关切且切实用心去处理。 3.能怡然且技巧性地带领团体讨论或演示文稿提案。 4.爱交际、受欢迎及富同情心。 5.对称许及批评很在意。 6.喜欢带引别人且能使别人或团体发挥潜能。 ENTJ1.坦诚、具决策力的活动领导者。 2.长于发展与实施广泛的系统以解决组织的问题。 3.专精于具内涵与智能的谈话如对公众演讲。 4.乐于经常吸收新知且能广开信息管道。 5.易生过度自信，会强于表达自已创见。 6.喜于长程策划及目标设定。","link":"/2020/10/15/MBTI/"},{"title":"Https 浅解","text":"传统的HTTP (Hypertext Transfer Protocol) 协议在数据传输过程中是明文的，这意味着任何恶意的第三方都可以轻易地窃听、篡改或伪造通信内容，给用户隐私和数据安全带来巨大风险。 HTTPS (Hypertext Transfer Protocol Secure) 正是为了解决这些问题而诞生的。它是在HTTP的基础上，加上了 SSL (Secure Sockets Layer) 或 TLS (Transport Layer Security) 协议，为网络通信提供加密、身份验证和数据完整性保护。其核心目标是确保用户与网站之间的通信是私密、安全和不可篡改的。 HTTPS的安全性主要由SSL/TLS协议提供。SSL/TLS协议位于应用层 (HTTP) 和传输层 (TCP) 之间，为上层应用提供加密和认证服务。 SSL/TLS 协议SSL/TLS协议是HTTPS的核心组件，TLS是SSL的升级版本。它们提供三项基本服务： **加密 (Encryption)**：确保数据在传输过程中不被窃听。通过对称加密和非对称加密结合使用，对传输的数据进行加密，即使数据被截获，没有密钥也无法解密。 **身份验证 (Authentication)**：确保客户端连接的是预期的服务器，防止中间人攻击。通过数字证书来验证服务器的身份。服务器也可以配置为验证客户端身份（双向认证）。 **数据完整性 (Data Integrity)**：确保数据在传输过程中未被篡改。通过消息认证码（MAC）或哈希函数来校验数据，保证数据在传输过程中没有被修改。 关键技术 **非对称加密 (Asymmetric Encryption)**： 使用一对密钥——公钥 (Public Key) 和 **私钥 (Private Key)**。 公钥可以公开，主要用于加密数据或验证签名；私钥必须保密，主要用于解密数据或生成签名。 特点：加密和解密使用不同的密钥，公钥无法推导出私钥。 主要用于在握手阶段安全地协商对称密钥和验证身份。 **对称加密 (Symmetric Encryption)**： 使用同一把密钥进行加密和解密。 特点：速度快，效率高，适用于大量数据的加密。 挑战：密钥交换的安全性。在HTTPS中，对称密钥是在TLS握手过程中通过非对称加密安全协商的。 **数字证书 (Digital Certificate)**： 由受信任的证书颁发机构 (CA, Certificate Authority) 签发。 包含服务器的公钥、服务器的身份信息（如域名）、CA的数字签名、证书有效期等。 用于验证服务器身份的真实性。 **证书颁发机构 (CA, Certificate Authority)**： 负责签发、管理和撤销数字证书的权威机构。 浏览器和操作系统内置了受信任的CA列表（根证书库）。 **哈希函数 (Hash Function)**： 将任意长度的输入数据映射为固定长度的输出（哈希值或摘要）。 特点：单向性（不可逆）、抗碰撞性 (collision resistance)（难以找到两个不同输入得到相同输出）。 用于验证数据完整性和数字签名。 数字证书生效过程用户访问HTTPS网站时，浏览器通过以下步骤验证证书是否有效： **证书交换 (Certificate Exchange)**： 客户端发起TLS握手：当用户在浏览器中访问HTTPS网址时，浏览器会自动向目标服务器发送一个 Client Hello 消息，启动TLS/SSL握手过程。此消息包含客户端支持的TLS版本、加密套件等信息。 服务器响应并返回证书链：服务器收到 Client Hello 后，会响应 Server Hello 消息（协商确认TLS版本和加密套件），并向客户端发送其服务器证书。通常情况下，服务器还会一并发送中间证书(Intermediate Certificates)，共同组成**证书链 (Certificate Chain)**，将这个打包后的证书链发送给客户端。 **基本验证 (Basic Validation)**： 有效期检查：检查证书是否在其指定的有效期内。 域名匹配：检查证书的 Subject Alternative Name (SAN) 字段（或早期的 Common Name (CN) 字段）是否与用户当前访问的域名一致。 **信任链验证 (Trust Chain Validation)**： 浏览器会从服务器证书开始，逐级验证证书链中的每个证书。 使用上一级证书（中间证书或根证书）的公钥，验证当前证书的数字签名是否有效。 如此层层向上验证，直到验证到根证书 (Root Certificate)。 确认根证书：检查该根证书是否存在于操作系统或浏览器的受信任根证书库中。如果根证书受信任，则整个证书链被认为是可信的。 **吊销状态检查 (Revocation Status Check)**： 浏览器会检查证书是否已被签发机构吊销。主要通过以下方式： **CRL (Certificate Revocation List)**：浏览器下载CA发布的证书吊销列表，检查目标证书序列号是否在列表中。 **OCSP (Online Certificate Status Protocol)**：浏览器实时向CA的OCSP服务器发送查询请求，获取证书的当前状态（有效、吊销或未知）。OCSP Stapling是一种优化，由服务器定期获取OCSP响应并随证书一起发送给客户端，提高效率。 **技术合规性验证 (Technical Compliance Validation)**： 签名算法强度：检查证书使用的签名算法（如RSA密钥长度至少2048位、ECDSA算法）是否符合当前的安全标准。强度不足的证书可能会被拒绝或收到警告。 **密钥用途 (Key Usage)**：检查证书的密钥用途扩展字段是否表明该证书可用于服务器身份验证（如 TLS Web Server Authentication）。 扩展字段合规性：检查其他必要的扩展字段（如 Basic Constraints）是否正确配置。 生效流程示例总结 客户端发起请求：用户在浏览器输入HTTPS开头的域名并访问。 服务器返回证书：服务器将其终端实体证书 (End-entity Certificate) 以及必要的中间证书链发送给客户端。 客户端验证证书链： 检查终端证书是否由中间证书A签发。 检查中间证书A是否由中间证书B（或根证书）签发。 以此类推，直至根证书。 检查根证书是否被本地操作系统或浏览器信任。 检查吊销状态：通过OCSP或CRL确认证书链中的所有证书均未被吊销。 域名匹配与有效期：确认证书中的域名与访问域名一致，且证书在有效期内。 建立加密连接：所有验证通过后，客户端信任服务器身份。随后，客户端和服务器使用非对称加密（通常利用证书中的公钥）安全地协商出一个对称密钥，之后的所有HTTP通信都将使用此对称密钥进行加密，开始安全的加密通信。 CSR, CRT, PEM 文件在处理SSL/TLS证书时，会遇到以下常见文件类型： **CSR (Certificate Signing Request - 证书签发请求)**： 这是一个包含了服务器公钥、组织信息（如域名、公司名称、城市等）以及一些可选属性（如电子邮件地址）的文件。 在向CA申请数字证书之前，由服务器管理员生成此文件，并将其提交给CA。 CA使用CSR中的信息来创建并签署数字证书。 **CRT (Certificate - 证书文件)**： 通常指由CA颁发的数字证书本身，扩展名常为 .crt，也可能是 .cer。 这是一个符合 X.509标准格式的文件，包含了服务器的公钥、服务器身份信息、CA的数字签名、证书有效期、颁发者信息等。 服务器将此文件（通常与中间证书一起构成证书链）配置好，以便客户端可以验证。 **PEM (Privacy Enhanced Mail)**： 这是一种基于Base64编码的文本文件格式，用于存储和传输各种密码学相关信息，如证书、私钥、公钥、CSR等。 PEM文件通常以 -----BEGIN CERTIFICATE-----、-----BEGIN PRIVATE KEY----- 等页眉开始，并以相应的 -----END ...----- 页脚结束。 .crt 文件和私钥文件 (如 .key) 经常以PEM格式存储。 部署 (Nginx 示例)通常使用Web服务器（如Nginx、Apache）进行HTTPS证书的部署。以下是一个Nginx的配置示例： 首先，将您的私钥文件（例如 your_domain.key）和CA颁发的证书文件（通常是一个包含了服务器证书及所有中间证书的捆绑文件，例如 your_domain_bundle.crt）放置在Nginx可以访问的一个安全目录中（例如 /etc/nginx/ssl/）。 然后，修改Nginx的站点配置文件（通常位于 /etc/nginx/sites-available/your_domain.conf 或 /etc/nginx/conf.d/your_domain.conf）。 在 server 块中，添加或修改SSL相关配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657server { listen 443 ssl http2; # 监听 443 端口，启用 SSL 和 HTTP/2 listen [::]:443 ssl http2; # 同样为 IPv6 监听 server_name your_domain.com www.your_domain.com; # 您的域名 ssl_certificate /etc/nginx/ssl/your_domain_bundle.crt; # 指向您的服务器证书和中间证书链的合并文件 ssl_certificate_key /etc/nginx/ssl/your_domain.key; # 指向您的私钥文件 # SSL/TLS 协议版本 ssl_protocols TLSv1.2 TLSv1.3; # 推荐只启用安全的 TLS 1.2 和 TLS 1.3 # 加密套件配置 # 对于 TLS 1.2，可以指定如下的强加密套件列表 ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384'; # TLS 1.3 的加密套件由 OpenSSL 库（Nginx 使用的）默认处理，通常包含: # TLS_AES_256_GCM_SHA384, TLS_CHACHA20_POLY1305_SHA256, TLS_AES_128_GCM_SHA256 # 如需显式控制 TLS 1.3 ciphers, 可使用 ssl_conf_command Ciphersuites &lt;cipher_list&gt;; ssl_prefer_server_ciphers off; # 对于 TLS 1.3 和 HTTP/2, 推荐设置为 off，允许客户端选择最优套件 # SSL 会话优化 ssl_session_timeout 1d; # 会话缓存超时时间 ssl_session_cache shared:SSL:10m; # 会话缓存大小 (10MB 约可存 40000 个会话) ssl_session_tickets off; # 考虑禁用 session tickets 如果有前向保密性的严格要求或使用不当的风险 # OCSP Stapling 配置 (提高证书状态检查效率) ssl_stapling on; # 启用 OCSP Stapling ssl_stapling_verify on; # 验证 OCSP 响应的有效性 resolver 8.8.8.8 8.8.4.4 valid=300s; # 配置 DNS 解析器，用于 OCSP Stapling (示例为Google Public DNS) resolver_timeout 5s; # HSTS (HTTP Strict Transport Security) - 推荐启用，强制客户端使用HTTPS # add_header Strict-Transport-Security &quot;max-age=63072000; includeSubDomains; preload&quot; always; # 其他安全头部 (可选，但推荐) # add_header X-Frame-Options DENY; # add_header X-Content-Type-Options nosniff; # add_header X-XSS-Protection &quot;1; mode=block&quot;; # add_header Referrer-Policy &quot;strict-origin-when-cross-origin&quot;; # 可选：将所有 HTTP 流量重定向到 HTTPS (在另一个 server 块中配置) # server { # listen 80; # listen [::]:80; # server_name your_domain.com www.your_domain.com; # return 301 https://$host$request_uri; # } location / { # 您的网站文件根目录或反向代理配置 root /var/www/your_domain.com/html; index index.html index.htm; # หรือ proxy_pass http://backend_server; } # 其他配置...} 注： 80 端口是 HTTP 的默认端口，443 端口是 HTTPS 的默认端口。当用户通过浏览器访问这些服务时，如果使用的是默认端口，则端口号通常会在URL中被省略，这对用户更加友好。 Nginx配置中的 ssl_ciphers 主要影响 TLS 1.2 及更早版本。TLS 1.3 的加密套件选择机制有所不同，通常由底层的SSL/TLS库（如OpenSSL）管理，且可选项更少、更安全。 上述Nginx配置是一个基础示例，实际部署时可能需要根据具体需求和安全最佳实践进行调整（例如，HSTS, 更详细的安全头部等）。","link":"/2024/06/06/Https%E8%A7%A3%E6%9E%90/"},{"title":"R语言基础语法","text":"R语言数据结构包含:向量(vector), 矩阵(matrix), 数组(array), 数据框(data frame), 列表(list). [索引从1开始] 基本向量类型六种:逻辑型(logical),整数型(integer), 实数型(double),复数型(complex),字符型(string//character), 字节型(raw).可以通过typeof(),mode(),storage.mode()查看其向量的类型 只含有一个元素的向量是标量(标量只有大小没有方向,矢量既有大小又有方向) cbind(),rbind()区别:cbind:根据列进行合并,叠加所有列.[前提行数必须相同,cbind(a,b)] {column} rbind:根据行进行合并,叠加所有行.[前提列数必须相同,rbind(a,b)] {row} methods():methods:查看其特定的类可以由哪些函数处理. eg:methods(class=lm) identical():判断向量是否相等,返回布尔值, identical(x,y). which():获取向量元素下标 which.max(),which.min(),which(a==3) 12345678910111213141516171819202122232425262728293031323334353637381. # 新建数组 2. a=c(1,3,4,5,3,2,5,6,3,2,5,6,7,5,8) 3. 4. # 取数组a中最大值的下标 5. which.max(a) 6. 7. # 取数组a中最小值的下标 8. which.min(a) 9. 10. # 取数组a中大于3值的下标 11. which(a&gt;3) 12. 13. # 取数组a中等于3值的下标 14. which(a==3) 15. 16. # 10到1的数组元素中在a中的元素的下标 17. b &lt;- which(10:1 %in% a) 18. b 19. [1] 3 4 5 6 7 8 9 10 c函数:c函数:用于合并一系列数字从而形成向量,数列[英文全拼:concatenate(把’’’连接在一起)] names():给向量的元素命名,eg:names(score)&lt;-c(“A”,”B”,”C”,”D”) 向量 seq创建向量: seq(begin=1,end=3,by=2) #间隔等于2 矩阵 矩阵生成: matrix(data= NA,nrow=1,ncol=1,byrow=FALSE,dimnames =NULL); [byrow是否按行填充矩阵,dimnames维度名称] x&lt;-matrix(c(1:12),nrow=3,ncol=4,byrow=TRUE) t(): 矩阵转置. 选取: 选取单个元素: x[2,4] 选取一行元素:x[2,] 选取多行多列元素:x[c(2,4),c(2,3)] 剔除矩阵的某行/某列元素: x[-1] #剔除第一行元素,同样适用于向量 x[-1,-2] #剔除第一行第二列的元素 行列命名: rownames(matrix) #查看矩阵行名称 colnames(matrix) #查看矩阵列名称 rownames&lt;-c(LETTERS[1:5]) #A-E为行命名 还可以通过行列名称选取相应值: x[‘A’,’B’]; dim()返回各个维度的最大值.数据框: data.frame()123456789observation&lt;-c(1:6)birthday&lt;-c(&quot;1/2&quot;,&quot;3/2&quot;,&quot;6/2&quot;,&quot;8/2&quot;,&quot;9/5&quot;,&quot;8/7&quot;)gender&lt;-c('M','M','F','F','F','M')weight&lt;-c(8.6,3.2,4.6,3.1,5.6,42.2)height&lt;-c(78,32,31,51,53,31)bloodtype&lt;-c('A','B','C','AB','O','A')breastmilk&lt;-c(TRUE,FALSE,TRUE,FALSE,TRUE,FALSE)bady&lt;-data.frame(observation,birthday,gender,weight,height,height,bloodtype,breastmilk)bady # 访问数据框中的特定变量:例如选取生日和身高的数据: bady[,c(2,5)] 或者通过变量名称获取:bady[c(‘birthday’,’height’)] ||bady[c(2,5),] bady$observation: $ 选择结果转换为向量式,从而可以绘图或计算 summary(bady$height) #计算 plot(bady$observation,bady$height,type=’h’,lwd=5,xlab=’observation’,ylab=’height(cm)’,ylim= c(60,75),main=’身高数据’) #绘图 使用$比较繁琐,也可以使用 attach()#添加数据框到R语言的查询路径123456 detach() #解除添加两个函数要成对出现` . 因子(factor) 因子是R语言中较重要的向量对象(类别变量),eg: Grade:A,B,C,D,E,F factor(x=character(),levels(),labels=levels,exclude=NA,ordered = is.ordered(x),nmax=NA) # x:向量,levels: 指定因子的水平值,ordered: 是否对因子的水平值进行排序,nmax: 水平值的上界,labels为levels添加标签,未包含于levels中需剔除的值 factors默认按字母顺序对应水平顺序 列表 list列表是一种复杂的数据结构,可以包含不同类型的元素(向量,矩阵,数组,数据框,其他类型的列表).是由一些对象的有序结合构成的对象,每个对象成为列表的分量(components),它们的长度和类型可以不相同.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&gt; student&lt;-c(&quot;John&quot;,&quot;Peter&quot;)&gt; subject&lt;-c(&quot;Math&quot;,&quot;Reading&quot;,&quot;History&quot;,&quot;Physics&quot;,&quot;Economics&quot;)&gt; listOne&lt;-list(subject,student)&gt; listOne[[1]][1] &quot;Math&quot; &quot;Reading&quot; &quot;History&quot; &quot;Physics&quot; &quot;Economics&quot;[[2]][1] &quot;John&quot; &quot;Peter&quot;&gt; listOne&lt;-list(subjectNames=subject,studentNames=student) #分别对两个对象进行命名&gt; listOne$subjectNames[1] &quot;Math&quot; &quot;Reading&quot; &quot;History&quot; &quot;Physics&quot; &quot;Economics&quot;$studentNames[1] &quot;John&quot; &quot;Peter&quot;&gt; score&lt;-matrix(c(95,80,60,72,84,58,32,65,43,49),nrow = 5,ncol = 2,dimnames = listOne) #列表对维度命名&gt; score studentNamessubjectNames John Peter Math 95 58 Reading 80 32 History 60 65 Physics 72 43 Economics 84 49&gt; x&lt;-data.frame(score,gradeJohn=factor(c(&quot;A&quot;,&quot;B&quot;,&quot;D&quot;,&quot;C&quot;,&quot;B&quot;)),gradePeter=factor(c(&quot;B&quot;,&quot;D&quot;,&quot;D&quot;,&quot;D&quot;,&quot;D&quot;)))&gt; listTwo&lt;-list(title=&quot;The Exam Results&quot;,listOne,x)&gt; listTwo$title[1] &quot;The Exam Results&quot;[[2]][[2]]$subjectNames[1] &quot;Math&quot; &quot;Reading&quot; &quot;History&quot; &quot;Physics&quot; &quot;Economics&quot;[[2]]$studentNames[1] &quot;John&quot; &quot;Peter&quot;[[3]] John Peter gradeJohn gradePeterMath 95 58 A BReading 80 32 B DHistory 60 65 D DPhysics 72 43 C DEconomics 84 49 B D&gt; listTwo[[2]]$subjectNames[1] &quot;Math&quot; &quot;Reading&quot; &quot;History&quot; &quot;Physics&quot; &quot;Economics&quot;$studentNames[1] &quot;John&quot; &quot;Peter&quot;&gt; listTwo[[2]]$subjectNames[1] &quot;Math&quot; &quot;Reading&quot; &quot;History&quot; &quot;Physics&quot; &quot;Economics&quot;&gt; listTwo$subjectNamesNULL 时间序列时间序列是特殊的矩阵或向量,由函数ts()创建,一元时间序列默认值 ts,多元时间序列默认值c(“mts”,”ts”) ,ts(data=NA,start=1,end=numeric(),frequency=1,deltat=1,ts.eps=getOption(&quot;ts.eps&quot;),class= ,names=) 123456789101112131415161718192021222324252627282930313233343536&gt; ts1&lt;-ts(1:10,2010,frequency=1)&gt; ts1Time Series:Start = 2010 End = 2019 Frequency = 1 [1] 1 2 3 4 5 6 7 8 9 10&gt; ts2&lt;-ts(1:36,frequency=12,start=c(2010,3))&gt; ts2 Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec2010 1 2 3 4 5 6 7 8 9 102011 11 12 13 14 15 16 17 18 19 20 21 222012 23 24 25 26 27 28 29 30 31 32 33 342013 35 36 &gt; ts3&lt;-ts(matrix(rnorm(24),8,3),start=c(2010,1),frequency = 4) #rnorm生成随机数&gt; ts3 Series 1 Series 2 Series 32010 Q1 -2.53265150 0.06600203 -0.95065402010 Q2 0.05894453 -0.84349820 -0.17655232010 Q3 -0.47160257 -1.52484881 0.32531432010 Q4 -0.68957525 0.12292570 0.42694422011 Q1 -2.47980475 0.59243573 -1.77352542011 Q2 -2.28164139 1.02340819 -0.71885062011 Q3 -1.14978250 -0.36354444 0.81437952011 Q4 0.20981269 0.37868089 -1.4009437&gt; ts3&lt;-ts(matrix(rnorm(24),8,3),start=c(2010,1),frequency = 4,names=c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;))&gt; ts3 A B C2010 Q1 -0.734254773 0.03228792 -0.8399690642010 Q2 0.190277060 -0.37829225 0.8963526192010 Q3 0.007298513 0.10820272 -0.1407952782010 Q4 0.376817757 -1.10836939 -0.4294747692011 Q1 -1.099760283 0.64250578 0.0037840242011 Q2 -0.563540402 -0.69517193 -1.0731606252011 Q3 -0.899862468 -0.23836692 -0.8667856602011 Q4 -0.668345051 -0.49486593 0.167862363 数据载入 从外部获取数据123456789101112read.csv()read.csv(file,header=TRUE,sep=&quot;,&quot;,quote=&quot;\\&quot;,dec=&quot;.&quot;,fill=TRUE,comment.char=&quot;&quot;,...)#header首行是否为字段名,默认为TRUE,#sep字段的分隔符,默认为逗号#quote指定字段的分隔符#dec指定表示小数点的字符#fill文件中是否忽略了行尾的字段#comment.char表示注释符,默认为#,如果文件中没有注释,采用默认的 comment.char=&quot;&quot; 即可read.table()扩展包gdata中的read.xls()函数扩展包RODBC中的相关函数扩展包foreign中的相关函数 数据输出数据管理 访问数据123&gt; x&lt;-seq(1,100,2) #访问向量元素&gt; x[10][1] 19 字符串的处理12345678- 字符串连接: paste()函数,paste(...,sep='',collapse=NULL)(1) ...表示一个或多个R对象,paste()函数将对象首先处理成字符串,然后再相互组合(2)sep表示用于连接字符的自定义分隔符,例如空格、$、等等，默认为空格(3)collapse参数为可选项，指定collapse参数时，会按照该参数值在之前组合的字符串基础上，再通过collapse参数进行分割，形成单独的长字符串，而非向量。eg:&gt; x&lt;-paste(LETTERS[1:6],letters[1:6],sep=&quot;#&quot;,collapse = &quot;&amp;&quot;)&gt; x[1] &quot;A#a&amp;B#b&amp;C#c&amp;D#d&amp;E#e&amp;F#f&quot; 123456789101112131415161718192021222324- 字符串拆分 strsplit(x,spilt,fixed=FALSE,perl=FALSE,useBytes=FALSE)(1)x：字符串向量，strspilt()函数依次对向量中每个元素进行拆分。(2)spilt:指定处在拆分位置上的字符串，即在那个字符串处进行拆分，(3)fixed:用普通文本匹配还是用正则表达式进行匹配。默认正则匹配(4)perl:表示使用perl语言的正则表达式，默认FALSE(5)useBytes：表示是否按字节进行匹配，默认为FALSE,表示按照字符而不是字节进行匹配。strsplit()函数返回列表，unlist()函数将列表转换为字符串向量eg:&gt; year&lt;-c(&quot;1990-1995&quot;,&quot;1996-2000&quot;,&quot;2001-2005&quot;)&gt; splityear&lt;-strsplit(year,split=&quot;-&quot;)&gt; splityear[[1]][1] &quot;1990&quot; &quot;1995&quot;[[2]][1] &quot;1996&quot; &quot;2000&quot;[[3]][1] &quot;2001&quot; &quot;2005&quot;&gt; unlist(splityear)[1] &quot;1990&quot; &quot;1995&quot; &quot;1996&quot; &quot;2000&quot; &quot;2001&quot; &quot;2005&quot;&gt; 12345678boxplot绘制箱线图boxplot(x, ..., range = 1.5, width = NULL, varwidth = FALSE,notch = FALSE, outline = TRUE, names, plot = TRUE,border = par(&quot;fg&quot;), col = NULL, log = &quot;&quot;, pars = list(boxwex= 0.8, staplewex = 0.5, outwex = 0.5), horizontal = FALSE,add = FALSE, at = NULL)#参数x为要绘制的数据,range控制点线延伸的长度,默认值为上下四分位数只差的1.5倍,在触须延伸终点#绘制横截线,outline表示是否绘制异常值,horizontal控制是否以水平或垂直于坐标轴的方式绘制箱线图 12四分位数:异常值计算方法:大于上四分位数的1.5倍分散度的值,或小于下四分位数1.5倍分散度的值,对于1.5至3倍分散度的异常值,用空心圆点表示,对于超出分散度三倍的异常值作为极端异常值处理,用实心圆点表示 12345678910111213141516171819散点图：plot()函数绘制分组数据的散点图饼图：pie(x, labels = names(x), edges = 200, radius = 0.8,clockwise = FALSE, init.angle = if(clockwise) 90 else 0,density = NULL, angle = 45, col = NULL, border = NULL, lty =NULL, main = NULL, ...)（1）x为向量，其元素为非负的数值型数据，这些数据反映在饼图的对应面积上。（2）labels是表达式或者字符串，用以给数据添加标签。（3）edges用来控制饼图外圈的圆润程度。饼图是由多边形拟合而成的，edges数值越大，饼图的外圈看上去就越圆。（4）radius用来控制饼图的半径，如果给数据添加的标签很长，缩小饼图半径就能够将字符完整显示出来。（5）clockwise用来控制排列顺序，即顺时针或逆时针方向排列。（6）density用来控制阴影线的密度。（7）angle用以控制阴影线的斜率。（8）col是一个向量，用以填充被分割饼图的每一区域的颜色。（9）main控制图的标题。eg:pie(c(10,20,30,40),col=rainbow(4),labels=c(&quot;10%&quot;,&quot;20%&quot;,&quot;30%&quot;,&quot;40%&quot;),main=&quot;PIE CHART&quot;) 1234567891011121314151617181920柱状图：barplot(height, width = 1, space = NULL, names.arg =NULL, legend.text = NULL, beside = FALSE, horiz = FALSE,density = NULL, angle = 45, col = NULL, border = par(&quot;fg&quot;),main = NULL, sub = NULL, xlab = NULL, ylab = NULL, xlim= NULL, ylim = NULL, xpd = TRUE, log = &quot;&quot;, axes = TRUE,axisnames = TRUE, cex.axis = par(&quot;cex.axis&quot;), cex.names =par(&quot;cex.axis&quot;), inside = TRUE, plot = TRUE, axis.lty = 0,offset = 0, add = FALSE, args.legend = NULL, ...)（1）height是绘图所用到的数据，数据的大小差异体现在柱形的高度上面。如果想要对一组数据进行绘图，则数据以向量方式输入；如果想要对两组以上数据进行绘图，则数据以矩阵方式输入，矩阵每一行代表一组数据。（2）names.arg是图形中绘制于每个柱形下方的名称向量。如果该参数被忽略，则名称就显示为向量所带的名称属性或矩阵的名称列。（3）legend.text用以控制图例。（4）horiz控制柱形（条形）以垂直或水平方式放置。（5）beside控制不同组数据以垂直方式堆积或水平方式并列来进行展示。取FALSE（默认取值）时，不同组的数据以垂直方式堆积展示。 123456789101112131415161718192021222324252627直方图：hist(x, breaks = &quot;Sturges&quot;, freq = NULL, probability = !freq,include.lowest = TRUE, right = TRUE, density = NULL,angle = 45, col = NULL, border = NULL, main =paste(&quot;Histogram of&quot;, xname), xlim = range(breaks), ylim= NULL, xlab = xname, ylab, axes = TRUE, plot = TRUE,labels = FALSE, nclass = NULL, warn.unused = TRUE, ...)（1）x是数值型向量，即所需要绘制直方图的数据集。（2）breaks参数通过以下方式控制直方图的单元（cells）数量：a) 给出一个向量，从而确定直方图单元的区间断点（breakpoints）；b) 给出单个数值，从而确定直方图的单元数量；c) 给出计算区间的算法名称的字符串；d) 一个用于计算单元数量的函数。 （3）freq和probability均为逻辑判断式，且两者为互斥选项，freq=TRUE时做频率图，否则为概率密度图。当probability=TRUE时，所有矩形的面积之和为1。 （4）labels是逻辑值，当labels=TRUE时，将添加相应的数值到矩形单元的上方。 （5）density参数设置填充矩形条的阴影线（shading lines）的密度，度量单位是每英寸填充的线条数。缺省模式下不绘制阴影线。angle参数设定了阴影线的角度。 （6）col参数设定了填充矩形条内部的颜色，当density为正数时，阴影线的颜色由col指定。 （7）border参数设置矩形条边框的颜色，当border=FALSE或NA时，将不绘制边框。 （8）如果想要自己设定坐标，可以使用xaxt=&quot;n&quot;或yaxt=&quot;n&quot;不绘制坐标，然后使用低级绘图命令axis来自定义坐标。 时间序列建模步骤： 目前, 最常用的平稳序列拟合模型是自回归模型 (AR 模 型)、移动平均模型 (MA 模型) 和自回归移动平均模型 (ARMA 模型). 这三类模型都属于有限参数线性模型, arima.sim拟合函数：","link":"/2020/09/14/R%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"},{"title":"Python魔术方法","text":"Python常用的魔术方法有 __init__,对象被创建后调用，用于初始化对象的属性。 __new__,对象被创建之前被调用， __str__,用于打印该对象展示给用户的字符串信息。 __repr__,用于开发调试时，给开发人员看的打印对象的详细信息 __len__,用于获取容器对象的元素个数。 __call__,允许对象像函数一样被调用，可以传递参数。 __iter__,返回一个迭代器，允许对象成为一个可以迭代的容器，常和__next__一起使用，","link":"/2020/04/24/Python%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/"},{"title":"Ubuntu 安装记录","text":"本博文U盘启动方式为UEFI Ubuntu是当今世界最流行的Linux系统之一 桌面环境采用Gnome,界面美观，（也有KDE等） 丰富的软件源，完善的包管理 具备完整的社区支持,许多问题可以通过搜索引擎搜索到已解决的方案 是初入linux的最佳选择之一 下面我们进入主题. 可能出现的问题（解决方案）： 关闭快速存储 关闭快速启动 设置硬盘为AHCI，安装完成后再还原。一、为Ubuntu系统分配硬盘空间 目前市面上笔记本硬盘主要是以下两种， 12345671. 固态(SSD) 如果你的硬盘为单固态,且未使用容量小于50G,基本上无法满足双系统日常使用.推荐加下容量2.机械(HDD)As we all know,HDD的读写速度慢于SSD- 如果读者笔记本是SSD+HDD组合,且固态内存未使用容量小于50G，建议把Ubuntu系统安装在机械盘上 为Ubuntu系统划分硬盘空间(下为图示步骤) ​ 选择有足够空间的磁盘,右键点击新建压缩卷,然后点击确定即可。（如果不把Ubuntu作为主系统使用,70G容量基本够用,此处以100G为例.） 二、制作U盘启动工具磁盘空间分配完成后,下一步用软碟通制作U盘启动工具准备: 一个4G内存且已格式化的U盘（ubuntu20.04系统镜像为2G多，U盘容量需大于镜像文件大小） U盘制作工具, [UltraISO](https://www.ultraiso.com/download.html) ubuntu镜像文件，下载站见下： 123选择版本，本文以20.04为例，18.04同样适用 ，- [官网](https://cn.ubuntu.com/download)- [清华大学镜像站](https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/) 上述下载完成后，便可制作启动U盘,打开UltraISO选择试用即可（Continue to Try） 左键点击文件（File）,单击OPEN,找到ubuntu ISO文件打开 然后点击Bootable,单击Write Disk Image,开始写入镜像，大约需要等待七八分钟， 三、设置启动方式 插入已制作成功的U盘，重启电脑, 开机时，按F2进入Bios界面(品牌不同,快捷键不同,需自行百度)。 调整启动顺序,把USB 选项放在首位(即USB启动),保存重启。 建议在Bios界面关闭安全启动（Secure boot） 四，安装Ubuntu重启后，可看到GRUB引导界面,选择Install ubuntu. 选择语言为中文, 选择最小安装（速度快点 😁） 选择其他选项，自己创建 下面开始为Ubuntu分区，在分区之前，先简略介绍一下各分区的作用 12345678910111213141516171根分区 根分区就是root分区，所有的东西都在这个分区内2/swap分区 /swap分区是交换分区，划分比内存大2倍 保证在编译过程中资源不会耗尽,是一定磁盘空间（分区或文件），用于将部分内存中的数据换下来，以腾出内存空间用于其他需求。在一个系统中，物理内存快使用完时，操作系统会使用交换分区。当系统内存紧张时，操作系统根据一定的算法规则，将一部分最近没使用的内存页面保存到交换分区，从而为需要内存的程序留出足够的内存空间.3/boot分区 它包含了操作系统的内核和在启动系统过程中所要用到的文件4/usr分区 是Linux存放软件的地方5/home分区 是用户的home目录所在地，这个分区的大小取决于有多少用户，如果是多用户共同使用同一台电脑，这个分区是完全有必要的，况且根用户也可以很好的控制普通用户使用计算机，如对用户或者用户组实行硬盘限量使用，限制普通用户访问那些文件等。6/tmp分区 用来存放临时文件， 博主建议划分swap分区与根分区(/ )及home分区,swap分区大小设置为本机内存的两倍，然后把剩余区间全部划分给根目录与home目录（如果作为主力系统，home分区不建议小于50G） swap分区选则用于交换空间 根目录选择Ext4文件系统，挂载点选/不同文件系统区别自行百度。 最后等待漫长的安装过程（约20分钟），完成后,拔下U盘,重启即可进入GRUB引导界面,在下载软件之前，需在软件更新器中更换软件源。如果遇到什么问题可在下方留言，看到会回复。最最后，放一张博主美化好后的界面（仿MAC风格）,美化教程下篇见！","link":"/2020/10/28/Ubuntu%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/"},{"title":"deepin wine QQ汉字显示方块解决方案","text":"simsun字体(宋体)复制到 /usr/share/fonts/目录 1sudo mv simsun.ttf /usr/share/fonts/","link":"/2022/01/03/deepin%20wine%20QQ%E6%B1%89%E5%AD%97%E6%98%BE%E7%A4%BA%E6%96%B9%E5%9D%97%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"deepin wine 微信启动失败解决记录","text":"从命令行启动微信，执行以下命令 12cd /opt/apps/com.qq.weixin.deepin/filessudo ./run.sh 查看启动信息，报错情况如下 12libGL error: No matching fbConfigs or visuals foundlibGL error: failed to load driver: swrast 缺少这个库，继续开启百度之路： 突然想到，上次安装Pytorch时，更换了ubuntu附加驱动为NVIDIA-470,接下来安装470相应的库， 重新启动微信，成功解决","link":"/2021/10/19/deepin%20wine%20%E5%BE%AE%E4%BF%A1%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/"},{"title":"Gitbash_乱码记","text":"更换电脑,重装hexo时,gitbash输出乱码. 系统字符集编码与Gitbash字符集编码不一致,解决方法打开win10语言设置,依次点击下图选项,更改为UTF-8编码,重启电脑即可解决.[吐了,其他软件又乱码了]","link":"/2020/09/14/gitbash-%E4%B9%B1%E7%A0%81%E8%AE%B0/"},{"title":"SQL Server","text":"候选码: 该属性或者属性组可以唯一的标识一个元组,而其子集不能 主码: 若一个关系有多个候选码,则选定其中一个作为主码 全码: 若此关系中,候选码的组成为该关系元组的全集,则称其为全码 外键: 表的外键为另一个表的主键,外键可以重复 ||为空值 主码: 保证数据完整性 外键: 和其它表建立联系 索引: 提高查询排序速度 1234建立索引: CREATE [UNIQUE] [CLUSTER] INDEX&lt;索引名&gt; ON &lt;表名&gt; (&lt;列名&gt; [&lt;次序&gt;] [,&lt;列名&gt;[&lt;次序&gt;]]....) # UNIQUE 此索引的每一个索引值只对应唯一的数据记录# CLUSTER 建立的索引是聚簇索引删除索引: DROP INDEX &lt;索引名&gt; ON &lt;表名&gt;修改索引: ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt; 1234567891011121314GO是批处理的标志，是一条或多条SQL语句的集合，SQL Server将批处理语句编译成一个可执行单元，此单元称为执行计划。GO语句把程序分成一个个代码块，即使一个代码块执行错误，它后面的代码块任然会执行。每个被GO分隔的语句都是独立的事务，一个语句执行失败不会影响其它语句执行：go select * from dbo.XXX go select * from dbo.sales 第一个查询失败了，第二查询的结果依旧会返回也就是说，go前面失败的语句，不影响后面语句的执行。也可以go N select * from dbo.sales N是常数，代表以下语句重复执行N次 ​ 12345678910modify alter不同modify：只能修改字段的属性。alter：除了修改字段属性外，还可以做增加删除操作。二、语法不同1、modify：修改字段名使用：ALTER TABLE [表名] MODIFY [列名] [数据类型]2、alter：数据库SQL语言的修改语句，可以用来修改基本表，表示格式为：ALTER TABLE&lt;表名&gt;[改变方式]。 123关系模式: 对关系的描述. R(U,D,dom,F)#R关系名, U组成该关系的属性名集合,D属性组U中属性来自的域,dom属性向域的映象集合,F属性间的依赖关系集合,简记为 R(U)E-R模型(entity-relationship model),构成成分是实体集,","link":"/2020/09/14/SQL%20Server/"},{"title":"网络协议篇","text":"TCP（Transmission Control Protocol，传输控制协议）是位于OSI模型的传输层的一个核心协议。它通过滑动窗口机制来管理数据包的传输速率，并利用拥塞控制算法来避免网络过载，从而确保数据的可靠传输。TCP支持全双工通信，允许数据在两个方向上同时传输，使得双方可以在保持连接的同时，进行数据的发送和接收。 滑动窗口：是TCP确保数据传输效率和可靠性的关键，可以比喻为一个火车过隧道，隧道（网络带宽）的长度限制了火车（数据包）的数量。当火车成功穿越隧道（数据包确认被接受），新的火车（数据包）就可以进入隧道。这种机制帮助控制数据的流动速度和量，确认网络不会被过量的数据包淹没。 拥塞控制：可以比喻为一个交通灯系统，它监控整个网络的拥塞程度，根据当前网络的用塞成度来调整数据包的发送速率，当网络流量较轻时，它变绿灯允许更多的数据包通过，当网络流量较大时，他变红灯减少发送的数据包量，以防止数据丢失和重传。 TCP三次握手：首先客户端向服务端发送SYN（同步序列编号）报文，表示客户端希望开始通信，服务端收到报文后，回复ACK和SYN（确认应答和同步序列编号）的报文，即确认了收到了SYN报文，也表明服务端准备好通信，进入SYN_RECEIVED状态，客户端收到报文后，进入ESTABLISHED状态，向服务端发送ACK（确认应答）报文，确认收到了服务端的同步请求。这一系列交换完成后，客户端和服务端就可以正式开始通信，传输数据了。 TCP三次握手用于在客户端和服务端建立可靠连接，以便进行数据传输，这个过程包含以下三个步骤： 第一步：客户端发送一个SYN（同步序列编号）报文到服务端，携带客户端的初始序列号（比如100），表示客户端希望与服务端建立连接。可以比喻为打电话给服务端，并告知“我想开始通话，并从编号100开始计数” 第二步：服务端收到该SYN报文后，会向客户端发送ACK报文确认客户端的序列号（确认编号100+1），同时发送自己的SYN报文，包含服务端的初始序列号（比如300），准备好接受客户端从编号100开始的数据，并告知自己从300开始计数，表明服务端准备好开始通信。可以比喻为服务端回应：“我明白你从100开始计数，我也准备好了，从300开始计数” 第三步：客户端收到服务端发来的ACK和SYN报文后，发送一个ACK报文和序列号301作为回应，确认了服务端的序列号300。表示客户端准备好接受从编号300开始的数据。此时，标志着双方已准备就绪，可以比喻为：“好的，从你的300开始计数，我们可以开始通话了” TCP四次挥手用于在客户端和服务端终止数据传输，关闭连接时，包含以下四个步骤： 第一步：客户端向服务端发送一个FIN报文，序列号为100，表明客户端已经没有数据发送了，希望终止连接。可以类比为电话通话中说：“我说完了，准备挂电话” 第二步：服务端收到FIN报文后，向客户端发送确认号为101的ACK报文作为回应，确认收到客户端的终止请求。此时，服务端可能还有数据等待发送，所以连接的这一方向不能立即关闭。可以类比为通话中的回应：“我知道你说完了，但请让我说完我的部分” 第三步：服务端向发送完所有待处理的数据后，向客户端发送一个FIN报文序列号为300，表示服务端的数据已经传输完毕了，可以终止该连接。可以类比为通话中：“我的话也说完了，可以挂断电话了” 第四步，客户端收到FIN报文后，向服务端发送确认号为301的ACK报文作为回应，确认了服务端的终止请求。在发送完这个报文后，客户端会进入一个等待状态（TIME_WAIT）,等待两倍的报文最大生存时间，以确保服务端收到了这个报文，并允许网络中延迟的任何报文到达，然后彻底关闭连接。可以类比为：“我知道你也说完了，我要等一会确保没有消息遗漏，然后挂断” UDP:UDP是一种位于传输层的全双工通信协议，它的无连接性质意味着数据包可以在不建立连接的情况下直接发送至接收方，从而降低了数据传输的延迟。然而，这种协议不保证数据包的顺序或确切到达，且不会对丢失的数据包进行重发，使其在需要实时性高于可靠性的应用场景中，如视频流、在线游戏和VoIP，表现出独特的优势。","link":"/2020/04/08/TCP%20IP/"},{"title":"Python迭代器与生成器","text":"Python 迭代器和生成器Python 中的迭代器和生成器是用于处理可迭代对象的强大工具。它们有一些共同点，但也有一些重要的区别。 迭代器（Iterators）： 迭代器是可迭代对象的一个子集。 它是一个可以记住遍历位置的对象。 迭代器需要实现 __iter__() 和 __next__() 方法。 使用 iter() 方法可以将列表、元组、集合、字符串等可迭代对象转换为迭代器。 通过调用 next() 方法逐个访问元素。 不能通过索引来访问生成器的元素。 当没有更多元素可迭代时，next() 方法会引发 StopIteration 异常。 1234567891011121314# 创建一个可迭代对象（列表）my_list = [1, 2, 3, 4, 5]# 使用iter()方法将可迭代对象转换为迭代器my_iterator = iter(my_list)# 使用next()方法逐个访问迭代器的元素try: while True: element = next(my_iterator) print(element)except StopIteration: pass 在这个示例中，将列表my_list转换为迭代器my_iterator，然后使用next()方法逐个访问迭代器的元素。当没有更多的元素可迭代时，next()方法会引发StopIteration异常，我们通过异常处理来结束循环。 生成器（Generators）： 生成器是一种特殊的迭代器。 使用 yield 关键字替代 return 返回值，将函数变成生成器对象。 生成器不会一次性生成所有值，而是按需生成每个值，这可以节省内存。 生成器只能被迭代一次，一旦耗尽，需要重新创建或重新初始化才能再次迭代。 不能通过索引来访问生成器的元素。 生成器是生成元素的，迭代器是访问集合元素的一种方式。 1234567891011121314151617# 创建一个生成器函数def my_generator(): yield 1 yield 2 yield 3# 使用生成器函数创建生成器对象gen = my_generator()# 迭代生成器并按需生成值for value in gen: print(value)# 尝试再次迭代，会发现生成器已经耗尽for value in gen: print(value) # 不会打印任何内容，因为生成器已经耗尽 迭代器用于按需访问集合元素，而生成器用于按需生成元素","link":"/2020/04/24/Python%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"},{"title":"博客加设coding平台记录","text":"起初博客放在github上,但是github有时访问不了(没买梯子emmm,改过hosts文件),后来转到了码云,(为什么转码云呢?因为码云快呀),但码云有点神经呀,绑定域名另外收费,我可以理解，但每次推送代码后都要我手动去执行下更新操作,我想不通.果断换coding coding现在騰訊旗下,部署个静态网站是真的麻烦,实名认证,绑定微信,绑定邮箱….一系列操作, 找静态部署费了好长时间,需要在团队管理处手动开启 绑定域名,需要用腾讯的CDN,意料之中,赠送了六个月的,每个月20G流量,对于我的小破站来说足够用了,不知道是只赠送六个月还是…,如果收费,俺就不绑定域名了. ssl证书,这个申请时间大约要四五天,之后添加解析记录. 其次问题就来了,浏览器提示证书无效,好吧,先把博客文件里的http换成https,再次推送,证书有效了,还是提示不安全,把仓库内容全删掉,再次推送,hexo clean 终于提示安全了. （最终，种种原因，我又换回GitHub了）","link":"/2020/10/16/blog%E8%AE%BEcoding%E5%B9%B3%E5%8F%B0/"},{"title":"Python 整数缓存机制","text":"首先在终端中输入python，打开解释器，输入以下测试代码： 1234&gt;&gt;&gt; number1 = 256&gt;&gt;&gt; number2 = 256&gt;&gt;&gt; number1 is number2True 1234&gt;&gt;&gt; number1 = 257&gt;&gt;&gt; number2 = 257&gt;&gt;&gt; number1 is number2False 在上述代码中，我们观察到不同的结果。这是由于 Python 的整数对象缓存机制。对于较小的整数（通常范围在 -5 到 256 之间），它们在解释器启动时会被预先创建，并且在整个程序执行期间会重用相同的对象。这意味着当我们使用相同的整数值创建变量时，它们实际上指向相同的对象，因此身份比较结果为 True。然而，对于较大的整数，缓存机制不适用，每次创建的对象都是独立的。 另外，在执行以下代码时，结果为 True。这是由于 Python 解释器的优化策略，它会预先创建并重用一些较大的整数对象，以减少内存消耗。因此，当我们使用相同的整数值创建变量时，它们可能会指向同一个对象，使得身份比较结果为 True。 1234&gt;&gt;&gt; number1 = 257&gt;&gt;&gt; number2 = 257&gt;&gt;&gt; number1 is number2True 然而，在使用 PyCharm 编辑器时，执行以下代码会返回 True。这是由于 PyCharm 编辑器可能对一些整数对象进行缓存或共享，以提高性能和减少内存消耗。这导致使用相同的整数值创建的多个变量指向相同的对象，使得身份比较结果为 True。 1234&gt;&gt;&gt; number1 = 25777777&gt;&gt;&gt; number2 = 25777777&gt;&gt;&gt; number1 is number2True 综上所述，整数对象的缓存机制和身份比较在 Python 中是一项优化策略，旨在提高性能和减少内存消耗。然而，其行为可能因解释器、环境和整数值的大小而有所不同。因此，在编写代码时，应尽量避免依赖整数对象的身份比较，而是使用相等性比较来判断整数值是否相等。","link":"/2020/04/24/python%E6%95%B4%E6%95%B0%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"},{"title":"pyecharts库只能识别int类型的整型数据","text":"数据类型不匹配：pyecharts库只能识别int类型的整型数据。但是pandas结果数据一般是numpy.int类型，pyecharts无法识别，导致数值数据变成null。","link":"/2020/04/24/pyecharts%E5%BA%93%E5%8F%AA%E8%83%BD%E8%AF%86%E5%88%ABint%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B4%E5%9E%8B%E6%95%B0%E6%8D%AE/"},{"title":"Python 下划线","text":"单个前导下划线： 用于表示该变量是模块内部使用的，作为约定，告诉其他开发者这不是公共接口的一部分，不建议直接访问 123456class MyClass: def __init__(self): self.public_variable = 42 self._protected_variable = 'protected data'obj = MyClass()print(obj._protected_variable) # 输出： protected data 单个末尾下划线 避免与Python关键字或者内置函数名命名冲突时，可以使用单个末尾下划线来重命名变量,如class_可以避免与class冲突 class_ = 'test' print(class_) # 输出: test ------------------------------ class= 'test' File &quot;&lt;stdin&gt;&quot;, line 1 class= 'test' ^ SyntaxError: invalid syntax 双前导下划线 名称修饰，保护父类属性的访问，防止子类属性覆盖父类属性，访问方法obj._类名__属性名 123456789101112131415161718class Parent: def __init__(self): self.__x = 10 # 使用双前导下划线命名属性class Child(Parent): def __init__(self): super().__init__() self.__x = 20 # 子类定义相同名称的属性parent = Parent()child = Child()print(parent.__dict__) # 输出 {'_Parent__x': 10}print(child.__dict__) # 输出 {'_Parent__x': 10, '_Child__x': 20}print(parent._Parent__x) # 输出 10print(child._Child__x) # 输出 20 双前导和双末尾下划线 用于标识特殊方法（魔术方法）,如 __init__（构造方法）、__str__（字符串表示方法）。 预定义的特殊名称，如，__name__ 是一个包含当前模块名称的特殊变量。__file__ 包含当前模块的文件路径。 1234567891011class MyClass: def __init__(self): self.__count__ = 0 def __str__(self): return f&quot;MyClass instance with count: {self.__count__}&quot;if __name__ =='__main__': # 预定义的特殊名称 obj = MyClass() obj.__count__ = 5 # 使用末尾下划线的特殊变量 print(obj) # 输出 &quot;MyClass instance with count: 5&quot; 单个下划线： 用来表示无关紧要的变量 12for _ in range(5): print('test') 在交互式解释器中，_指向最后一次执行的表达式结果 1234+87+9_ # 输出16","link":"/2020/04/24/python-%E4%B8%8B%E5%88%92%E7%BA%BF/"},{"title":"会者定离，一期一祈。","text":"每一次相遇皆是缘分,可遇而不可求有些事错过了就是错过了.静下心来,仔细回顾,终是我不够勇敢,过于求稳,倘若我坚定一点,很多事情应该可以做得更好,至少不会像现在一般遗憾吧.已往之不谏,来者仍可追!感谢遇见!","link":"/2020/04/08/%E4%BC%9A%E8%80%85%E5%AE%9A%E7%A6%BB%EF%BC%8C%E4%B8%80%E6%9C%9F%E4%B8%80%E7%A5%88/"},{"title":"关键词提取算法","text":"关键词是揭示文档核心主题的最小语义单元，对于理解文本内容至关重要。关键词自动抽取技术致力于自动识别和提取这些具有高度意义和代表性的词汇或短语，实现了自动化的关键词识别过程。在文本挖掘领域，这一技术被称为关键词抽取（Keyword Extraction），而在信息检索领域，它通常被称作自动标引（Automatic Indexing）。关键词提取作为文献检索、自动摘要、文本分类、推荐系统等多个领域的关键任务，为这些应用提供了基础性的支持。 在传统的中文文本处理领域，目前主要采用以下三种算法进行关键词提取： TF/IDF算法：评估词汇在文档中的重要性与其在语料库中的常见程度的反比。 TextRank算法：一种基于图的排序算法，通过文档内部的词汇相互作用来确定关键词的重要性。 LDA算法：一种主题模型，它假设文档是从隐含主题的混合中生成的，通过这种方式抽取具有代表性的关键词。 TF/IDF算法预处理：首先，需要对文档进行分词，将文本分解为单个词汇，并去除那些常见但对主题贡献不大的词汇，比如“的、吗、首先、然后”等停用词。这是为了减少噪音，确保算法专注于那些具有实际意义的词汇。 词频（TF）计算：接下来统计每个词在文章中出现的频率，即该词出现次数除以文档的总词数。这个比例反映了词在文档中的重要性，但不能反映词汇的独特性或在整个语料库中的分布情况。 逆文档频率（IDF）计算：逆文档频率用来衡量词汇的罕见程度，通过对语料库中包含该词文档的数量取倒数并进行对数变换来计算，公式为 IDF = log(语料库的文档总数 / 包含该词的文档数 + 1)。这样做是为了提升那些在少数文档中出现但给出大量信息的词的重要性。 计算TFIDF值：最后将每个词的TF值乘以其IDF值得到TF/IDF值。这个值越高，词在文档中的重要性越大。 TextRank算法TextRank算法是一个基于图的排名算法，广泛应用于关键词提取和文本摘要任务中。其核心思想是利用文本内部词语之间的共现关系来评估每个词语的重要性。在这个过程中，每个词语被视为图中的一个节点，而词语之间的共现关系则形成节点间的连接边。 预处理阶段首先，对文档进行预处理，包括分词和去除停用词。分词是将文本分解为单独的词汇单元，而去除停用词（如“的”、“吗”、“然后”等）旨在消除那些虽频繁出现但对理解文档主题贡献较小的词汇。这一步骤帮助减少图中的节点数量，确保算法能更有效地聚焦于那些具有实际意义的词汇。 构建图接下来，构建一个图，其中的节点代表文档中的词语或短语，边代表它们之间的共现关系。这里的“共现”指的是两个或多个词汇在文本中一定窗口大小范围内同时出现的情况，而边的权重通常反映了共现的频次。通过这种方式，图形象地表示了文本中词语的相互关联和相对重要性。 在构建图的过程中，统计共现情况是关键步骤之一。这一步骤通常遵循以下流程： 窗口大小：首先，确定一个“窗口大小”，即在文本中同时考虑的连续词汇的数量。这个大小可以根据任务和文本的特点调整。较小的窗口强调更紧密的词语关系，而较大的窗口可以捕捉更广泛的上下文关系。 遍历文本：然后，遍历处理后的文本（已分词且去除了停用词），在每个窗口内记录所有词汇对的共现。例如，如果窗口大小为4，那么窗口中的每个词都与其他三个词形成共现关系。 构建图：对于每个共现关系，如果图中还不存在这两个词语对应的节点，则创建这些节点；如果这两个节点之间还没有边，则添加一条边，并将边的权重设为1。如果这两个节点之间已经有一条边，则将该边的权重增加1。 迭代计算与权重确定通过类似PageRank算法的迭代计算过程，每个节点（词或短语）的权重根据其邻接节点的重要性进行动态调整，直至整个系统达到平衡（收敛）。这个过程模拟了一个网络中的“推荐”机制，即一个词的重要性部分由与之相关的其他词的重要性决定。 关键词与摘要的提取最终，根据节点的权重对它们进行排序，权重越高的词语被认为在文档中的重要性越大。通过选择排名靠前的词语，我们可以确定文档的关键词或生成文本摘要。 类比说明可以将TextRank算法比作社交网络中的人际关系网。在这个网络中，每个人（节点）通过与其他人的互动（边）建立起连接。一个人的影响力（节点权重）不仅取决于他们直接认识的人数，还受到他们朋友的社交地位影响。这个类比有助于理解TextRank如何通过分析词语间的相互作用来评估它们的重要性，进而抽取关键信息。 LDA算法LDA（潜在狄利克雷分配，Latent Dirichlet Allocation）是一种常用于文本分析的主题模型，通过分析文档中词语的分布来推断出潜在的主题结构。LDA理想的文档不应过于短暂，以避免词汇过于稀疏，影响主题发现的质量。 初始化选择K个你希望从文档中发现的主题数量，每个文档被认为是这些主题的一个混合体，其中每个主题被定义为词汇的概率分布。通过狄利克雷分布为每个主题随机生成一个词的概率分布。 随机分配对于文档中的每个词，随机分配一个主题，作为该词的初始主题标签，然后开始吉布斯采样，不断更新文档中每个词的主题分配，在每次迭代中，算法会为文档中的每个词重新评估其属于各个主题的条件概率。 对每个文档中的每个词： 临时移除该词的当前主题分配。 根据当前模型的状态，计算该词被分配到每个主题的条件概率。这一步利用了以下公式，其中包含两个因素： 文档中其他词的当前主题分配。 全部文档中，当前主题下其他词的分配。 条件概率公式： 具体地，每个词w被分配到主题k的条件概率是基于： $p(topic_k∣document_d)$ 主题k在文档d中的分布。 $p(word_w∣topic_k)$：词w在主题k中的分布。 更新主题分配： 根据计算出的条件概率，为该词选择一个新的主题，并更新模型状态。 迭代直至收敛： 这个过程重复执行，直到每个词的主题分配变化不大，模型达到了稳定状态。 收敛重复迭代过程，直到每个词的主题分配稳定下来，这时算法结束。最终，我们得到每个文档的主题分布，以及每个主题的词分布。从每个主题的词分布中选出N个概率最高的词作为关键词。","link":"/2022/04/08/%E5%85%B3%E9%94%AE%E8%AF%8D%E6%8F%90%E5%8F%96%E7%AE%97%E6%B3%95/"},{"title":"在jupyter里面使用conda创建的虚拟环境","text":"提要 conda常用的命令。 conda list 查看安装了哪些包。 conda env list 或 conda info -e 查看当前存在哪些虚拟环境 conda update conda 检查更新当前conda 创建Python虚拟环境。 使用 conda create -n your_env_name python=X.X（2.7、3.6等） anaconda 命令创建python版本为X.X、名字为your_env_name的虚拟环境。your_env_name文件可以在Anaconda安装目录envs文件下找到。 指定python版本为2.7，注意至少需要指定python版本或者要安装的包# 后一种情况下，自动安装最新python版本 conda create -n env_name python=2.7 同时安装必要的包 conda create -n env_name numpy matplotlib python=2.73. 使用激活(或切换不同python版本)的虚拟环境。 打开命令行输入python –version可以检查当前python的版本。 使用如下命令即可 激活你的虚拟环境(即将python的版本改变)。 Linux: conda activate your_env_name(虚拟环境名称) 对虚拟环境中安装额外的包。 使用命令conda activate your_env_name 激活你的虚拟环境 使用命令conda install [package] 即可安装package到your_env_name中 关闭虚拟环境(即从当前环境退出返回使用PATH环境中的默认python版本)。使用如下命令即可。conda deactivate env_name，也可以使用activate root切回root环境 删除虚拟环境。移除环境使用命令conda remove -n your_env_name(虚拟环境名称) –all， 即可删除。删除环境中的某个包。使用命令conda remove –name your_env_name $package_name 即可。 jupyter使用conda创建的虚拟环境 安装 jupyter kernelconda activate your_env_nameconda install ipykernel 安装一个插件让jupyter notebook可以运行于指定的conda虚拟环境。conda install nb_conda_kernels 连接虚拟环境到jupyter kernel python -m ipykernel install –user –name [环境名] 删除虚拟环境 jupyter kernelspec remove your_env_name 完成！","link":"/2020/05/23/%E5%9C%A8jupyter%E9%87%8C%E9%9D%A2%E4%BD%BF%E7%94%A8conda%E5%88%9B%E5%BB%BA%E7%9A%84%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"title":"Python爬虫 requests访问http网站之443报错（ssl验证）","text":"报错信息： 1urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='ssr4.scrape.center', port=443): Max retries exceeded with url: /page/1 (Caused by SSLError(SSLCertVerificationError(1, '[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1007)'))) SSL介绍： SSL（Secure Sockets Layer）验证是在建立HTTPS连接时进行的一种验证过程。SSL验证的目的是确保服务器的身份，并验证通信双方之间的信任关系。以下是SSL验证的基本过程： 客户端请求建立SSL连接：当客户端（通常是Web浏览器）向服务器发送HTTPS连接请求时，它将尝试与服务器建立SSL连接。 服务器发送数字证书：如果服务器支持SSL，它会将包含数字证书的响应发送给客户端。数字证书由经过可信认证的第三方机构（证书颁发机构）签发，并包含了服务器的公钥、服务器的身份信息以及其他相关信息。 客户端验证数字证书：客户端接收到服务器发送的数字证书后，会对证书进行验证。验证过程包括以下几个方面： a. 校验证书的签发机构：客户端会检查证书是否由被客户端信任的可信证书颁发机构签发。 b. 检查证书的有效期：客户端会验证证书是否在有效期内，即确认证书尚未过期。 c. 验证服务器域名：客户端会核对证书中的服务器域名与客户端请求的域名是否匹配。这可以防止中间人攻击等安全威胁。 d. 检查证书的撤销状态：客户端会查询证书撤销列表（CRL）或在线证书状态协议（OCSP）服务器，确认证书是否被吊销。 客户端生成会话密钥：一旦客户端验证通过，它会生成一个临时的会话密钥（也称为”对称密钥”或”会话密钥”），用于该SSL会话的后续加密和解密操作。 安全数据传输：客户端使用服务器的公钥对会话密钥进行加密，并将加密后的会话密钥发送给服务器。服务器使用自己的私钥解密接收到的会话密钥。之后，客户端和服务器之间的通信将使用该会话密钥进行对称加密和解密。 通过SSL验证过程，客户端可以验证服务器的身份，并确保与服务器之间建立了安全的通信通道。这种验证过程可以帮助防止中间人攻击、欺骗和数据篡改等安全威胁。同时，SSL验证还为用户提供了信任和可靠性，因为证书是由可信的第三方机构签发的，代表了服务器的身份和认证信息。使用requests.get(verify=False) 关闭ssl验证。urllib3.disable_warnings()禁用 urllib3 库中的 SSL 证书验证警告","link":"/2020/04/28/python%E7%88%AC%E8%99%AB%20requests%E8%AE%BF%E9%97%AEhttp%E7%BD%91%E7%AB%99%E4%B9%8B443%E6%8A%A5%E9%94%99%EF%BC%88ssl%E9%AA%8C%E8%AF%81%EF%BC%89/"},{"title":"新服务器运行django站点","text":"远程登录服务器 1234sudo ssh root@user_name#删除 原来的ssh密钥命令ssh-keygen -f &quot;/home/shimmer/.ssh/known_hosts&quot; -R &quot;117.72.9.46&quot; 延长服务器ssh超时自动断开时间,此处为30分钟 12345#默认情况下，SSH 配置文件位于 /etc/ssh/sshd_config。ClientAliveInterval 1800ClientAliveCountMax 3#设置完成后，保存文件并重新启动 SSH 服务器：sudo service ssh restart 建议安装FTP软件代替scp命令,本处使用FileZilla 首先更新服务器的软件 123#用户为root用户apt updateapt upgrade 升级python版本,安装pip 12apt install python3apt install python3-pip 我的服务器上，上一步的环境没解决好，有问题，pip不能切换，使用conda创建虚拟环境 下载 Miniconda 安装脚本： 在终端中执行以下命令，从 Miniconda 的官方网站下载适用于你的操作系统的安装脚本。你可以选择适用于 Python 3.x 的版本。 1wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh 运行安装脚本： 在终端中执行以下命令，运行下载的安装脚本（请注意，文件名可能会因下载的版本而有所不同）： 1bash Miniconda3-latest-Linux-x86_64.sh 按照安装向导完成安装： 按照安装向导的提示进行安装。ctrl + c跳过解释，通常情况下，选择默认选项即可。 启动一个新的终端窗口： 安装完成后，你需要启动一个新的终端窗口，以使新的 Conda 环境变量生效。 测试 Conda 安装： 在终端中运行以下命令，检查 Conda 是否正确安装： 1conda --version 如果显示了 Conda 的版本信息，则表示安装成功。 现在，你可以使用 Conda 创建虚拟环境、安装软件包等。使用以下命令来创建一个名为 “myenv” 的虚拟环境： 1conda create -n myenv python=3.8 然后激活这个环境： 1conda activate myenv 在激活的环境中，你可以使用 Conda 安装所需的软件包，管理依赖项等。当你完成项目后，可以使用以下命令退出虚拟环境： 1conda deactivate 安装requirements.txt库 123pip install -r requirements.txt#注意安装mysqlclient时需要先安装mysqlclient的开发库apt-get install libmysqlclient-dev 上传并解压文件（推荐上传压缩包替代文件夹）， 1unzip MyBlog.zip pip换国内源 123456mkdir ~/.pipnano ~/.pip/pip.conf--------------------------#pip.conf文件输入以下内容，换为清华源[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple 安装数据库，此处为MySql 1apt install mysql-server 为mysql root用户设置密码 登录到 MySQL 服务器： 打开终端并使用以下命令登录到 MySQL 服务器。你将需要输入安装过程中设置的 MySQL root 用户密码。 1mysql -u root -p 如果成功登录，你将进入 MySQL 命令行界面。 设置 root 用户密码： 在 MySQL 命令行中，使用以下命令来设置 root 用户的密码。将 new_password 替换为你想要设置的实际密码。 1ALTER USER 'root'@'localhost' IDENTIFIED WITH 'mysql_native_password' BY 'new_password'; 替换 'new_password' 为你要设置的实际密码。 刷新权限： 在设置密码后，需要刷新权限以确保更改生效。 1FLUSH PRIVILEGES; 退出 MySQL 命令行： 输入以下命令退出 MySQL 命令行界面。 1exit 运行django程序 mysql建立相应的数据库 使用迁移命令建立相应的表 12python3 manage.py makemigrationspython3 manage.py migrate 开启防火墙 1234#在配置nginx前，开启防火墙，不然下次可能无法通过ssh访问服务器apt install ufw ufw enableufw allow 22/tcp 安装nginx 1apt install nginx 配置nginx文件 1nano /etc/nginx/sites-available/default 1234567891011121314151617181920server { charset utf-8; listen 80; server_name 117.72.9.46.; location /static { alias /MyBlog/static; } location /media { alias /MyBlog/media; } location / { proxy_set_header Host $host; proxy_pass http://unix:/tmp/117.72.9.46.socket; }} 1service nginx reload apt换源 备份当前sources.list文件: 1cp /etc/apt/sources.list /etc/apt/sources.list.bak 编辑sources.list文件: 1nano /etc/apt/sources.list 注释掉原有的源,加入新的软件源: 1234deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse 收集静态文件 12# 静态文件收集目录STATIC_ROOT = os.path.join(BASE_DIR, 'static') 1python3 manage.py collectstatic 运行gunicorn 1gunicorn --bind unix:/tmp/117.72.9.46.socket MyBlog.wsgi:application gunicorn –bind unix:/tmp/117.72.9.46.socket –log-file /logfile.log MyBlog.wsgi:application 使用nginx获取真实ip 123456789101112#如果你使用了Nginx作为反向代理服务器，并且在Nginx配置中有一些代理相关的设置，那么在Django中通过#self.request.META.get('REMOTE_ADDR')获取到的IP地址可能会不准确，甚至为空。这是因为Nginx会将用户的真实IP地址放在特定的#HTTP头中，而不是直接传递给Django。#在这种情况下，你可以通过访问特定的HTTP头来获取用户的真实IP地址。默认情况下，Nginx将用户的真实IP地址存储在X-Real-IP头中。以下##是如何在Django中获取用户真实IP地址的示例代码：user_ip = self.request.META.get('HTTP_X_REAL_IP') # 获取真实IP地址if user_ip: url = f&quot;http://ip-api.com/json/{user_ip}?lang=zh-CN&quot; response = requests.get(url) data = response.json() print(&quot;国家:&quot;, data['country']) location_info = data['country'] 当然你也可以不安装nginx、gunicorn等服务，直接部署项目 开启防火墙，配置服务器防火墙规则： 确保服务器的防火墙允许来自外部网络的连接到达你选择的Django运行端口 123456#查看防火墙状态ufw status#开启django运行的端口ufw allow 8000/tcp#重新加载防火墙规则ufw reload 2.启动Django应用： 12#切记运行接口是（0.0.0.0），而不仅仅是本地接口127.0.0.1python manage.py runserver 0.0.0.0:8000 3.访问django程序 1浏览器访问 公网IP:8000","link":"/2023/08/19/%E6%96%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8Cdjango%E7%AB%99%E7%82%B9/"},{"title":"端午，年中总结","text":"暑气逼人，年中将至。翻起年初写的flag，对照这半年的经历，是时候好好总结一下了。 更勇敢、更果断；以前做事总是想太多，左思右想就错过了机会，可机会就像公交车，错过这班，下一班就不知道什么时候来。与其在原地纠结，不如先迈出第一步，哪怕结果不完美，至少不会留下遗憾。 有魄力，敢担当：遇到问题时，第一反应不能是”这不关我事”或”我要怎么推卸责任”，而是问自己”我能做什么？”，”主动承担责任，全力解决问题。同时也努力提升情商，学会换位思考，理解别人的感受和需求，让自己成为值得信赖的人。 提高思考的深度：以前不敢提问题，怕显得自己无知。敢于提问才是进步的开始。遇到任何事情都多问几个”为什么”，从不同角度去分析，不满足于表面的理解。 成为一个温暖的人：努力培养乐观的心态，多关注生活中的美好。最重要的一点是：事事要有回应。别人找你帮忙，哪怕帮不上，也要及时回复；朋友分享喜悦，哪怕再忙也要表达祝福。这些小细节，往往最能体现一个人的温度。 学会组局，不只是约个饭那么简单——在人际关系中的良好的互动： 组局—&gt;沟通和领导力的练习场 主动发起话题，用开放式问题引导大家聊天 真诚关注每个人，让大家都感受到被重视 照顾到性格内向的朋友，主动把他们拉入对话 做个好的倾听者 认真听别人说话，适时点头回应 偶尔复述对方的话，表示你在认真听 如果现场气氛紧张，想办法缓解 平衡各方需求 这是最考验人的地方。有人想唱歌，有人想吃饭，有人预算有限，这时候就需要像个小外交官一样，找到大家都能接受的方案。 通过组局，慢慢学会察言观色，能够敏锐感知他人的情绪变化，这种能力在工作和生活中都很受用。 保持好奇心，做个有趣的人： 对未知领域保持兴趣 主动去了解不熟悉的东西，这不仅能拓宽视野，还能让自己在聊天时有更多话题。比如朋友聊起某个我不懂的游戏或电影，我会问”这个好玩吗？讲的什么故事？” 避免非黑即白的思维 世界比我们想象的复杂，很多事情没有标准答案。有人喜欢996，有人追求工作生活平衡，这些都没有对错。学会从多个角度看问题，既是智慧，也是修养。 保持情绪稳定 遇到冲突或挫折时，先让自己冷静下来再做反应。不要因为一时的情绪就给别人贴标签，说不定对方只是那天心情不好。 警惕生活中平庸的恶： 这半年越来越意识到一个问题：生活中那些看似微不足道的小事，正在悄悄塑造我们的人格。 看到有人摔倒，想着”应该有其他人会帮忙”然后走开 知道同事被不公平对待，但觉得”多一事不如少一事” 在电梯里对清洁阿姨视而不见，仿佛她是透明人 明知某个决定不公平，但因为对自己有利就保持沉默 为什么要在意这些小事？ 因为这些看似无关紧要的选择，正在悄悄塑造我们成为什么样的人。如果总是选择冷漠和回避，时间久了就真的会变得麻木不仁。 小结半年下来，最大的感悟是：成长不是一蹴而就的，而是在一次次选择中慢慢积累的。 每一次选择勇敢而不是退缩，选择担当而不是推脱，选择倾听而不是急于表达，选择善良而不是冷漠，都在让我们成为更好的人。","link":"/2024/06/10/%E7%AB%AF%E5%8D%88%EF%BC%8C%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/"},{"title":"English words","text":"format: 版式,格式action: 动作,活动interaction: 互动,交互动作abstraction: 抽象instance: 实例 interface: 界面/接口dependency: 依赖generalization: 泛化association: 关联aggregation: 聚合composition: 组合implementation: 实现analysis: 分析activity diagram: 活动图attribute: 属性basic flow: 基本流程component diagram: 组件图 plot (绘制,标出) assign(分配,指定) script(脚本,手迹) apropos(适当的,恰好的) manuals(手册) reference(参考,引文) attributes(属性) variables(变量) vector(向量) numeric(数字的) sequence(序列,顺序) generic(一般的,通用的) respective(各自的) Linear regression model (线性回归模型) dimensions(维度) components(分量) chr:数值表达式 replicate: 复制 重复 concatenate: 把…联系起来 quantile: 分位数 median: 中值 中位数 sieve: 筛子 滤网 不能守密的人copy: 中文 英文 中文 英文 抽象 Abstraction 实例 Instance 动作、活动 Action 互动、交互作用 Interaction 动作流、任务流程管理 Action Flow 接口 Interface 活跃的、主动的 Active 界面 Interface 活动 Activity 不变量、不变的 Invariant 活动图 Activity Diagram 生命线 Lifeline 行为者 Actor 连结 Link 聚合 Aggregation 逻辑视图 Logical View 其它流程 Alternative Flow 消息 Message 分析 Analysis 方法 Method 分析模式 Analysis Pattern (AP) 模型 Model 应用框架 Application Framework (AF) 多样性 Multiplicity 架构样式 Architectural Pattern 导航 Navigation 关连 Association 嵌套的状态 Nested State 属性 Attribute 节点 Node 基本流程 Basic Flow 注意、强调、说明 Note 行为 Behavior 对象 Object 边界 Boundary 对象约束语言 Object Constraint Language 呼叫、访问 Call 对象图 Object Diagram 类 Class 面向对象 Object Oriented 类别图 Class Diagram 操作 Operation 合作 Collaboration 重载 Overloading 合作图 Collaboration Diagram 覆盖、重写 Overriding 通讯 Communicate 包 Package 组件 Component 参数 Parameter 组件图 Component Diagram 被动、消极的 Passive 组件框架 Component Framework (CF) 模式 Pattern 组件式开发 Component-Based Development 多态 Polymorphism 组合、组成 Composition 后续条件 Post-Condition 具体 Concrete 前置条件 Pre-Condition 限制、约束 Constraint 进程视图 Process View 构建 Construction 特性、性质 Property 构造方法、构造器 Constructor 限定、指定限制 Qualifier 控制 Control 关系 Relationship 建立 Creation 需求 Requirement 数据类型 Data type 返回 Return 相依 Dependency 角色 Role 部署图 Deployment Diagram 情节、使用场景（用例图） Scenario 部署视图 Deployment View 顺序图、时序图 Sequence Diagram 设计 Design 方法规格 Signature 设计模式 Design Pattern (DP) 状态 State 摧毁 Destruction 状态机 State Machine 破坏、析构 Destructor 状态转移图 State Transition Diagram 鉴别器 Discriminator 静态 Static 动态 Dynamic 套用老套，使一成不变 Stereotype 封装 Encapsulation 结构 Structure 实体 Entity 子系统 Subsystem 事件 Event 泳道、区隔线 Swimlane 扩展 Extend 标注值、标记值 Tagged Value 外观、门面 Facade 模板 Template 结束状态 Final State 测试 Test 事件流程 Flow Of Event 追溯 Trace 控制焦点、焦点 Focus of Control 转移 Transition 框架 Framework 类型 Type 框架 Framework 统一模塑语言。UML Unified Modeling Language 监视、守卫 Guard 使用 Use 实现 Implementation 用例 Use Case 实现视图 Implementation View 使用个案图 Use Case Diagram 包含 Include 使用个案观点 Use-Case View 基础框架 Infrastructure Framework (IF) 视图 View 继承 Inheritance 虚拟 Virtual 初始状态 Initial State 可见性 Visibility","link":"/2021/04/08/%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D/"},{"title":"协同过滤","text":"协同过滤算法是一种常见的推荐系统算法，核心思想是利用用户历史行为数据，通过计算相似度,来找到与目标用户或目标商品喜好相似的商品。 基于用户的协同过滤算法：它通过分析用户间的相似性来进行个性化推荐。具体来说，如果用户A和用户B在评分或点赞行为上表现出高度的一致性，那么系统会推断出用户B可能对用户A喜欢的物品感兴趣。这种方法的核心在于，通过挖掘用户间的相似偏好，来预测并推荐那些用户可能喜欢但尚未接触的物品。 为了实现这一目标，首先需要构建一个用户-物品评分矩阵。这个矩阵以用户为行、物品为列，矩阵中的每个元素代表相应用户对相应物品的评分。接下来，算法会计算矩阵中用户向量之间的相似度，这可以通过多种方法完成，如余弦相似度、杰卡德系数、欧式距离、汉明距离或皮尔逊相关系数等。 通过比较这些相似度指标，算法可以识别出与用户A最相似的N个用户,标志为用户群体T(A，N)，并且将T中A未交互过的物品提取出来，对于每个物品item计算它的加权平均值，选择制值最高的K个物品作为A的推荐项。 例如，如果用户A和用户B都对某一系列电影给出了高评分，但用户A还对另一部未被用户B观看过的电影给出了高分，那么基于他们的相似偏好，这部未被用户B观看过的电影就有可能被推荐给用户B。 基于物品的协同过滤算法：如果用户U喜欢物品A，而物品A和物品B有很高的相似性，那么用户U也有可能很喜欢物品B。 为了实现这一目标，首先需要建立用户–物品表，记录每个用户最近点击交互过的物品列表，以及每个物品的喜好程度，根据时间倒排列，取前n个物品 物品–物品表：记录每个物品与其相似的物品列表及相似度，根据相似度倒排列，取前k个相似物品。","link":"/2021/04/10/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4/"},{"title":"面向对象与面向过程","text":"-面向对象(Object Oriented Programming):在面向对象编程中，我们将问题划分为一组相互关联的对象，每个对象都有自己的属性和方法。通过定义这些对象和它们之间的关系，我们可以使用对象的组合、继承和多态性等特性来解决问题。对象的属性描述了对象的特征，方法定义了对象的行为。通过对象之间的交互和消息传递，我们可以实现问题的解决方案。 理解面向对象编程（OOP）涉及掌握这种编程范式的核心概念和原则。 以下是帮助理解 OOP 的一些步骤： 学习基础知识：首先了解 OOP 的基本概念，例如对象、类、属性、方法和封装。 对象是类的实例，类定义了创建对象的蓝图。 属性表示对象的数据或状态，而方法定义对象可以执行的行为或操作。 理解封装：封装是指将数据和方法捆绑在一个对象内，并限制对对象内部细节的直接访问。 它有助于实现数据隐藏、抽象和维护对象状态的完整性。 了解如何定义类、创建对象以及访问其属性和方法。 探索继承：继承允许一个类从另一个类继承属性和方法。 这个概念促进了代码重用和分层组织。 了解如何创建父（基）类和子（派生）类，并了解超类、子类和继承层次结构的概念。 掌握多态性：多态性使得不同类的对象能够被视为公共超类的对象。 它允许不同的对象以不同的方式响应同一个方法调用。 了解方法重写和方法重载的概念，它们是实现多态性的关键方面。 练习设计和实现 OOP 解决方案：开展涉及使用 OOP 原则设计和实现解决方案的小型项目或练习。 练习创建类、定义其属性和方法、建立对象之间的关系以及在适当的情况下应用继承和多态性。 学习OOP设计模式：探索OOP中常用的设计模式，例如单例模式、工厂模式、观察者模式等等。 了解这些设计模式将为您提供解决 OOP 中重复出现的设计问题的实用见解。 分析现有的OOP代码库：研究和分析现有的OOP代码库，例如开源项目，看看OOP原理如何应用在现实场景中。 检查对象是如何设计的，它们如何相互交互，以及如何利用封装、继承和多态性。 考虑一个图书馆的场景，我们可以定义两个对象：图书馆（Library）和图书（Book）。 首先，我们定义一个图书对象（Book）的类，它具有属性（如书名、作者、出版年份）和方法（如借书、还书）： 1234567891011121314151617181920class Book: def __init__(self, title, author, year): self.title = title self.author = author self.year = year self.borrowed = False def borrow(self): if self.borrowed: print(&quot;This book is already borrowed.&quot;) else: self.borrowed = True print(&quot;Book borrowed successfully:&quot;, self.title) def return_book(self): if not self.borrowed: print(&quot;This book is not borrowed.&quot;) else: self.borrowed = False print(&quot;Book returned successfully:&quot;, self.title) 接下来，我们定义图书馆对象（Library）的类，它包含了图书馆的属性（如名称、地址）和方法（如添加书籍、借书、还书）： 1234567891011121314151617181920212223class Library: def __init__(self, name, address): self.name = name self.address = address self.books = [] def add_book(self, book): self.books.append(book) print(&quot;Book added successfully:&quot;, book.title) def borrow_book(self, book_title): for book in self.books: if book.title == book_title: book.borrow() return print(&quot;Book not found:&quot;, book_title) def return_book(self, book_title): for book in self.books: if book.title == book_title: book.return_book() return print(&quot;Book not found:&quot;, book_title) 现在，我们可以创建图书馆对象和图书对象，并进行相应的操作： 1234567891011121314151617181920# Create library objectlibrary = Library(&quot;City Library&quot;, &quot;123 Main Street&quot;)# Create book objectsbook1 = Book(&quot;Python Beginner's Guide&quot;, &quot;John Smith&quot;, 2019)book2 = Book(&quot;Java Programming Practice&quot;, &quot;Jane Doe&quot;, 2020)# Add books to the librarylibrary.add_book(book1)library.add_book(book2)# Borrow bookslibrary.borrow_book(&quot;Python Beginner's Guide&quot;)library.borrow_book(&quot;Java Programming Practice&quot;)library.borrow_book(&quot;C++ Basics&quot;) # Book not found# Return bookslibrary.return_book(&quot;Python Beginner's Guide&quot;)library.return_book(&quot;Java Programming Practice&quot;)library.return_book(&quot;C++ Basics&quot;) # Book not found 在这个例子中，我们首先定义了Book类和Library类，分别表示图书和图书馆。每个图书对象都有自己的属性（如书名、作者、出版年份）和方法（如借书、还书）。图书馆对象维护了一组图书，并提供了添加图书、借书和还书的方法。 我们通过创建图书馆对象library和图书对象book1和book2，并使用图书馆对象的方法来模拟图书馆的借书和还书过程。在借书和还书的过程中，我们可以看到相应的提示信息被打印出来，表示操作的成功与否。 -面向过程(Procedural Programming)：在面向过程编程中，我们将问题分解成一系列详细的步骤，然后通过函数实现每个步骤，并按照特定的顺序依次调用这些函数来解决问题。每个函数负责完成特定的任务，函数之间通过参数传递数据或返回值进行通信。面向过程编程强调程序的步骤和算法，以顺序执行的方式解决问题，不涉及对象的概念。 在面向过程编程中，问题的解决方法通常以过程或函数为中心，而不是以对象为中心。在这个图书馆的例子中，我们可以使用面向过程的方式来实现相同的功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243books = [] # 存储图书的列表def add_book(title, author, year): book = {&quot;title&quot;: title, &quot;author&quot;: author, &quot;year&quot;: year, &quot;borrowed&quot;: False} books.append(book) print(&quot;Book added successfully:&quot;, title)def borrow_book(title): for book in books: if book[&quot;title&quot;] == title: if book[&quot;borrowed&quot;]: print(&quot;This book is already borrowed.&quot;) else: book[&quot;borrowed&quot;] = True print(&quot;Book borrowed successfully:&quot;, title) return print(&quot;Book not found:&quot;, title)def return_book(title): for book in books: if book[&quot;title&quot;] == title: if not book[&quot;borrowed&quot;]: print(&quot;This book is not borrowed.&quot;) else: book[&quot;borrowed&quot;] = False print(&quot;Book returned successfully:&quot;, title) return print(&quot;Book not found:&quot;, title)# Add books to the libraryadd_book(&quot;Python Beginner's Guide&quot;, &quot;John Smith&quot;, 2019)add_book(&quot;Java Programming Practice&quot;, &quot;Jane Doe&quot;, 2020)# Borrow booksborrow_book(&quot;Python Beginner's Guide&quot;)borrow_book(&quot;Java Programming Practice&quot;)borrow_book(&quot;C++ Basics&quot;) # Book not found# Return booksreturn_book(&quot;Python Beginner's Guide&quot;)return_book(&quot;Java Programming Practice&quot;)return_book(&quot;C++ Basics&quot;) # Book not found 在这个面向过程的实现中，我们不再使用类和对象，而是使用了一组全局变量和函数来处理图书馆的操作。图书被表示为字典，每本图书有自己的属性（如书名、作者、出版年份）和状态（是否被借出）。books列表用于存储所有图书的信息。 函数add_book用于添加图书，它创建一个包含图书信息的字典，并将其添加到books列表中。函数borrow_book用于借书，它遍历books列表，查找要借的图书并更新其借阅状态。函数return_book用于还书，它遍历books列表，查找要还的图书并更新其借阅状态。 通过这种面向过程的方式，我们仍然可以实现相同的功能，但是代码结构和组织方式与面向对象编程有所不同。面向过程更注重问题的步骤和操作的组织，而不是将问题划分为对象并通过对象的交互来解决问题。","link":"/2020/06/09/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"title":"linux后台运行和关闭、查看后台任务","text":"在日常使用 Linux 的过程中，我们经常需要将任务放到后台运行，或者对多个并发任务进行管理。 一、使用 &amp;：命令后台运行在命令末尾加上 &amp;，可以让该命令在后台异步执行，终端不会被占用。例如： 1watch -n 10 sh test.sh &amp; 这个命令的意思是：每 10 秒执行一次 test.sh 脚本，并且在后台运行。 这种方式适合执行不需要交互、运行时间较长的任务。 ⚠️ 注意：当你关闭当前终端后，使用 &amp; 启动的任务通常会一并终止。 二、Ctrl + Z：挂起当前前台任务在执行一个前台任务时，按下 Ctrl + Z 可以将其挂起（暂停执行），并转为后台状态。 此时任务并未运行，而是处于“暂停”状态。你可以通过 jobs 查看它的编号，并结合 bg 或 fg 进行后续处理。 三、jobs：查看后台任务列表jobs 命令可以列出当前 shell 中所有的后台任务（包括暂停的和正在运行的）。 12jobsjobs -l # 显示每个任务对应的 PID 显示结果通常类似： 12[1]+ Running watch -n 10 sh test.sh &amp;[2]- Stopped python script.py 其中 + 表示默认任务，- 表示次要任务，编号（如 [1]）可用于 fg 和 bg。 四、fg：将后台任务调至前台执行使用 fg 命令可以把一个后台任务拉回前台继续运行。 1fg %1 # 将任务编号为 1 的任务恢复到前台 如果你只有一个后台任务，也可以直接用 fg 而不加参数。 五、bg：恢复后台暂停的任务如果某个任务被你 Ctrl + Z 暂停了，可以用 bg 命令让它在后台继续运行。 1bg %2 # 将任务编号为 2 的任务在后台继续执行 这时候任务不会回到前台，但会继续运行，不会阻塞终端。 六、kill：终止后台进程你可以通过两种方式终止后台任务： 方法一：使用 jobs 和 %jobnumber1kill %1 # 杀掉编号为 1 的后台任务 方法二：使用 ps 查看 PID 再杀掉12ps aux | grep test.shkill 12345 # 终止 PID 为 12345 的进程 如果你在前台执行某个任务，也可以直接按 Ctrl + C 来终止它。 七、nohup：让任务脱离终端独立运行当你希望某个任务在关闭终端之后仍能继续运行，可以使用 nohup 命令。 1nohup sh test.sh &amp; 输出默认会被写入到 nohup.out 文件中，即使关闭当前终端，该脚本依然会继续运行。 你可以通过以下命令确认进程是否仍在： 1ps aux | grep test.sh 这是生产环境中部署后台任务的常见做法，适合长期运行的服务或爬虫等任务。 八、前后台命令速查表 操作 命令或快捷键 说明 后台运行 command &amp; 命令直接后台执行 暂停并转后台 Ctrl + Z 暂停前台任务，任务进入后台暂停状态 查看后台任务 jobs / jobs -l 查看所有后台任务和其状态 后台任务转前台 fg %n 恢复后台任务到前台执行 恢复后台执行 bg %n 让后台任务继续在后台运行（取消暂停） 杀死任务 kill %n / kill PID 通过任务编号或 PID 终止进程 永久后台运行 nohup command &amp; 即使关闭终端也能继续运行任务 终止前台任务 Ctrl + C 强制终止正在执行的前台任务","link":"/2020/02/19/linux%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E5%92%8C%E5%85%B3%E9%97%AD%E3%80%81%E6%9F%A5%E7%9C%8B%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1/"},{"title":"小白的nginx指南","text":"Nginx 是一个高性能的开源web和反向代理服务器，也可以用作电子邮件（IMAP/POP3）代理服务器。它的主要特点包括占用资源少、并发性高、可扩展性强以及对高负载环境的稳定性。 高性能： 事件驱动：Nginx 使用事件驱动架构，能够高效地处理大量并发连接，而不会消耗过多的内存或CPU资源。 非阻塞：Nginx 是非阻塞式的，允许它同时处理多个请求，而不会等待一个请求完成后再处理下一个。 低资源消耗： 内存效率：Nginx 的内存占用非常低，适合在有限的硬件资源上运行。 CPU效率：由于事件驱动和非阻塞特性，Nginx 使用 CPU 的效率非常高，即使在高负载下也能保持稳定。 高并发性： Nginx 可以同时处理成千上万个并发连接，这对于高流量和高并发的网站非常重要。 反向代理： 1234567891011121314151617181920反向代理服务器（Reverse Proxy Server）是一种位于网络服务器和客户端之间的中间服务器，是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。与正向代理服务器不同，反向代理服务器的作用是隐藏真实的后端服务器，使客户端不直接与后端服务器通信。客户端是不知道真正的目标服务器是谁的，甚至不知道自己访问的是一个代理。 正向代理服务器（Forward Proxy Server）是一种位于客户端和目标服务器之间的中间服务器，其主要作用是代表客户端向目标服务器发送请求，并将获得的内容返回给客户端。客户端通过正向代理服务器来访问互联网上的资源，而不是直接连接目标服务器。正向代理服务器在客户端和目标服务器之间充当了中介的角色，隐藏了客户端的真实IP地址和身份。应用场景：访问受限资源：正向代理服务器可以用于绕过网络访问限制。例如，如果某些网站被屏蔽或受到地理位置限制，用户可以通过连接到位于允许访问的国家/地区的正向代理服务器来访问这些资源。保护客户端隐私：正向代理服务器可以隐藏客户端的真实IP地址，增强了用户的隐私和匿名性。内容过滤和安全性：正向代理服务器可以用于过滤恶意流量、病毒、广告和有害内容，提高安全性。提高性能：正向代理服务器可以缓存常用资源，减少对目标服务器的请求，从而提高性能。VPN服务：正向代理服务器通常用于构建虚拟私人网络（VPN）。用户可以通过连接到VPN服务器来获得安全的、匿名的互联网访问，并访问受限资源。企业内部网络：在企业内部，正向代理服务器通常用于管理内部网络的访问控制和安全性，允许员工安全地访问互联网资源。正向代理与反向代理的区别简单来讲：正向代理需要在客户端做配置，服务器不需要做任何配置。反向代理需要在服务器做配置，客户端不需要做任何配置。 Nginx 可以作为反向代理服务器，将客户端的请求转发到后端服务器，实现负载平衡和高可用性。这对于分散负载和提供冗余非常有用。 负载均衡： Nginx 可以分发请求到多个后端服务器，确保它们平均分担负载，提高系统的性能和可用性。这对于处理大量流量的网站非常重要。 静态文件服务： Nginx 能够快速地提供静态文件（如HTML、CSS、JavaScript和图像），这减轻了后端服务器的负载，提高了网站的响应速度。 反向代理缓存： Nginx 可以缓存一些静态或动态内容，以减少对后端服务器的请求，提高性能。这对于频繁请求相同内容的网站非常有用。 以下是在Ubuntu上管理Nginx的一些常用命令： 启动Nginx： 1sudo systemctl start nginx 停止Nginx： 1sudo systemctl stop nginx 重启Nginx： 1sudo systemctl restart nginx 重新加载Nginx配置（不中断已经处理的连接）： 1sudo systemctl reload nginx 检查Nginx配置文件的语法是否正确： 1sudo nginx -t 查看Nginx的状态： 1sudo systemctl status nginx 启用Nginx开机自启动： 1sudo systemctl enable nginx 禁用Nginx开机自启动： 1sudo systemctl disable nginx 查看Nginx版本号： 1nginx -v 打开Nginx的主配置文件（默认是/etc/nginx/nginx.conf）： 1sudo nano /etc/nginx/nginx.conf 查看Nginx配置文件所在目录： 1nginx -V 查看Nginx正在监听的端口和虚拟主机配置： 1sudo nginx -T","link":"/2022/09/06/%E9%80%9A%E4%BF%97%E8%A7%A3%E9%87%8Anginx/"},{"title":"驾校一点通抢课脚本","text":"软件: autojs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//判断屏幕锁定，解锁屏幕（数字密码）if (!device.isScreenOn()) { //从息屏状态 将屏幕唤醒 device.wakeUp();//唤醒设备 console.log('亮屏'); sleep(1000); // 等待屏幕亮起 //miui锁屏滑动不能唤出密码输入 通过下拉通知栏点击时间进入密码解锁 swipe(500, 0, 500, 2120, 900); //点击“时间” click(180, 180); sleep(1000); console.log('开始解锁'); //解锁 密码 0000 desc(0).findOne().click(); desc(0).findOne().click(); desc(0).findOne().click(); desc(0).findOne().click(); //等待解锁完成，返回并退出 back(); }sleep(1000);launch('com.jxedt');while(!textContains('我的').exists()){ //等待启动完成};toast('驾校一点通已打开');//消息提示log('驾校一点通已打开');//消息提示click('驾校');sleep(3000);click('我要约课');sleep(3000);click(666,666); //点击教练sleep(3000);while(true){ var myDate = new Date(); console.log(myDate.getMinutes()); if(myDate.getMinutes()==1 || textContains('查看约课记录').exists()){ exit();} //退出循环 时间或约课成功 click(460,300); //刷新 sleep(10); click(550,1200); //点击教练 sleep(10); click(900,1950); //预约 sleep(10);}","link":"/2020/10/28/%E9%A9%BE%E6%A0%A1%E4%B8%80%E7%82%B9%E9%80%9A%E6%8A%A2%E8%AF%BE%E8%84%9A%E6%9C%AC%20/"},{"title":"常用设计模式","text":"软件设计的六大原则SOLID： 单一职责：一个类应该只负责一个方面的任务，如果一个类承担了过多的任务，修改其中一部分可能会影响到其它类的功能。 ​ 开闭原则：对修改关闭，对扩展开放，类、模块、函数等应该可以在已有代码不被修改的情况下增添新功能。 依赖倒置：鼓励创建抽象类或接口，通过依赖注入的方式，让具体实现类依赖于这些抽象类 接口隔离：将大的接口分成更小更具体的接口，让类只需要关心他们真正需要的接口。 里氏替换：子类对象应该能够替换其父类对象，而不破坏程序的正确性。换句话说，这意味着子类应当遵循父类的行为约定，父类定义的行为在子类中依然成立。 组合优于继承：可以通过包含其它对象来扩展类的行为，通过对象的组合来获得更灵活的代码重用机制，避免继承带来的紧密耦合问题。 常用的设计模式： 工厂模式：旨在将对象的创建过程从其使用过程中分离出来，以提高系统的灵活性和可维护性。在这种模式下，客户端代码不直接实例化具体产品类。相反，它通过使用一个共同的工厂接口，依赖于工厂类来创建具体产品的实例。这种方式允许客户端代码在不知道具体产品类细节的情况下工作，从而使系统更容易扩展和维护。举一个类比，这就像在餐厅点餐时，你不需要知道食物是如何准备的，你只需要从菜单中选择你想要的食物，并等待厨房准备好送到你的桌上。 123456789101112131415161718192021222324252627282930313233343536class Chart: def draw(self): raise NotImplementedError(&quot;This method should be overridden by subclasses.&quot;)class ScatterChart(Chart): def draw(self): return &quot;Drawing ScatterChart.&quot;class LineChart(Chart): def draw(self): return &quot;Drawing LineChart.&quot;class BarChart(Chart): def draw(self): return &quot;Drawing BarChart.&quot;class ChartFactory: def create_chart(self, data_type, data_size, user_preference): if data_type == 'continuous': if data_size &gt; 1000: return ScatterChart() else: return LineChart() elif data_type == 'categorical': if user_preference == 'detail': return BarChart() else: return LineChart() # Add more logic as needed else: raise ValueError(&quot;Unsupported data type or preferences&quot;)# Client codefactory = ChartFactory()chart = factory.create_chart('continuous', 1200, None)print(chart.draw()) 策略模式：是一种行为模式，它主要关注对象的行为和算法的选择。这个模式允许开发者定义一系列的算法，把它们封装在独立的策略类中，并在运行时确定使用哪一个算法。这样，这种模式使得客户端可以在不同算法间切换，而无需关心算法的具体实现细节。客户端的选择通常基于运行时的条件或者需求变更，而策略模式使得这种选择变得灵活和可扩展。 123456789101112131415161718192021222324252627282930313233343536373839from abc import ABC, abstractmethod# 定义策略接口class RenderStrategy(ABC): @abstractmethod def render(self, text): pass# 实现文本渲染策略class TextRenderStrategy(RenderStrategy): def render(self, text): return text# 实现Markdown渲染策略class MarkdownRenderStrategy(RenderStrategy): def render(self, text): return f&quot;**{text}**&quot; # 假设简单地将文本加粗表示Markdown渲染# 上下文，用于使用策略class ContentRenderer: def __init__(self, strategy: RenderStrategy): self.strategy = strategy def render(self, text): return self.strategy.render(text)# 在运行时根据条件选择策略if __name__ == &quot;__main__&quot;: # 假设这是根据用户输入或其他条件动态决定的 user_preference = &quot;markdown&quot; if user_preference == &quot;text&quot;: strategy = TextRenderStrategy() elif user_preference == &quot;markdown&quot;: strategy = MarkdownRenderStrategy() renderer = ContentRenderer(strategy) print(renderer.render(&quot;Hello, Strategy Pattern!&quot;)) 观察者模式：是一种行为模式，允许观察者对象监听某个被观察者对象的状态变化，当被观察者对象的状态发生变化时，它会自动通知所有注册的观察者，触发他们执行相应的更新操作。这种模式特别是用于创建松耦合的系统。我不清楚上述过程中观察者是如何注册的，并且被观察者如何通知的观察者？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899class Observer: def update(self, news): &quot;&quot;&quot;接收新闻更新的方法。 该方法应当由继承自Observer类的所有子类实现，以便当新闻发布者有新闻更新时，能够通知所有订阅者。 Args: news: 一个字符串，表示接收到的新闻内容。 &quot;&quot;&quot; passclass EmailSubscriber(Observer): def update(self, news): &quot;&quot;&quot;当新闻更新时，通过电子邮件通知订阅者。 实现Observer类中的update方法，以电子邮件形式接收新闻。 Args: news: 一个字符串，表示接收到的新闻内容。 &quot;&quot;&quot; print(f&quot;Email Subscriber received news: {news}&quot;)class SMSSubscriber(Observer): def update(self, news): &quot;&quot;&quot;当新闻更新时，通过短信通知订阅者。 实现Observer类中的update方法，以短信形式接收新闻。 Args: news: 一个字符串，表示接收到的新闻内容。 &quot;&quot;&quot; print(f&quot;SMS Subscriber received news: {news}&quot;)class NewsPublisher: def __init__(self): &quot;&quot;&quot;初始化新闻发布者。 创建一个新的新闻发布者实例，该实例可以注册和注销观察者，同时发布新闻给所有注册的观察者。 &quot;&quot;&quot; self.__subscribers = [] self.__latestNews = None def register(self, subscriber): &quot;&quot;&quot;注册一个新的观察者以接收新闻更新。 Args: subscriber: 一个Observer类的实例，表示要注册的观察者。 &quot;&quot;&quot; if subscriber not in self.__subscribers: self.__subscribers.append(subscriber) def unregister(self, subscriber): &quot;&quot;&quot;注销一个观察者，使其不再接收新闻更新。 Args: subscriber: 一个Observer类的实例，表示要注销的观察者。 &quot;&quot;&quot; self.__subscribers.remove(subscriber) def notifySubscribers(self): &quot;&quot;&quot;通知所有注册的观察者最新的新闻。 遍历所有注册的观察者，并调用它们的update方法，传递最新的新闻内容。 &quot;&quot;&quot; for subscriber in self.__subscribers: subscriber.update(self.__latestNews) def addNews(self, news): &quot;&quot;&quot;添加新闻并通知所有注册的观察者。 设置最新的新闻内容，并自动调用notifySubscribers方法通知所有观察者。 Args: news: 一个字符串，表示要发布的新闻内容。 &quot;&quot;&quot; self.__latestNews = news self.notifySubscribers()if __name__ == &quot;__main__&quot;: # 创建被观察者 news_publisher = NewsPublisher() # 创建观察者 email_subscriber = EmailSubscriber() sms_subscriber = SMSSubscriber() # 注册观察者 news_publisher.register(email_subscriber) news_publisher.register(sms_subscriber) # 添加一条新闻，自动通知所有观察者 news_publisher.addNews(&quot;New Python Version Released!&quot;) # 注销一个观察者 news_publisher.unregister(email_subscriber) # 添加另一条新闻，只有注册的观察者会收到通知 news_publisher.addNews(&quot;New Java Version Released!&quot;) 单例模式是一种确保类在任何给定时间内只有一个实例的设计模式，并提供一个全局访问点来获取该实例。 1234567891011121314151617181920212223242526272829303132import threadingclass SingletonClass: _instance = None _lock = threading.Lock() def __new__(cls, *args, **kwargs): with cls._lock: if not cls._instance: cls._instance=super(SingletonClass, cls).__new__(cls, *args, **kwargs) return cls._instancefrom functools import wrapsdef singleton(cls): instances = {} lock = threading.Lock() @wraps(cls) def wrapper(*args, **kwargs): if cls not in instances: with lock: if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return wrapper","link":"/2020/09/14/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"CORS跨域问题详解","text":"在前后端分离开发中，我们常常遇到一个令人头疼的问题——跨域（CORS，Cross-Origin Resource Sharing）。明明接口地址、请求方法都没问题，却无法访问后端服务。 什么是跨域跨域（Cross-Origin）指的是当前网页向与其协议、域名或端口三者中任意一个不同的目标发起的请求。如果请求的资源不属于同源范围（协议、域名、端口三者中有任意一个不同），浏览器会根据同源策略限制该跨域请求。需要注意的是： 同源策略是浏览器的安全机制，不是服务器的限制 不同浏览器对同源策略的具体实施可能存在细微差异 该问题的解决需要后端服务器配置CORS响应头来允许跨域请求，这涉及前后端的协作 为什么会有同源策略浏览器为了防止恶意网页利用用户的浏览器身份获取其他网站的敏感数据，实施了同源策略。主要防护以下几类威胁： CSRF（跨站请求伪造）：恶意网站通过浏览器自动携带的 Cookie，以用户身份向已登录网站发起未经授权的请求。 数据泄露：恶意网页尝试读取用户在其他网站的敏感信息，如 Cookie、LocalStorage、SessionStorage 等。 内网扫描：当用户在公司内网访问外部恶意网站时，该网站可能尝试扫描和攻击内网资源。 浏览器如何处理跨域请求当浏览器检测到当前页面发起的请求与页面源不同，会根据请求类型采取不同的处理方式。 CORS请求分类：简单请求与预检请求简单请求的定义满足以下全部条件的请求被视为“简单请求”： 方法：仅限 GET、POST、HEAD。 Content-Type：仅限 application/x-www-form-urlencoded、multipart/form-data、text/plain。 请求头：仅限 Accept、Accept-Language、Content-Language、Content-Type（前述三种值），不允许自定义头。 简单请求的处理流程 浏览器直接发送请求，同时添加 Origin 头部 服务器处理请求并返回响应 浏览器检查响应中的 Access-Control-Allow-Origin 头部 如果允许当前源访问，则将响应交给JavaScript；否则抛出CORS错误 预检请求（Preflight Request）当请求不满足“简单请求”条件时，浏览器会先发送一个 OPTIONS 预检请求，确认服务器是否允许实际请求。 触发预检请求的情况 使用非简单请求方法（如 PUT、DELETE、PATCH） 使用自定义请求头（如 Authorization、X-API-Key） Content-Type 为 application/json 等非简单类型。 预检请求示例 12345OPTIONS /api/data HTTP/1.1Host: api.example.comOrigin: https://www.client.comAccess-Control-Request-Method: DELETEAccess-Control-Request-Headers: Authorization, X-Custom-Header 预检响应示例 12345HTTP/1.1 200 OKAccess-Control-Allow-Origin: https://www.client.comAccess-Control-Allow-Methods: GET, POST, PUT, DELETEAccess-Control-Allow-Headers: Authorization, X-Custom-HeaderAccess-Control-Max-Age: 86400 Tip：Access-Control-Max-Age 表示预检结果的缓存时间（单位：秒），可减少预检次数。 携带凭据的请求当请求需要携带cookie或其他凭据时： 123fetch(url, { credentials: 'include' }) 浏览器会进行额外检查： 服务器必须返回 Access-Control-Allow-Credentials: true Access-Control-Allow-Origin 不能是通配符 *，必须是具体的源 如果检查不通过，浏览器会阻止JavaScript访问响应数据，并抛出CORS错误 常见跨域场景举例 场景 示例 跨域原因 子域名不同 页面：https://www.example.com接口：https://api.example.com 域名不同 端口不同（开发环境） 页面：http://localhost:3000接口：http://localhost:8080 端口不同 协议和域名都不同 页面：http://insecure.com接口：https://secure.com 协议、域名都不同 第三方 API 调用 页面：https://my-app.com接口：https://api.weather.com 域名不同 本地文件访问 页面：file:///C:/app/index.html接口：http://localhost:8080 协议（file:// vs http://） 🔄 跨域解决方案对比 方案 原理与适用场景 限制与注意事项 1. JSONP 利用 &lt;script&gt; 标签能够跨域加载脚本的特性，将接口返回的数据包装成函数调用。 仅支持 GET 请求，且无法处理复杂交互；已被现代 CORS 替代。 2. 反向代理 前端服务器（如 Nginx）接收前端请求，再转发到后端，浏览器只与同源服务器通信。 配置简单、安全性高，适用于生产环境；需维护代理服务器。 3. iframe + postMessage 在不同源页面间通过 postMessage 进行数据通信。 实现较繁琐，主要用于嵌入第三方或多个域之间的复杂通信场景。 4. 后端设置 CORS 后端在响应头中配置 Access-Control-Allow-Origin、Access-Control-Allow-Methods、Access-Control-Allow-Headers 等。 通用、标准；可细粒度控制源、方法与头部；需后端框架或中间件支持。 5. WebSocket 基于 TCP 的双向通信协议，一旦建立连接后不受同源策略限制。 需要 WebSocket 服务端支持；不适合所有应用场景。 CORS与CSRF的安全关系澄清 “当后端没有设置CORS的时候，数据岂不是轻易的就被窃取了” 实际上，CORS 不是安全机制，而是浏览器的访问控制： 跨域请求：浏览器仍会发送请求到服务器（可抓包验证）。 响应处理：若未授权，浏览器会阻止前端脚本读取响应，但请求已执行。 真正规避风险：应对 CSRF 攻击，需使用 CSRF Token、SameSite Cookie 等机制。 CSRF攻击三要素 用户已登录目标网站（存在有效会话） 网站依赖Cookie验证身份（无额外防护） 用户访问恶意页面（触发跨域请求） CSRF 防御策略1. CSRF Token原理：后端在用户会话中生成一个随机、不可预测的 token，并将其以隐藏字段或响应接口返回给前端；前端将此 token 附加在每次敏感请求中，后端校验请求中 token 与会话存储的值是否一致。若一致，则请求合法。 1234567891011121314151617181920212223242526# Django. views.pyfrom django.http import JsonResponsefrom django.middleware.csrf import get_tokendef csrf_token_view(request): return JsonResponse({'csrfToken': get_token(request)})&lt;!-- 模板或前端框架获取并使用 --&gt;&lt;input type=&quot;hidden&quot; id=&quot;csrfToken&quot; value=&quot;&quot; /&gt;&lt;script&gt;fetch('/csrf-token').then(res =&gt; res.json()).then(data =&gt; { document.getElementById('csrfToken').value = data.csrfToken;});function postData(url, payload) { return fetch(url, { method: 'POST', credentials: 'include', headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': document.getElementById('csrfToken').value }, body: JSON.stringify(payload) });}&lt;/script&gt; 2. SameSite Cookie 属性原理：通过设置 SameSite 属性控制浏览器是否在跨站请求时携带 Cookie。 1Set-Cookie: sessionid=abcd1234; SameSite=Lax; Secure; HttpOnly; Path=/ 模式 行为说明 Strict 仅当前站点导航时携带 Cookie，完全阻止跨站请求发送 Cookie。 Lax 允许顶级跨站 GET/HEAD 导航携带 Cookie（推荐用于登录态）。 None 始终携带 Cookie，适用于复杂跨站场景，需配合 Secure。 优缺点： 优点：无需额外前端代码，依赖浏览器实现； 缺点：对非导航型跨站请求（如 AJAX POST）无效；部分老旧浏览器兼容性欠佳。 3. 验证 Origin / Referer 头原理：后端检查请求头中的 Origin 或 Referer 字段，仅允许来自可信域名的请求。此方式不依赖 token，但要确保所有请求都出现在同浏览器策略下。 1234567891011121314# Django # middleware.pyfrom django.http import HttpResponseForbiddenclass OriginCheckMiddleware: def __init__(self, get_response): self.get_response = get_response def __call__(self, request): origin = request.headers.get('Origin') or request.headers.get('Referer') if origin and not origin.startswith('https://mydomain.com'): return HttpResponseForbidden('Forbidden: Invalid Origin') return self.get_response(request) 然后在 settings.py 中添加中间件： 12345MIDDLEWARE = [ ... 'yourproject.middleware.OriginCheckMiddleware', ...] 注意：某些请求（如表单提交）可能没有 Origin，建议同时检查 Referer。 4. 🔐 双重提交验证（Double Submit Cookie）原理：前端和后端各自持有相同的随机 token。后端将 token 写入 Cookie，前端也读取该 Cookie 并在请求头中携带；后端只需比较 Cookie 与头部中 token 是否一致，无需维护服务端会话状态。 123456789101112// 前端示例const token = Cookies.get('XSRF-TOKEN');fetch('/api', { method: 'POST', headers: { 'X-XSRF-TOKEN': token }, credentials: 'include'});# 后端示例（伪代码）if (request.cookies['XSRF-TOKEN'] !== request.headers['X-XSRF-TOKEN']) { reject();} 优缺点： 优点：适合无状态架构，无需会话存储； 缺点：Token 泄露风险更高，需与 HTTPS 强绑定。 5. CAPTCHA / 二次确认对高风险操作（如交易、密码修改等），可在操作前要求用户输入 CAPTCHA、短信验证码或重新输入密码，以二次确认用户意图。 123&lt;!-- 示例：操作前弹出验证框 --&gt;&lt;label&gt;请输入验证码：&lt;input id=&quot;captcha&quot; /&gt;&lt;/label&gt;&lt;button onclick=&quot;submitWithCaptcha()&quot;&gt;确认操作&lt;/button&gt;","link":"/2023/06/12/CORS%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/"},{"title":"Cursor 体验：AI IDE 如何提升开发效率与体验","text":"在人工智能快速发展的今天，AI编程工具正在重新定义我们的开发方式。作为一名计算机专业的从业人员，我在2025年上半年中深度体验了Cursor这款AI编程工具，从最初的尝试下使用到最终将其融入到日常开发流程，完成了包括微信小程序和Java CURD系统等多个实际项目的开发。 AI 编程工具能够显著提升特定环节的开发效率，特别是在代码生成、样式设计、文档编写等重复性工作方面表现相当出色。在传统开发模式下，将一个新想法转化为可运行的原型往往需要数小时甚至数天的时间。而借助AI工具，开发者可以在几分钟内获得一个基本可用的代码框架。当你有一个新的功能想法时，你可以立即通过自然语言描述让AI生成初始代码，然后基于这个基础进行迭代优化，这种工作方式比从零开始编写要高效得多。 但在系统整体架构设计、技术栈选择、性能优化策略等需要全局视野和深度技术判断的高层次决策方面，它还远不能替代有经验的架构师或高级开发者。系统架构设计需要考虑业务需求、技术约束、团队能力、维护成本等多个维度的因素，这种复杂的权衡决策目前仍然是人类智慧的专属领域。 上下文理解的长度限制的瓶颈在处理大型项目时表现得尤为明显。当项目代码库达到一定规模时，AI很难在有限的上下文窗口内完整理解整个系统的复杂关联关系。这可能导致生成的代码在局部看起来完全正确，但在全局视角下却与现有系统不兼容或产生冲突。这个问题突出了项目管理和模块化设计的重要性。 领域专业知识的局限性在处理特定业务领域或小众技术栈时表现得特别明显。AI模型的训练数据虽然庞大，但在某些专业细分领域可能存在覆盖不足的问题。这要求开发者必须具备足够的专业知识来指导、验证和修正AI生成的代码，确保其符合特定领域的技术规范和业务要求。 Agent能力仍然有很大的发展空间，虽然这些工具在代码生成方面表现，但在主动理解开发者意图、自主规划开发任务、智能处理异常情况等方面还有很大的改进空间。理想的AI编程助手应该能够更好地理解项目上下文，主动提出针对性的优化建议。 我第一次听说Cursor是在2024年中期，当时AI编程工具刚刚兴起，GitHub Copilot已经获得了广泛关注。作为一个对新技术充满好奇的人，我怀着极大的期待下载并安装了Cursor，期望它能够成为我编程路上的得力助手。 然而，最初的体验远不如预期。受限于当时集成模型以及工具本身agent的能力水平，Cursor生成的代码存在诸多的问题，常常需要大量的人工修改。这种类型的工具是否真的能够提升开发效率，还是仅仅是一个华而不实的技术展示？真正的转折出现在Claude 3.7 Sonnet以及DeepSeek R1等新一代推理模型的发布。这些模型在语言理解、逻辑推理和代码生成方面展现出了前所未有的能力，标志着大语言模型技术迈入了一个全新的发展阶段。Cursor的关键价值在于，它成功的将这些强大的AI模型无缝且高效的集成到了开发者最熟悉的工作流中。这种集成不是简单的API调用或功能叠加，而是深度融入了代码编辑、调试、解释等各个开发环节，它可以时刻为你提供建议，解答疑惑、生成及优化代码。 我第一个深度使用Cursor(使用claude 3.7 think模型)开发的项目是一个颇具趣味性的微信小程序——“餐谋一下”美食决策助手，这个项目的核心功能是帮助用户解决日常生活中的经典难题：今天应该吃什么？ 在技术架构方面： 前端：uni-app 框架(采用 Vue3 的语法规范和开发范式，这意味着我能够充分利用Vue的组件化开发理念、响应式数据绑定。更重要的是，uni-app提供了”一次开发，多端发布”的能力，虽然当前项目专注于微信小程序平台，但这种架构为未来可能的平台扩展（如支付宝小程序、H5页面、App应用）留下了技术储备空间。) 后端：Go 1.24版本(Go的跨平台编译特性意味着开发完成的程序可以轻松部署到Linux服务器、Windows开发环境或macOS系统上，而无需担心运行时环境的依赖问题。Go程序通常具有较小的内存占用和快速的启动时间，这对于云服务器的资源利用效率有着重要意义。) 数据存储：MySQL 8.0 项目的核心功能相对简洁： 用户登录注册系统（通过微信小程序的openid作为用户唯一标识符） 用餐选项的完整CRUD操作（创建、读取、更新、删除） 接入AI，用户可以以对话的形式获取用餐建议 转盘抽选功能 在UI组件库的选择上，我指定使用UV-UI框架，希望能够快速构建出美观且功能完善的用户界面。然而，这个决定很快就遇到了挑战：UV-UI作为一个相对小众的框架，在互联网上的学习资料和代码示例相当有限。这种资料稀缺性直接影响了AI模型的表现。由于训练数据中缺乏足够的UV-UI相关内容，Claude输出的代码不得不大量使用自定义CSS样式来实现所需的界面效果。这种现象揭示了当前AI工具的一个重要特征：它们的能力很大程度上依赖于训练数据的丰富程度和质量。 项目中最核心的功能当属转盘抽选。我向Cursor提出的需求描述相当具体：”使用HTML5 Canvas实现一个交互式转盘，转盘应当包含用户自定义的餐品选项，当用户点击开始按钮时，转盘开始旋转，经过一段随机时间后逐渐减速并停止，最终指针应当准确指向某个选项区域的中心位置”。令我惊喜的是，Cursor基于这个描述生成了一个功能完整且视觉效果相当精美的转盘组件。代码不仅实现了基本的旋转动画，还包含了平滑的加速减速效果、样式也十分精美。虽然Cursor成功生成了视觉效果出色的旋转动画，但在计算转盘停止后应当选中哪个选项这一核心逻辑上，生成的算法存在明显缺陷。这需要我手动编写和调试数学计算逻辑相关代码。 尽管项目规模相对简单，但随着开发的深入，还是遇到了各种各样的问题 技术栈识别准确性不足：当我在prompt中未明确指明使用uni-app框架时，Cursor有时会默认生成微信小程序的原生代码。 项目架构理解能力薄弱：当我要求Cursor对现有项目代码进行规范化或新增功能时，其表现出对项目整体架构把握不足的问题。具体表现为经常创建功能重复的目录和文件，这反映出AI Agent在建立和维护项目结构索引方面存在明显缺陷。 复杂逻辑处理能力受限：面对需要多步骤推理、复杂状态管理或多系统交互的功能需求时，受限于当前的模型能力，Cursor 往往无法一次性生成完整可用代码。 调试与诊断能力缺失：Cursor的Agent 无法访问浏览器控制台信息，代码出现运行时错误时，开发者只能手动排查。 这些表象问题实际上反映了AI编程工具的本质特征：它们的表现根本上受限于底层语言模型的能力以及Agent系统的架构设计。在本项目开发中，我使用的是Claude 3.7模型，这已经是目前代码生成能力最强的模型之一。当前的AI编程工具更多地体现了语言模型本身的能力边界，而非我们期望的智能代理能力。它们在生成符合语法规则的代码片段方面表现不错，但在理解复杂业务逻辑、优化代码架构和解决实际问题方面仍有很大的提升空间。Agent系统对项目的索引能力不足，无法充分识别和理解用户的真实需求，这些都表明该领域还有巨大的发展潜力。 通过这些实际遇到的问题，我感觉当前的AI编程工具更适合扮演智能助手的角色，而非开发者的替代者。针对这些问题，我总结了以下使用策略： 项目开发规范显式化：为AI提供当前项目的开发规范和架构文档。我的实践是首先花时间明确系统的整体架构和核心功能模块。完成架构设计后，我会让AI将架构设计输出为结构化文档，作为后续开发的基线参考。在与AI协作时，显式提供该文档的关键内容作为对话上下文，确保AI理解系统边界和设计原则。 Prompt：我们必须要清晰、详细地描述任务需求，避免歧义。这不仅包括功能描述，还要包含技术栈、代码风格、性能要求等具体约束条件。良好的提示就像是给AI提供了一份详细的技术规格书，让它能够在正确的框架内发挥创造力。 模块化开发策略：将复杂的功能需求分解为相对独立的小模块，分而治之，按照功能优先级逐步实现。AI在处理明确、具体的小任务时表现出色，但在处理复杂、模糊的大任务时容易出现逻辑混乱和架构偏离。 随着大模型的持续迭代，我们有理由相信AI编程工具将在不久的将来变得更加智能和强大。未来的AI编程助手很可能会具备更强的架构设计能力，能够在更大的上下文长度内保持准确的理解，并且在各个专业领域都具备更深入的知识储备。然而，无论技术如何进步，我们都应该认识到，AI编程工具的价值不在于替代开发者，而在于解放开发者，让我们能够从重复性的编码工作中脱身，将更多的时间和精力投入到创造性思考、架构设计和用户体验优化等更具价值的工作中。创造性思维、复杂问题的分析和解决能力、系统性的架构思考、对业务需求的深度理解，以及跨团队协作的沟通能力，这些都是人类开发者独有的优势，也是在AI时代保持竞争力的关键所在。 “世界上唯一不变的就是变化本身。”在AI技术快速发展的今天，这句话显得尤为贴切。作为开发者，我们需要以开放的心态拥抱这些变化，将其视为提升自身能力和工作效率的机遇，而不是威胁。","link":"/2025/06/16/Cursor%E4%BD%BF%E7%94%A8%20%E4%BD%93%E9%AA%8C/"}],"tags":[{"name":"spark","slug":"spark","link":"/tags/spark/"},{"name":"VMware16","slug":"VMware16","link":"/tags/VMware16/"},{"name":"scala","slug":"scala","link":"/tags/scala/"},{"name":"Centos7","slug":"Centos7","link":"/tags/Centos7/"},{"name":"Zookeeper","slug":"Zookeeper","link":"/tags/Zookeeper/"},{"name":"Hadoop","slug":"Hadoop","link":"/tags/Hadoop/"},{"name":"Hbase","slug":"Hbase","link":"/tags/Hbase/"},{"name":"Hive","slug":"Hive","link":"/tags/Hive/"},{"name":"flume","slug":"flume","link":"/tags/flume/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Google开发者模式","slug":"Google开发者模式","link":"/tags/Google%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"name":"网络协议","slug":"网络协议","link":"/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"Web开发","slug":"Web开发","link":"/tags/Web%E5%BC%80%E5%8F%91/"},{"name":"性能优化","slug":"性能优化","link":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Linux命令杂记","slug":"Linux命令杂记","link":"/tags/Linux%E5%91%BD%E4%BB%A4%E6%9D%82%E8%AE%B0/"},{"name":"kafaka","slug":"kafaka","link":"/tags/kafaka/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"心理学","slug":"心理学","link":"/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"},{"name":"R","slug":"R","link":"/tags/R/"},{"name":"CORS","slug":"CORS","link":"/tags/CORS/"},{"name":"跨域","slug":"跨域","link":"/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"安全","slug":"安全","link":"/tags/%E5%AE%89%E5%85%A8/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"coding","slug":"coding","link":"/tags/coding/"},{"name":"生活","slug":"生活","link":"/tags/%E7%94%9F%E6%B4%BB/"},{"name":"Python爬虫","slug":"Python爬虫","link":"/tags/Python%E7%88%AC%E8%99%AB/"},{"name":"编程","slug":"编程","link":"/tags/%E7%BC%96%E7%A8%8B/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"}],"categories":[{"name":"Hadoop","slug":"Hadoop","link":"/categories/Hadoop/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"问题杂记","slug":"问题杂记","link":"/categories/%E9%97%AE%E9%A2%98%E6%9D%82%E8%AE%B0/"},{"name":"技术分享","slug":"技术分享","link":"/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"auto.js","slug":"auto-js","link":"/categories/auto-js/"}]}